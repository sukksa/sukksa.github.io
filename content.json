{"meta":{"title":"sukksa blog","subtitle":"","description":"","author":"sukksa","url":"https://sukksa.github.io","root":"/"},"posts":[{"title":"将 Hexo 提交到仓库","date":"2025-11-26T01:27:34.000Z","path":"2025/other/将Hexo提交到仓库/","permalink":"https://sukksa.github.io/2025/other/%E5%B0%86Hexo%E6%8F%90%E4%BA%A4%E5%88%B0%E4%BB%93%E5%BA%93/","excerpt":"将 Hexo 提交到仓库这是一个 Hexo 双仓库管理问题（一个是用于存放静态网页的 xxx.github.io，一个是用于存放源代码的 hexo-code）。 提交不上去是因为Git 配置冲突或者**.gitignore 设置不当**造成的。","categories":[{"name":"git","slug":"git","permalink":"https://sukksa.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://sukksa.github.io/tags/git/"}]},{"title":"从现有git仓库切换到另一个仓库","date":"2025-11-25T13:51:08.000Z","path":"2025/other/从现有的仓库切换到另一个仓库/","permalink":"https://sukksa.github.io/2025/other/%E4%BB%8E%E7%8E%B0%E6%9C%89%E7%9A%84%E4%BB%93%E5%BA%93%E5%88%87%E6%8D%A2%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E4%BB%93%E5%BA%93/","excerpt":"从现有仓库切换到另一个仓库方法一：添加新的远程仓库此方法会保留原有的 origin（指向 url1），同时新增一个指向 url2 的远程仓库。这样本地仓库就可以同时与两个远程仓库进行通信。","categories":[{"name":"git","slug":"git","permalink":"https://sukksa.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://sukksa.github.io/tags/git/"}]},{"title":"《罪与罚》","date":"2025-11-25T13:49:08.000Z","path":"2025/note/《罪与罚》/","permalink":"https://sukksa.github.io/2025/note/%E3%80%8A%E7%BD%AA%E4%B8%8E%E7%BD%9A%E3%80%8B/","excerpt":"《罪与罚》这是继《钢铁是怎样炼成的》后阅读的第二本俄国文学，或许是第一本？本书作成时沙俄还未推翻罢。 和我印象中的俄国文学一样，光是开篇冗长的人名以及各种昵称都快将我劝退了，直到拉斯克尔尼科夫将放贷的老太婆谋杀后，我才提起兴趣罢。","categories":[{"name":"note","slug":"note","permalink":"https://sukksa.github.io/categories/note/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://sukksa.github.io/tags/Note/"}]},{"title":"仅显示某个行政区划（cesium 挖孔）","date":"2025-11-25T06:14:39.000Z","path":"2025/cesium/只显示某个区域/","permalink":"https://sukksa.github.io/2025/cesium/%E5%8F%AA%E6%98%BE%E7%A4%BA%E6%9F%90%E4%B8%AA%E5%8C%BA%E5%9F%9F/","excerpt":"添加polygon, 中间挖孔, 仅显示某个区域 GeoJSON为 GeoJSON , 行政区划下载","categories":[{"name":"cesium","slug":"cesium","permalink":"https://sukksa.github.io/categories/cesium/"}],"tags":[{"name":"cesium","slug":"cesium","permalink":"https://sukksa.github.io/tags/cesium/"}]},{"title":"第一个cesium项目","date":"2025-10-07T08:14:08.000Z","path":"2025/cesium/第一个cesium项目/","permalink":"https://sukksa.github.io/2025/cesium/%E7%AC%AC%E4%B8%80%E4%B8%AAcesium%E9%A1%B9%E7%9B%AE/","excerpt":"第一个cesium项目创建 Vite 项目这里使用vite搭建demo, 选择 Vanilla （代表原生 JS） 1npm create vite@latest my-cesium-demo","categories":[{"name":"cesium","slug":"cesium","permalink":"https://sukksa.github.io/categories/cesium/"}],"tags":[{"name":"cesium","slug":"cesium","permalink":"https://sukksa.github.io/tags/cesium/"},{"name":"vite","slug":"vite","permalink":"https://sukksa.github.io/tags/vite/"}]},{"title":"使用着色器绘制波浪","date":"2025-05-16T10:05:53.000Z","path":"2025/shader/着色器绘制波浪/","permalink":"https://sukksa.github.io/2025/shader/%E7%9D%80%E8%89%B2%E5%99%A8%E7%BB%98%E5%88%B6%E6%B3%A2%E6%B5%AA/","excerpt":"","categories":[{"name":"shader","slug":"shader","permalink":"https://sukksa.github.io/categories/shader/"}],"tags":[{"name":"Threejs","slug":"Threejs","permalink":"https://sukksa.github.io/tags/Threejs/"},{"name":"shader","slug":"shader","permalink":"https://sukksa.github.io/tags/shader/"}]},{"title":"使用着色器绘制图案","date":"2025-05-06T08:15:53.000Z","path":"2025/shader/着色器绘制图案/","permalink":"https://sukksa.github.io/2025/shader/%E7%9D%80%E8%89%B2%E5%99%A8%E7%BB%98%E5%88%B6%E5%9B%BE%E6%A1%88/","excerpt":"What is UV在创建着色器时，我们需要绘制特定的图案，如星星、圆圈、光透镜、波浪等。虽然可以使用纹理，但绘制形状可以让我们有更多的控制权;我们可以对形状参数进行动画处理，并且没有要加载的纹理。需要在fragment shader中用到uv坐标。 什么是uv坐标？ UV坐标是用来将2D纹理贴图到3D模型表面的坐标系。这里的U和V代表的是2D空间的两个轴，类似于平面中的X和Y，但为了避免与3D空间中的X、Y、Z混淆，所以用U和V来命名。 在Threejs中UV坐标的范围是0到1，覆盖整个纹理图像。原点(0,0)在左下角，而(1,1)在右上角。uv坐标的count取决于material的分段数 如何将uv坐标发送到fragment shader？ fragment shader无法直接访问顶点数据，所以我们需要通过 vertex shader 创建变量发送给 fragment shader。 Pattern 1直接使用 uv 坐标，原点的颜色为到右上角的渐变","categories":[{"name":"shader","slug":"shader","permalink":"https://sukksa.github.io/categories/shader/"}],"tags":[{"name":"Threejs","slug":"Threejs","permalink":"https://sukksa.github.io/tags/Threejs/"},{"name":"shader","slug":"shader","permalink":"https://sukksa.github.io/tags/shader/"}]},{"title":"第一个 shader 程序","date":"2025-05-06T08:10:38.000Z","path":"2025/shader/第一个着色器程序/","permalink":"https://sukksa.github.io/2025/shader/%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F/","excerpt":"shader 是用 GLSL(OpenGL Shading Language) 编写的程序，他会被发送到GPU运行。原生 WebGL 的一部分，如果不依赖任何库使用 WebGl 的话，需要自己动手创建 Shader。shader 会为几何体的每个顶点(vertex)定位，以及为几何体的所有可见片段（fragment）着色。 我们会为shader发送大量的数据，比如顶点坐标、网格变换信息、摄像机的信息以及几何体的顶点颜色、纹理等等。然后交给CPU，利用GLSL编写的着色器程序处理这些数据，最终在屏幕上定位顶点，并为每个可见片段着色 着色器有两种类型 vertex shader fragment shader Vertex Shader 顶点着色器会为每个几何体的顶点定位，当顶点着色器为顶点定位完之后，GPU 便知道哪些几何体的像素是可见的，然后进入片段着色器(fragment shader) fragment shader 片段着色器会为顶点着色，包括颜色，纹理，透明度等等。 https://learnopengl.com/Getting-started/Coordinate-Systems 为什么要自己编写着色器？为什么我们不能直接使用Threejs的内置材质？","categories":[{"name":"shader","slug":"shader","permalink":"https://sukksa.github.io/categories/shader/"}],"tags":[{"name":"Threejs","slug":"Threejs","permalink":"https://sukksa.github.io/tags/Threejs/"},{"name":"shader","slug":"shader","permalink":"https://sukksa.github.io/tags/shader/"}]},{"title":"THREE Modules","date":"2025-04-09T15:34:08.000Z","path":"2025/Threejs/Threejs Modules/","permalink":"https://sukksa.github.io/2025/Threejs/Threejs%20Modules/","excerpt":"export Experience Class首先创建一个类，将所有与 WebGL 相关的内容全部放在里面。大的类都在这儿实例化，并且设置为单例类。只有在第一次实例化时，会创建一个实例，若已经创建过实例对象，则会返回那个实例对象。类似于一个全局变量 Utils将 THREEjs 项目通过 class 和 modules 分割为许多小模块方便维护。 Size Class","categories":[{"name":"Threejs","slug":"Threejs","permalink":"https://sukksa.github.io/categories/Threejs/"}],"tags":[{"name":"Threejs","slug":"Threejs","permalink":"https://sukksa.github.io/tags/Threejs/"}]},{"title":"如何移除 GitHub 中的 contributors","date":"2025-04-05T13:57:08.000Z","path":"2025/other/如何移除 GitHub 中的 contributors/","permalink":"https://sukksa.github.io/2025/other/%E5%A6%82%E4%BD%95%E7%A7%BB%E9%99%A4%20GitHub%20%E4%B8%AD%E7%9A%84%20contributors/","excerpt":"如果你在某次 commit 时，忘记 git config 设置自己的 username 和 email了，发现仓库主页 contributors，多了一个contributor，那么如何才能移除呢？ 虽然官方没有移除contributor的办法，但是我们可以替换掉所有的username和email啊 这样全都是我们提交的了 通过 git filter-branch Git 内置的重写历史工具，允许批量修改提交记录。 --commit-filter指定一个自定义脚本，针对每个提交执行操作。脚本的返回值会替换原始提交。","categories":[{"name":"git","slug":"git","permalink":"https://sukksa.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://sukksa.github.io/tags/git/"}]},{"title":"Vuex","date":"2022-10-07T09:21:45.000Z","path":"2022/vue/Vuex/","permalink":"https://sukksa.github.io/2022/vue/Vuex/","excerpt":"VuexVuex 是在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间通信。","categories":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/tags/Vue/"}]},{"title":"Vue 插件","date":"2022-10-07T09:15:18.000Z","path":"2022/vue/Vue插件/","permalink":"https://sukksa.github.io/2022/vue/Vue%E6%8F%92%E4%BB%B6/","excerpt":"Vue 插件插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制,一般有下面几种： 添加全局方法或者 property。如：vue-custom-element 添加全局资源：指令&#x2F;过滤器&#x2F;过渡等。如 vue-touch 通过全局混入来添加一些组件选项。如 vue-router 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现 一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 vuex，vue-router","categories":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/tags/Vue/"}]},{"title":"vue-router","date":"2022-10-07T08:14:08.000Z","path":"2022/vue/Vue-router/","permalink":"https://sukksa.github.io/2022/vue/Vue-router/","excerpt":"vue-routervue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。我们可以访问其官方网站对其进行学习：https://router.vuejs.org/zh/ vue-router是基于路由和组件的 路由用户设定访问路径的，将路径和组件映射起来。 在vue-router的单页面应用中，页面的路径的改变就是组件的切换","categories":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/tags/Vue/"}]},{"title":"Mixin (混入)","date":"2022-10-07T08:14:08.000Z","path":"2022/vue/mixin/","permalink":"https://sukksa.github.io/2022/vue/mixin/","excerpt":"mixin混入 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项 Mixins 是一种分发 Vue 组件中可复用功能的非常灵活的一种方式。页面的风格不用，但是执行的方法和需要的数据类似就可以选择使用混入 混合对于封装一小段想要复用的代码来讲是有用的。它们当然不是唯一可行的。混合很好，它不需要传递状态，但是这种模式当然也可能会被滥用","categories":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/tags/Vue/"}]},{"title":"Vue 脚手架","date":"2022-10-06T15:54:08.000Z","path":"2022/vue/Vue脚手架/","permalink":"https://sukksa.github.io/2022/vue/Vue%E8%84%9A%E6%89%8B%E6%9E%B6/","excerpt":"Vue 脚手架 使用前置： 第一步(没有安装过的执行)：全局安装 @vue&#x2F;cli npm install -g @vue&#x2F;cli 第二步：切换到要创建项目的目录，然后使用命令创建项目 vue create xxxxx 第三步：启动项目 npm run serve","categories":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/tags/Vue/"}]},{"title":"组件间通信","date":"2022-10-06T13:25:42.000Z","path":"2022/vue/组件间通信/","permalink":"https://sukksa.github.io/2022/vue/%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1/","excerpt":"组件间通信props方式一个组件里面引入另外一个组件，此时构成了一种“父子关系”，当前组件为“父”，引入的组件为“子”，如当前组件（父），在父组件中通过 :message向子组件通信。","categories":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/tags/Vue/"}]},{"title":"按键修饰符","date":"2022-10-06T04:10:42.000Z","path":"2022/vue/按键修饰符/","permalink":"https://sukksa.github.io/2022/vue/%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/","excerpt":"按键修饰符在绑定了键盘或鼠标的点击事件后,可以通过按下的按键触发要进行的事件,这时需要在后方添加表示按键的修辞符","categories":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/tags/Vue/"}]},{"title":"Vue 组件","date":"2022-10-05T14:30:42.000Z","path":"2022/vue/组件/","permalink":"https://sukksa.github.io/2022/vue/%E7%BB%84%E4%BB%B6/","excerpt":"Vue 组件组件的定义组件的出现是为了拆分 Vue 实例的代码量，能够让我们以不同的组件来划分不同的功能模板，将来需要什么样的功能，只需要调用对应的组件就可以了 组件化与模块化的区别 模块化是从代码逻辑的角度进行划分的;方便代码分层开发，保证每个功能模块的职能单一 组件化是从 UI 界面的角度进行划分的，前端的组件化是为了方便 UI 组件的重用","categories":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/tags/Vue/"}]},{"title":"过渡与动画","date":"2022-10-05T12:35:27.000Z","path":"2022/vue/过渡与动画/","permalink":"https://sukksa.github.io/2022/vue/%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB/","excerpt":"过渡与动画Vue 中可以通过transition组件来实现过渡效果 Vue 在插入,更新或者移除 DOM 时,提供多种不同方式的应用过渡效果 在 CSS 过渡和动画中自动应用 class 可以配合使用第三方 CSS 动画库，如 Animate.css 在过渡钩子函数中使用 JavaScript 直接操作 DOM 可以配合使用第三方 JavaScript 动画库，如 Velocity.js","categories":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/tags/Vue/"}]},{"title":"Promise","date":"2022-10-03T14:48:08.000Z","path":"2022/ES6/Promise/","permalink":"https://sukksa.github.io/2022/ES6/Promise/","excerpt":"PromisePromise 是什么理解 PromisePromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件(通常是一个异步操作)的结果。 从语法上看：Promise是一个构造函数 (自己身上有all、reject、resolve这几个方法，原型上有then、catch等方法) 功能上看：promise对象用来封装一个异步操作并可以获取其成功&#x2F;失败的结果值","categories":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/categories/ES6/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/tags/ES6/"}]},{"title":"Vue 基本指令","date":"2022-09-17T15:23:42.000Z","path":"2022/vue/Vue指令/","permalink":"https://sukksa.github.io/2022/vue/Vue%E6%8C%87%E4%BB%A4/","excerpt":"Vue 基本指令v-textv-text，该指令的用法同原生 JS 中的 innerText，更新绑定元素内部的文本内容 &lt;div id=&quot;div&quot;&gt; &lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt; &lt;!--不会有闪烁问题--&gt;&lt;!-- 和下面的一样 --&gt; &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt; &lt;/div&gt; 与插值语法的区别：v-text会替换掉节点中的内容，&#123;&#123;xx&#125;&#125;则不会。","categories":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/tags/Vue/"}]},{"title":"Vue 生命周期","date":"2022-09-17T14:14:08.000Z","path":"2022/vue/Vue生命周期/","permalink":"https://sukksa.github.io/2022/vue/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"Vue 生命周期生命周期又名：生命周期回调函数、生命周期函数、生命周期钩子。 是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。 生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。 生命周期函数中的this指向是vm 或 组件实例对象。","categories":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/tags/Vue/"}]},{"title":"Vue实例对象","date":"2022-07-29T15:58:08.000Z","path":"2022/vue/Vue实例对象/","permalink":"https://sukksa.github.io/2022/vue/Vue%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1/","excerpt":"Vue实例对象创建并绑定 Vue 对象Vue 也是一个构造函数,通过 new Vue()可以创建一个 Vue 对象,通过 Vue 对象进行对 DOM 元素以及内部的子孙元素的操作 new Vue(&#123; el: &#39;#div&#39;, /* 在Vue中通过el属性来绑定一个DOM元素,从而让该DOM元素以及内部都绑定Vue的相关操作,一般是通过ID进行查找,因为这样才能够精确绑定 */ data: &#123; //data属性中包含着在el中使用的使用的变量或属性 msg: 123, &#125;, //也可以使用函数形式的 data() &#123; return &#123; msg: 123, &#125; &#125;, //methods属性包含着需要使用的方法 methods: &#123; show() &#123; console.log(this.msg) &#125;, &#125;, &#125;) 注:在实例内部使用定义的属性或方法时不能直接使用,必须通过 this 来指定需要用的属性","categories":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/tags/Vue/"}]},{"title":"字符串的扩展","date":"2022-07-26T13:19:08.000Z","path":"2022/ES6/字符串的扩展/","permalink":"https://sukksa.github.io/2022/ES6/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/","excerpt":"字符串的扩展字符的 Unicode 表示法JavaScript 允许采用\\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。 &#39;\\u0061&#39; // &quot;a&quot; 但是，这种表示法只限于码点在\\u0000~\\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示","categories":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/categories/ES6/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/tags/ES6/"}]},{"title":"Module 的加载实现","date":"2022-07-23T07:58:59.000Z","path":"2022/ES6/Moudle 的加载实现/","permalink":"https://sukksa.github.io/2022/ES6/Moudle%20%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/","excerpt":"Module 的加载实现本章介绍如何在浏览器和 Node 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题(比如循环加载) 浏览器加载传统方法在 HTML 网页中，浏览器通过&lt;script&gt;标签加载 JavaScript 脚本。","categories":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/categories/ES6/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/tags/ES6/"}]},{"title":"Module 模块化","date":"2022-07-21T07:32:08.000Z","path":"2022/ES6/模块化 module/","permalink":"https://sukksa.github.io/2022/ES6/%E6%A8%A1%E5%9D%97%E5%8C%96%20module/","excerpt":"模块化 module基本概述历史上，JavaScript 一直没有模块(module)体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。 在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案","categories":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/categories/ES6/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/tags/ES6/"}]},{"title":"对象的扩展","date":"2022-07-19T07:57:08.000Z","path":"2022/ES6/对象的扩展/","permalink":"https://sukksa.github.io/2022/ES6/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/","excerpt":"对象的扩展属性的简介表示ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。 const foo = &quot;bar&quot; const baz = &#123; foo &#125; baz // &#123;foo: &quot;bar&quot;&#125; // 等同于 // const baz = &#123; foo: foo &#125;","categories":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/categories/ES6/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/tags/ES6/"}]},{"title":"Class的基本用法","date":"2022-06-25T07:22:19.000Z","path":"2022/ES6/Class的继承/","permalink":"https://sukksa.github.io/2022/ES6/Class%E7%9A%84%E7%BB%A7%E6%89%BF/","excerpt":"Class的基本用法Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。","categories":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/categories/ES6/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/tags/ES6/"}]},{"title":"Class的基本用法","date":"2022-06-24T07:11:40.000Z","path":"2022/ES6/Class的基本用法/","permalink":"https://sukksa.github.io/2022/ES6/Class%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/","excerpt":"Class的基本用法ES6 提供了更接近传统语言的写法，引入了 Class(类)这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。","categories":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/categories/ES6/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/tags/ES6/"}]},{"title":"set 与 map","date":"2021-12-18T01:11:59.000Z","path":"2021/ES6/set与map/","permalink":"https://sukksa.github.io/2021/ES6/set%E4%B8%8Emap/","excerpt":"set 与 mapset基本用法ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set 本身是一个构造函数，用来生成 Set 数据结构。","categories":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/categories/ES6/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/tags/ES6/"}]},{"title":"Ajax跨域","date":"2021-12-05T07:08:27.000Z","path":"2021/Ajax/Ajax跨域请求/","permalink":"https://sukksa.github.io/2021/Ajax/Ajax%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/","excerpt":"Ajax跨域同源策略同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）","categories":[{"name":"Ajax","slug":"Ajax","permalink":"https://sukksa.github.io/categories/Ajax/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://sukksa.github.io/tags/Ajax/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://sukksa.github.io/tags/JavaScript/"}]},{"title":"Axios","date":"2021-11-24T12:35:27.000Z","path":"2021/Ajax/Axios/","permalink":"https://sukksa.github.io/2021/Ajax/Axios/","excerpt":"Axios创建 APIAPI 的分类 REST API: restful （Representational State Transfer (资源)表现层状态转化） 发送请求进行CRUD 哪个操作由请求方式来决定 同一个请求路径可以进行多个操作 请求方式会用到GET&#x2F;POST&#x2F;PUT&#x2F;DELETE 非REST API: restless 请求方式不决定请求的CRUD 操作 一个请求路径只对应一个操作 一般只有GET&#x2F;POST","categories":[{"name":"Ajax","slug":"Ajax","permalink":"https://sukksa.github.io/categories/Ajax/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://sukksa.github.io/tags/Ajax/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://sukksa.github.io/tags/JavaScript/"}]},{"title":"Fetch","date":"2021-11-24T12:35:27.000Z","path":"2021/Ajax/Fetch/","permalink":"https://sukksa.github.io/2021/Ajax/Fetch/","excerpt":"Fetchfetch 是一种 HTTP 数据请求的方式，是 XMLHttpRequest 的一种替代方案。fetch 不是 ajax 的进一步封装，而是原生 js。Fetch 函数就是原生 js，没有使用 XMLHttpRequest 对象","categories":[{"name":"Ajax","slug":"Ajax","permalink":"https://sukksa.github.io/categories/Ajax/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://sukksa.github.io/tags/Ajax/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://sukksa.github.io/tags/JavaScript/"}]},{"title":"原生Ajax","date":"2021-11-22T13:59:27.000Z","path":"2021/Ajax/原生Ajax/","permalink":"https://sukksa.github.io/2021/Ajax/%E5%8E%9F%E7%94%9FAjax/","excerpt":"原生AjaxAjax 全称 Asynchronous JavaScript and XML(异步的 JavaScript 和 XML)，既是一个对象，也是一种方法模式 AJAX 是一种用于创建快速动态网页的技术，通过在后台与服务器进行少量数据交换,Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新，传统的不使用 Ajax 的网页如果需要更新内容,必需重载整个网页","categories":[{"name":"Ajax","slug":"Ajax","permalink":"https://sukksa.github.io/categories/Ajax/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://sukksa.github.io/tags/Ajax/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://sukksa.github.io/tags/JavaScript/"}]},{"title":"node","date":"2021-11-18T11:18:41.000Z","path":"2021/node/node/","permalink":"https://sukksa.github.io/2021/node/node/","excerpt":"node简介Node是对ES标准一个实现，Node也是一个JS引擎，通过Node可以使js代码在服务器端执行，Node仅仅对ES标准进行了实现，所以在Node中不包含DOM 和 BOM","categories":[{"name":"node","slug":"node","permalink":"https://sukksa.github.io/categories/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://sukksa.github.io/tags/node/"}]},{"title":"less","date":"2021-11-15T12:13:01.000Z","path":"2021/less/less/","permalink":"https://sukksa.github.io/2021/less/less/","excerpt":"lessless 是一种动态样式语言,属于 CSS 预处理器的范畴,它拓展了 CSS 语言,其余的 CSS 预处理器有 sass 和 stylus 等 less 增加了变量,MIxin,函数等特性,使 CSS 更易维护和扩展,less 既可以在客户端上运行,也可以借助 node.js 在服务端 运行","categories":[{"name":"less","slug":"less","permalink":"https://sukksa.github.io/categories/less/"}],"tags":[{"name":"less","slug":"less","permalink":"https://sukksa.github.io/tags/less/"}]},{"title":"Symbol","date":"2021-11-11T06:08:35.000Z","path":"2021/ES6/Symbol/","permalink":"https://sukksa.github.io/2021/ES6/Symbol/","excerpt":"SymbolES5 的对象属性名都是字符串，这容易造成属性名的冲突。如在对象中添加一个方法，这个方法名有可能导致重名，引起冲突 ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型 对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突","categories":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/categories/ES6/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/tags/ES6/"}]},{"title":"函数的扩展","date":"2021-11-08T12:57:08.000Z","path":"2021/ES6/函数的扩展/","permalink":"https://sukksa.github.io/2021/ES6/%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/","excerpt":"函数的扩展函数参数的默认值ES6 允许给函数参数赋值初始值","categories":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/categories/ES6/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/tags/ES6/"}]},{"title":"变量解构赋值","date":"2021-11-06T05:57:08.000Z","path":"2021/ES6/变量解构赋值/","permalink":"https://sukksa.github.io/2021/ES6/%E5%8F%98%E9%87%8F%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/","excerpt":"变量的解构赋值ES6 允许按照一定模式从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。","categories":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/categories/ES6/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/tags/ES6/"}]},{"title":"let与const","date":"2021-10-30T10:02:40.000Z","path":"2021/ES6/let与const/","permalink":"https://sukksa.github.io/2021/ES6/let%E4%B8%8Econst/","excerpt":"let与conset在ES6中引入了变量声明的两种方式，let 与 conset let 用来声明变量 conset 用来声明常量","categories":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/categories/ES6/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/tags/ES6/"}]},{"title":"ES6简介","date":"2021-10-30T10:00:28.000Z","path":"2021/ES6/ES6简介/","permalink":"https://sukksa.github.io/2021/ES6/ES6%E7%AE%80%E4%BB%8B/","excerpt":"ES6简介ECMAScript 6.0(以下简称 ES6)是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。","categories":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/categories/ES6/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/tags/ES6/"}]},{"title":"jQuery轮播图","date":"2021-10-26T14:13:14.000Z","path":"2021/实战/jQuery轮播图/","permalink":"https://sukksa.github.io/2021/%E5%AE%9E%E6%88%98/jQuery%E8%BD%AE%E6%92%AD%E5%9B%BE/","excerpt":"jQuery实现轮播图 功能说明: 点击向右(左)的图标, 平滑切换到下(上)一页 无限循环切换: 第一页的上一页为最后页, 最后一页的下一页是第一页 每隔3s自动滑动到下一页 当鼠标进入图片区域时, 自动切换停止, 当鼠标离开后,又开始自动切换 切换页面时, 下面的圆点也同步更新 点击圆点图标切换到对应的页 bug: 快速点击时, 翻页不正常","categories":[{"name":"实战","slug":"实战","permalink":"https://sukksa.github.io/categories/%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"https://sukksa.github.io/tags/DOM/"},{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/tags/jQuery/"}]},{"title":"jQuery插件","date":"2021-10-24T12:21:52.000Z","path":"2021/jQuery/jQuery插件/","permalink":"https://sukksa.github.io/2021/jQuery/jQuery%E6%8F%92%E4%BB%B6/","excerpt":"jQuery插件 我们可以扩展 jQuery 来实现自定义方法。这种方式也称为编写 jQuery 插件。 在使用jQuery插件时，应该先引入jQuery库文件，然后在引用jQuery插件","categories":[{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/tags/jQuery/"}]},{"title":"jQuery动画","date":"2021-10-24T06:11:29.000Z","path":"2021/jQuery/jQuery动画/","permalink":"https://sukksa.github.io/2021/jQuery/jQuery%E5%8A%A8%E7%94%BB/","excerpt":"jQuery动画slideUp &#x2F; slideDown滑动动画: 通过不断改变元素的高度(height)实现 slideDown(): 带动画的展开 slideUp(): 带动画的收缩 slideToggle(): 带动画的切换展开&#x2F;收缩","categories":[{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/tags/jQuery/"}]},{"title":"jQuery事件","date":"2021-10-20T16:46:14.000Z","path":"2021/jQuery/jQuery事件/","permalink":"https://sukksa.github.io/2021/jQuery/jQuery%E4%BA%8B%E4%BB%B6/","excerpt":"jQuery事件因为 JavaScript 在浏览器中以单线程模式运行，页面加载后，一旦页面上所有的 JavaScript 代码被执行完后，就只能依赖触发事件来执行 JavaScript 代码。浏览器在接收到用户的鼠标或键盘输入后，会自动在对应的 DOM 节点上触发相应的事件。如果该节点已经绑定了对应的 JavaScript 处理函数，该函数就会自动调用。","categories":[{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/tags/jQuery/"}]},{"title":"jQuery修改DOM结构","date":"2021-10-20T13:26:54.000Z","path":"2021/jQuery/jQuery修改DOM结构/","permalink":"https://sukksa.github.io/2021/jQuery/jQuery%E4%BF%AE%E6%94%B9DOM%E7%BB%93%E6%9E%84/","excerpt":"修改DOM结构直接使用浏览器提供的 API 对 DOM 结构进行修改，不但代码复杂，而且要针对浏览器写不同的代码。 有了 jQuery，我们就专注于操作 jQuery 对象本身，底层的 DOM 操作由 jQuery 完成就可以了，这样一来，修改 DOM 也大大简化了","categories":[{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/tags/jQuery/"}]},{"title":"jQuery操作DOM元素","date":"2021-10-20T12:40:59.000Z","path":"2021/jQuery/jQuery操作DOM/","permalink":"https://sukksa.github.io/2021/jQuery/jQuery%E6%93%8D%E4%BD%9CDOM/","excerpt":"jQuery操作DOMjQuery对象提供了许多修改DOM元素的功能","categories":[{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/tags/jQuery/"}]},{"title":"jQuery选择器","date":"2021-10-19T02:55:03.000Z","path":"2021/jQuery/jQuery选择器/","permalink":"https://sukksa.github.io/2021/jQuery/jQuery%E9%80%89%E6%8B%A9%E5%99%A8/","excerpt":"jQuery选择器 jQuery 选择器允许对 HTML 元素组或单个元素进行操作。 jQuery 选择器基于元素的 id、类、类型、属性、属性值等”查找”（或选择）HTML 元素。 它基于已经存在的 CSS 选择器，除此之外，它还有一些自定义的选择器。 jQuery 中所有选择器都以美元符号开头：$()。 jQuery选择器不是同时执行，而是顺序执行","categories":[{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/tags/jQuery/"}]},{"title":"jQuery介绍","date":"2021-10-18T16:03:28.000Z","path":"2021/jQuery/jQuery简介/","permalink":"https://sukksa.github.io/2021/jQuery/jQuery%E7%AE%80%E4%BB%8B/","excerpt":"jQuery介绍jQuery 是 JavaScript 世界中使用最广泛的一个库。鼎盛时期全世界大约有 80~90%的网站直接或间接地使用了 jQuery。","categories":[{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/tags/jQuery/"}]},{"title":"线程机制与事件机制","date":"2021-10-17T15:36:27.000Z","path":"2021/javaScript/线程机制与事件机制/","permalink":"https://sukksa.github.io/2021/javaScript/%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/","excerpt":"线程 进程：程序的一次执行, 它占有一片独有的内存空间 线程： CPU的基本调度单位, 是程序执行的一个完整流程","categories":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"对象","date":"2021-10-17T15:13:23.000Z","path":"2021/javaScript/对象/","permalink":"https://sukksa.github.io/2021/javaScript/%E5%AF%B9%E8%B1%A1/","excerpt":"对象（Object） 对象是JS中的引用数据类型 对象是一种复合数据类型，在对象中可以保存多个不同数据类型的属性 使用typeof检查一个对象时，会返回object","categories":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"函数","date":"2021-10-15T15:17:45.000Z","path":"2021/javaScript/函数/","permalink":"https://sukksa.github.io/2021/javaScript/%E5%87%BD%E6%95%B0/","excerpt":"函数（Function） 函数也是一个对象，也具有普通对象的功能 函数中可以封装一些代码，在需要的时候可以去调用函数来执行这些代码 使用typeof检查一个函数时会返回function","categories":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"事件","date":"2021-10-15T13:51:28.000Z","path":"2021/DOM/事件/","permalink":"https://sukksa.github.io/2021/DOM/%E4%BA%8B%E4%BB%B6/","excerpt":"事件HTML 事件是发生在 HTML 元素上的事情。 当在 HTML 页面中使用 JavaScript 时， JavaScript 可以触发这些事件。","categories":[{"name":"DOM","slug":"DOM","permalink":"https://sukksa.github.io/categories/DOM/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"https://sukksa.github.io/tags/DOM/"}]},{"title":"变量与作用域","date":"2021-10-15T13:49:28.000Z","path":"2021/javaScript/变量与作用域/","permalink":"https://sukksa.github.io/2021/javaScript/%E5%8F%98%E9%87%8F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/","excerpt":"变量 字面量字面量（常量），都是一些不可改变的值比如 ：1 2 3 4 5字面量都是可以直接使用，但是我们一般都不会直接使用字面量 变量变量可以用来保存字面量，而且变量的值是可以任意改变的变量更加方便我们使用，所以在开发中都是通过变量去保存一个字面量，而很少直接使用字面量，可以通过变量对字面量进行描述","categories":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"事件对象","date":"2021-04-27T12:47:26.000Z","path":"2021/DOM/事件对象/","permalink":"https://sukksa.github.io/2021/DOM/%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/","excerpt":"事件对象 当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递进响应函数,在事件对象中封装了当前事件相关的一切信息，比如：鼠标的坐标，键盘哪个按键被按下，鼠标滚轮滚动的方向…","categories":[{"name":"DOM","slug":"DOM","permalink":"https://sukksa.github.io/categories/DOM/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"https://sukksa.github.io/tags/DOM/"},{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"DOM介绍","date":"2021-04-27T12:45:31.000Z","path":"2021/DOM/DOM/","permalink":"https://sukksa.github.io/2021/DOM/DOM/","excerpt":"DOM DOM全称Document Object Model(文档对象模型) 文档:整个HTML网页文档对象 对象:网页中的每一个部分都被转换为了一个对象 模型:使用模型表示对象之间的关系，方便我们获取对象","categories":[{"name":"DOM","slug":"DOM","permalink":"https://sukksa.github.io/categories/DOM/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"https://sukksa.github.io/tags/DOM/"},{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"字符串方法","date":"2021-04-27T07:25:31.000Z","path":"2021/javaScript/字符串方法/","permalink":"https://sukksa.github.io/2021/javaScript/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95/","excerpt":"字符串的相关方法 在底层字符串是以字符数组的形式保存的 var str &#x3D; “abc”;&#x2F;&#x2F; [“a”,”b”,”c”] length属性 可以用来获取字符串的长度 console.log(str.length); &#x2F;&#x2F;输出字符串str的长度","categories":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"正则表达式","date":"2021-04-27T07:23:30.000Z","path":"2021/javaScript/正则表达式/","permalink":"https://sukksa.github.io/2021/javaScript/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"正则表达式正则表达式用于定义一些字符串的规则，计算机可以根据正则表达式，来检查一个字符串是否符合规则，获取将字符串中符合规则的内容提取出来","categories":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"数组","date":"2021-04-27T07:21:47.000Z","path":"2021/javaScript/数组/","permalink":"https://sukksa.github.io/2021/javaScript/%E6%95%B0%E7%BB%84/","excerpt":"数组 数组也是一个对象 普通对象是使用字符串作为属性名的，而数组时使用数字来作为索引操作元素 数组中的元素可以是任意的数据类型，可以是对象","categories":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"类型转换","date":"2021-04-27T07:18:39.000Z","path":"2021/javaScript/类型转换/","permalink":"https://sukksa.github.io/2021/javaScript/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"类型转换 类型转换就是指将其他的数据类型，转换为String Number 或 Boolean","categories":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"基本语法","date":"2021-04-27T07:15:36.000Z","path":"2021/javaScript/基本语法/","permalink":"https://sukksa.github.io/2021/javaScript/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"JavaScript的基本语法JavaScript编写位置 可以将js代码编写到标签的onclick属性或超链接的href属性中（当我们点击按钮时，js代码才会执行 123&lt;button onclick=&quot;alert(&#x27;xxx&#x27;);&quot;&gt;button&lt;/button&gt;`&lt;a href=&quot;javascript:alert(&#x27;xxx&#x27;);&quot;&gt;&lt;/a&gt;&lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt; 可以将js代码编写到script标签 1&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;我是script标签中的代码&quot;);&lt;/script&gt; 可以将js代码编写到外部js文件中，然后通过script标签引入 1&lt;script type=&quot;text/javascript&quot; src=&quot;js/script.js&quot;&gt;&lt;/script&gt; 注：script标签一旦用于引入外部文件了，就不能在编写代码了，即使编写了浏览器也会忽略如果需要则可以在创建一个新的script标签用于编写内部代码","categories":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]}],"categories":[{"name":"git","slug":"git","permalink":"https://sukksa.github.io/categories/git/"},{"name":"note","slug":"note","permalink":"https://sukksa.github.io/categories/note/"},{"name":"cesium","slug":"cesium","permalink":"https://sukksa.github.io/categories/cesium/"},{"name":"shader","slug":"shader","permalink":"https://sukksa.github.io/categories/shader/"},{"name":"Threejs","slug":"Threejs","permalink":"https://sukksa.github.io/categories/Threejs/"},{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/categories/Vue/"},{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/categories/ES6/"},{"name":"Ajax","slug":"Ajax","permalink":"https://sukksa.github.io/categories/Ajax/"},{"name":"node","slug":"node","permalink":"https://sukksa.github.io/categories/node/"},{"name":"less","slug":"less","permalink":"https://sukksa.github.io/categories/less/"},{"name":"实战","slug":"实战","permalink":"https://sukksa.github.io/categories/%E5%AE%9E%E6%88%98/"},{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/categories/jQuery/"},{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/categories/javaScript/"},{"name":"DOM","slug":"DOM","permalink":"https://sukksa.github.io/categories/DOM/"}],"tags":[{"name":"git","slug":"git","permalink":"https://sukksa.github.io/tags/git/"},{"name":"Note","slug":"Note","permalink":"https://sukksa.github.io/tags/Note/"},{"name":"cesium","slug":"cesium","permalink":"https://sukksa.github.io/tags/cesium/"},{"name":"vite","slug":"vite","permalink":"https://sukksa.github.io/tags/vite/"},{"name":"Threejs","slug":"Threejs","permalink":"https://sukksa.github.io/tags/Threejs/"},{"name":"shader","slug":"shader","permalink":"https://sukksa.github.io/tags/shader/"},{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/tags/Vue/"},{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/tags/ES6/"},{"name":"Ajax","slug":"Ajax","permalink":"https://sukksa.github.io/tags/Ajax/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://sukksa.github.io/tags/JavaScript/"},{"name":"node","slug":"node","permalink":"https://sukksa.github.io/tags/node/"},{"name":"less","slug":"less","permalink":"https://sukksa.github.io/tags/less/"},{"name":"DOM","slug":"DOM","permalink":"https://sukksa.github.io/tags/DOM/"},{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/tags/jQuery/"}]}