{"meta":{"title":"sukksa blog","subtitle":"","description":"","author":"sukksa","url":"https://sukksa.github.io","root":"/"},"posts":[{"title":"使用着色器绘制波浪","date":"2025-05-16T09:05:53.000Z","path":"2025/shader/着色器绘制波浪/","permalink":"https://sukksa.github.io/2025/shader/%E7%9D%80%E8%89%B2%E5%99%A8%E7%BB%98%E5%88%B6%E6%B3%A2%E6%B5%AA/","excerpt":"","categories":[{"name":"shader","slug":"shader","permalink":"https://sukksa.github.io/categories/shader/"}],"tags":[{"name":"Threejs","slug":"Threejs","permalink":"https://sukksa.github.io/tags/Threejs/"},{"name":"shader","slug":"shader","permalink":"https://sukksa.github.io/tags/shader/"}]},{"title":"使用着色器绘制图案","date":"2025-05-06T07:15:53.000Z","path":"2025/shader/着色器绘制图案/","permalink":"https://sukksa.github.io/2025/shader/%E7%9D%80%E8%89%B2%E5%99%A8%E7%BB%98%E5%88%B6%E5%9B%BE%E6%A1%88/","excerpt":"What is UV在创建着色器时，我们需要绘制特定的图案，如星星、圆圈、光透镜、波浪等。虽然可以使用纹理，但绘制形状可以让我们有更多的控制权;我们可以对形状参数进行动画处理，并且没有要加载的纹理。需要在fragment shader中用到uv坐标。 什么是uv坐标？ UV坐标是用来将2D纹理贴图到3D模型表面的坐标系。这里的U和V代表的是2D空间的两个轴，类似于平面中的X和Y，但为了避免与3D空间中的X、Y、Z混淆，所以用U和V来命名。 在Threejs中UV坐标的范围是0到1，覆盖整个纹理图像。原点(0,0)在左下角，而(1,1)在右上角。uv坐标的count取决于material的分段数 如何将uv坐标发送到fragment shader？ fragment shader无法直接访问顶点数据，所以我们需要通过 vertex shader 创建变量发送给 fragment shader。 Pattern 1直接使用 uv 坐标，原点的颜色为到右上角的渐变","categories":[{"name":"shader","slug":"shader","permalink":"https://sukksa.github.io/categories/shader/"}],"tags":[{"name":"Threejs","slug":"Threejs","permalink":"https://sukksa.github.io/tags/Threejs/"},{"name":"shader","slug":"shader","permalink":"https://sukksa.github.io/tags/shader/"}]},{"title":"第一个 shader 程序","date":"2025-05-06T07:10:38.000Z","path":"2025/shader/第一个着色器程序/","permalink":"https://sukksa.github.io/2025/shader/%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F/","excerpt":"shader 是用 GLSL(OpenGL Shading Language) 编写的程序，他会被发送到GPU运行。原生 WebGL 的一部分，如果不依赖任何库使用 WebGl 的话，需要自己动手创建 Shader。shader 会为几何体的每个顶点(vertex)定位，以及为几何体的所有可见片段（fragment）着色。 我们会为shader发送大量的数据，比如顶点坐标、网格变换信息、摄像机的信息以及几何体的顶点颜色、纹理等等。然后交给CPU，利用GLSL编写的着色器程序处理这些数据，最终在屏幕上定位顶点，并为每个可见片段着色 着色器有两种类型 vertex shader fragment shader Vertex Shader 顶点着色器会为每个几何体的顶点定位，当顶点着色器为顶点定位完之后，GPU 便知道哪些几何体的像素是可见的，然后进入片段着色器(fragment shader) fragment shader 片段着色器会为顶点着色，包括颜色，纹理，透明度等等。 https://learnopengl.com/Getting-started/Coordinate-Systems 为什么要自己编写着色器？为什么我们不能直接使用Threejs的内置材质？","categories":[{"name":"shader","slug":"shader","permalink":"https://sukksa.github.io/categories/shader/"}],"tags":[{"name":"Threejs","slug":"Threejs","permalink":"https://sukksa.github.io/tags/Threejs/"},{"name":"shader","slug":"shader","permalink":"https://sukksa.github.io/tags/shader/"}]},{"title":"THREE Modules","date":"2025-04-09T14:34:08.000Z","path":"2025/Threejs/Threejs Modules/","permalink":"https://sukksa.github.io/2025/Threejs/Threejs%20Modules/","excerpt":"export Experience Class首先创建一个类，将所有与 WebGL 相关的内容全部放在里面。大的类都在这儿实例化，并且设置为单例类。只有在第一次实例化时，会创建一个实例，若已经创建过实例对象，则会返回那个实例对象。类似于一个全局变量 Utils将 THREEjs 项目通过 class 和 modules 分割为许多小模块方便维护。 Size Class","categories":[{"name":"Threejs","slug":"Threejs","permalink":"https://sukksa.github.io/categories/Threejs/"}],"tags":[{"name":"Threejs","slug":"Threejs","permalink":"https://sukksa.github.io/tags/Threejs/"}]},{"title":"如何移除 GitHub 中的 contributors","date":"2025-04-05T12:57:08.000Z","path":"2025/other/如何移除 GitHub 中的 contributors/","permalink":"https://sukksa.github.io/2025/other/%E5%A6%82%E4%BD%95%E7%A7%BB%E9%99%A4%20GitHub%20%E4%B8%AD%E7%9A%84%20contributors/","excerpt":"如果你在某次 commit 时，忘记 git config 设置自己的 username 和 email了，发现仓库主页 contributors，多了一个contributor，那么如何才能移除呢？ 虽然官方没有移除contributor的办法，但是我们可以替换掉所有的username和email啊 这样全都是我们提交的了 通过 git filter-branch Git 内置的重写历史工具，允许批量修改提交记录。 --commit-filter指定一个自定义脚本，针对每个提交执行操作。脚本的返回值会替换原始提交。","categories":[{"name":"git","slug":"git","permalink":"https://sukksa.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://sukksa.github.io/tags/git/"}]},{"title":"Hello World","date":"2025-04-03T12:37:14.075Z","path":"2025/hello-world/","permalink":"https://sukksa.github.io/2025/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files","categories":[],"tags":[]},{"title":"Vuex","date":"2022-10-07T08:21:45.000Z","path":"2022/vue/Vuex/","permalink":"https://sukksa.github.io/2022/vue/Vuex/","excerpt":"VuexVuex 是在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间通信。","categories":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/tags/Vue/"}]},{"title":"Vue 插件","date":"2022-10-07T08:15:18.000Z","path":"2022/vue/Vue插件/","permalink":"https://sukksa.github.io/2022/vue/Vue%E6%8F%92%E4%BB%B6/","excerpt":"Vue 插件插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制,一般有下面几种： 添加全局方法或者 property。如：vue-custom-element 添加全局资源：指令&#x2F;过滤器&#x2F;过渡等。如 vue-touch 通过全局混入来添加一些组件选项。如 vue-router 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现 一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 vuex，vue-router","categories":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/tags/Vue/"}]},{"title":"vue-router","date":"2022-10-07T07:14:08.000Z","path":"2022/vue/Vue-router/","permalink":"https://sukksa.github.io/2022/vue/Vue-router/","excerpt":"vue-routervue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。我们可以访问其官方网站对其进行学习：https://router.vuejs.org/zh/ vue-router是基于路由和组件的 路由用户设定访问路径的，将路径和组件映射起来。 在vue-router的单页面应用中，页面的路径的改变就是组件的切换","categories":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/tags/Vue/"}]},{"title":"Mixin (混入)","date":"2022-10-07T07:14:08.000Z","path":"2022/vue/mixin/","permalink":"https://sukksa.github.io/2022/vue/mixin/","excerpt":"mixin混入 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项 Mixins 是一种分发 Vue 组件中可复用功能的非常灵活的一种方式。页面的风格不用，但是执行的方法和需要的数据类似就可以选择使用混入 混合对于封装一小段想要复用的代码来讲是有用的。它们当然不是唯一可行的。混合很好，它不需要传递状态，但是这种模式当然也可能会被滥用","categories":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/tags/Vue/"}]},{"title":"Vue 脚手架","date":"2022-10-06T14:54:08.000Z","path":"2022/vue/Vue脚手架/","permalink":"https://sukksa.github.io/2022/vue/Vue%E8%84%9A%E6%89%8B%E6%9E%B6/","excerpt":"Vue 脚手架 使用前置： 第一步(没有安装过的执行)：全局安装 @vue&#x2F;cli npm install -g @vue&#x2F;cli 第二步：切换到要创建项目的目录，然后使用命令创建项目 vue create xxxxx 第三步：启动项目 npm run serve","categories":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/tags/Vue/"}]},{"title":"组件间通信","date":"2022-10-06T12:25:42.000Z","path":"2022/vue/组件间通信/","permalink":"https://sukksa.github.io/2022/vue/%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1/","excerpt":"组件间通信props方式一个组件里面引入另外一个组件，此时构成了一种“父子关系”，当前组件为“父”，引入的组件为“子”，如当前组件（父），在父组件中通过 :message向子组件通信。","categories":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/tags/Vue/"}]},{"title":"按键修饰符","date":"2022-10-06T03:10:42.000Z","path":"2022/vue/按键修饰符/","permalink":"https://sukksa.github.io/2022/vue/%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/","excerpt":"按键修饰符在绑定了键盘或鼠标的点击事件后,可以通过按下的按键触发要进行的事件,这时需要在后方添加表示按键的修辞符","categories":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/tags/Vue/"}]},{"title":"Vue 组件","date":"2022-10-05T13:30:42.000Z","path":"2022/vue/组件/","permalink":"https://sukksa.github.io/2022/vue/%E7%BB%84%E4%BB%B6/","excerpt":"Vue 组件组件的定义组件的出现是为了拆分 Vue 实例的代码量，能够让我们以不同的组件来划分不同的功能模板，将来需要什么样的功能，只需要调用对应的组件就可以了 组件化与模块化的区别 模块化是从代码逻辑的角度进行划分的;方便代码分层开发，保证每个功能模块的职能单一 组件化是从 UI 界面的角度进行划分的，前端的组件化是为了方便 UI 组件的重用","categories":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/tags/Vue/"}]},{"title":"过渡与动画","date":"2022-10-05T11:35:27.000Z","path":"2022/vue/过渡与动画/","permalink":"https://sukksa.github.io/2022/vue/%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB/","excerpt":"过渡与动画Vue 中可以通过transition组件来实现过渡效果 Vue 在插入,更新或者移除 DOM 时,提供多种不同方式的应用过渡效果 在 CSS 过渡和动画中自动应用 class 可以配合使用第三方 CSS 动画库，如 Animate.css 在过渡钩子函数中使用 JavaScript 直接操作 DOM 可以配合使用第三方 JavaScript 动画库，如 Velocity.js","categories":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/tags/Vue/"}]},{"title":"Promise","date":"2022-10-03T13:48:08.000Z","path":"2022/ES6/Promise/","permalink":"https://sukksa.github.io/2022/ES6/Promise/","excerpt":"PromisePromise 是什么理解 PromisePromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件(通常是一个异步操作)的结果。 从语法上看：Promise是一个构造函数 (自己身上有all、reject、resolve这几个方法，原型上有then、catch等方法) 功能上看：promise对象用来封装一个异步操作并可以获取其成功&#x2F;失败的结果值","categories":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/tags/ES6/"},{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"Vue 基本指令","date":"2022-09-17T14:23:42.000Z","path":"2022/vue/Vue指令/","permalink":"https://sukksa.github.io/2022/vue/Vue%E6%8C%87%E4%BB%A4/","excerpt":"Vue 基本指令v-textv-text，该指令的用法同原生 JS 中的 innerText，更新绑定元素内部的文本内容 &lt;div id=&quot;div&quot;&gt; &lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt; &lt;!--不会有闪烁问题--&gt;&lt;!-- 和下面的一样 --&gt; &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt; &lt;/div&gt; 与插值语法的区别：v-text会替换掉节点中的内容，&#123;&#123;xx&#125;&#125;则不会。","categories":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/tags/Vue/"}]},{"title":"Vue 生命周期","date":"2022-09-17T13:14:08.000Z","path":"2022/vue/Vue生命周期/","permalink":"https://sukksa.github.io/2022/vue/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"Vue 生命周期生命周期又名：生命周期回调函数、生命周期函数、生命周期钩子。 是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。 生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。 生命周期函数中的this指向是vm 或 组件实例对象。","categories":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/tags/Vue/"}]},{"title":"Vue实例对象","date":"2022-07-29T14:58:08.000Z","path":"2022/vue/Vue实例对象/","permalink":"https://sukksa.github.io/2022/vue/Vue%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1/","excerpt":"Vue实例对象创建并绑定 Vue 对象Vue 也是一个构造函数,通过 new Vue()可以创建一个 Vue 对象,通过 Vue 对象进行对 DOM 元素以及内部的子孙元素的操作 new Vue(&#123; el: &#39;#div&#39;, /* 在Vue中通过el属性来绑定一个DOM元素,从而让该DOM元素以及内部都绑定Vue的相关操作,一般是通过ID进行查找,因为这样才能够精确绑定 */ data: &#123; //data属性中包含着在el中使用的使用的变量或属性 msg: 123, &#125;, //也可以使用函数形式的 data() &#123; return &#123; msg: 123, &#125; &#125;, //methods属性包含着需要使用的方法 methods: &#123; show() &#123; console.log(this.msg) &#125;, &#125;, &#125;) 注:在实例内部使用定义的属性或方法时不能直接使用,必须通过 this 来指定需要用的属性","categories":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/tags/Vue/"}]},{"title":"字符串的扩展","date":"2022-07-26T12:19:08.000Z","path":"2022/ES6/字符串的扩展/","permalink":"https://sukksa.github.io/2022/ES6/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/","excerpt":"字符串的扩展字符的 Unicode 表示法JavaScript 允许采用\\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。 &#39;\\u0061&#39; // &quot;a&quot; 但是，这种表示法只限于码点在\\u0000~\\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示","categories":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/tags/ES6/"},{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"Module 的加载实现","date":"2022-07-23T06:58:59.000Z","path":"2022/ES6/Moudle 的加载实现/","permalink":"https://sukksa.github.io/2022/ES6/Moudle%20%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/","excerpt":"Module 的加载实现本章介绍如何在浏览器和 Node 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题(比如循环加载) 浏览器加载传统方法在 HTML 网页中，浏览器通过&lt;script&gt;标签加载 JavaScript 脚本。","categories":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/tags/ES6/"},{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"Module 模块化","date":"2022-07-21T06:32:08.000Z","path":"2022/ES6/模块化 module/","permalink":"https://sukksa.github.io/2022/ES6/%E6%A8%A1%E5%9D%97%E5%8C%96%20module/","excerpt":"模块化 module基本概述历史上，JavaScript 一直没有模块(module)体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。 在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案","categories":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/tags/ES6/"},{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"对象的扩展","date":"2022-07-19T06:57:08.000Z","path":"2022/ES6/对象的扩展/","permalink":"https://sukksa.github.io/2022/ES6/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/","excerpt":"对象的扩展属性的简介表示ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。 const foo = &quot;bar&quot; const baz = &#123; foo &#125; baz // &#123;foo: &quot;bar&quot;&#125; // 等同于 // const baz = &#123; foo: foo &#125;","categories":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/tags/ES6/"},{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"Class的基本用法","date":"2022-06-25T06:22:19.000Z","path":"2022/ES6/Class的继承/","permalink":"https://sukksa.github.io/2022/ES6/Class%E7%9A%84%E7%BB%A7%E6%89%BF/","excerpt":"Class的基本用法Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。","categories":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/tags/ES6/"},{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"Class的基本用法","date":"2022-06-24T06:11:40.000Z","path":"2022/ES6/Class的基本用法/","permalink":"https://sukksa.github.io/2022/ES6/Class%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/","excerpt":"Class的基本用法ES6 提供了更接近传统语言的写法，引入了 Class(类)这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。","categories":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/tags/ES6/"},{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"set 与 map","date":"2021-12-18T00:11:59.000Z","path":"2021/ES6/set与map/","permalink":"https://sukksa.github.io/2021/ES6/set%E4%B8%8Emap/","excerpt":"set 与 mapset基本用法ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set 本身是一个构造函数，用来生成 Set 数据结构。","categories":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/tags/ES6/"},{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"Ajax跨域","date":"2021-12-05T06:08:27.000Z","path":"2021/Ajax/Ajax跨域请求/","permalink":"https://sukksa.github.io/2021/Ajax/Ajax%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/","excerpt":"Ajax跨域同源策略同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）","categories":[{"name":"Ajax","slug":"Ajax","permalink":"https://sukksa.github.io/categories/Ajax/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://sukksa.github.io/tags/Ajax/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://sukksa.github.io/tags/JavaScript/"}]},{"title":"Axios","date":"2021-11-24T11:35:27.000Z","path":"2021/Ajax/Axios/","permalink":"https://sukksa.github.io/2021/Ajax/Axios/","excerpt":"Axios创建 APIAPI 的分类 REST API: restful （Representational State Transfer (资源)表现层状态转化） 发送请求进行CRUD 哪个操作由请求方式来决定 同一个请求路径可以进行多个操作 请求方式会用到GET&#x2F;POST&#x2F;PUT&#x2F;DELETE 非REST API: restless 请求方式不决定请求的CRUD 操作 一个请求路径只对应一个操作 一般只有GET&#x2F;POST","categories":[{"name":"Ajax","slug":"Ajax","permalink":"https://sukksa.github.io/categories/Ajax/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://sukksa.github.io/tags/Ajax/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://sukksa.github.io/tags/JavaScript/"}]},{"title":"Fetch","date":"2021-11-24T11:35:27.000Z","path":"2021/Ajax/Fetch/","permalink":"https://sukksa.github.io/2021/Ajax/Fetch/","excerpt":"Fetchfetch 是一种 HTTP 数据请求的方式，是 XMLHttpRequest 的一种替代方案。fetch 不是 ajax 的进一步封装，而是原生 js。Fetch 函数就是原生 js，没有使用 XMLHttpRequest 对象","categories":[{"name":"Ajax","slug":"Ajax","permalink":"https://sukksa.github.io/categories/Ajax/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://sukksa.github.io/tags/Ajax/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://sukksa.github.io/tags/JavaScript/"}]},{"title":"原生Ajax","date":"2021-11-22T12:59:27.000Z","path":"2021/Ajax/原生Ajax/","permalink":"https://sukksa.github.io/2021/Ajax/%E5%8E%9F%E7%94%9FAjax/","excerpt":"原生AjaxAjax 全称 Asynchronous JavaScript and XML(异步的 JavaScript 和 XML)，既是一个对象，也是一种方法模式 AJAX 是一种用于创建快速动态网页的技术，通过在后台与服务器进行少量数据交换,Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新，传统的不使用 Ajax 的网页如果需要更新内容,必需重载整个网页","categories":[{"name":"Ajax","slug":"Ajax","permalink":"https://sukksa.github.io/categories/Ajax/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://sukksa.github.io/tags/Ajax/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://sukksa.github.io/tags/JavaScript/"}]},{"title":"node","date":"2021-11-18T10:18:41.000Z","path":"2021/node/node/","permalink":"https://sukksa.github.io/2021/node/node/","excerpt":"node简介Node是对ES标准一个实现，Node也是一个JS引擎，通过Node可以使js代码在服务器端执行，Node仅仅对ES标准进行了实现，所以在Node中不包含DOM 和 BOM","categories":[{"name":"node","slug":"node","permalink":"https://sukksa.github.io/categories/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://sukksa.github.io/tags/node/"}]},{"title":"less","date":"2021-11-15T11:13:01.000Z","path":"2021/less/less/","permalink":"https://sukksa.github.io/2021/less/less/","excerpt":"lessless 是一种动态样式语言,属于 CSS 预处理器的范畴,它拓展了 CSS 语言,其余的 CSS 预处理器有 sass 和 stylus 等 less 增加了变量,MIxin,函数等特性,使 CSS 更易维护和扩展,less 既可以在客户端上运行,也可以借助 node.js 在服务端 运行","categories":[{"name":"less","slug":"less","permalink":"https://sukksa.github.io/categories/less/"}],"tags":[{"name":"less","slug":"less","permalink":"https://sukksa.github.io/tags/less/"}]},{"title":"Symbol","date":"2021-11-11T05:08:35.000Z","path":"2021/ES6/Symbol/","permalink":"https://sukksa.github.io/2021/ES6/Symbol/","excerpt":"SymbolES5 的对象属性名都是字符串，这容易造成属性名的冲突。如在对象中添加一个方法，这个方法名有可能导致重名，引起冲突 ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型 对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突","categories":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/tags/ES6/"},{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"函数的扩展","date":"2021-11-08T11:57:08.000Z","path":"2021/ES6/函数的扩展/","permalink":"https://sukksa.github.io/2021/ES6/%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/","excerpt":"函数的扩展函数参数的默认值ES6 允许给函数参数赋值初始值","categories":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/tags/ES6/"},{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"变量解构赋值","date":"2021-11-06T04:57:08.000Z","path":"2021/ES6/变量解构赋值/","permalink":"https://sukksa.github.io/2021/ES6/%E5%8F%98%E9%87%8F%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/","excerpt":"变量的解构赋值ES6 允许按照一定模式从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。","categories":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/tags/ES6/"},{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"let与const","date":"2021-10-30T09:02:40.000Z","path":"2021/ES6/let与const/","permalink":"https://sukksa.github.io/2021/ES6/let%E4%B8%8Econst/","excerpt":"let与conset在ES6中引入了变量声明的两种方式，let 与 conset let 用来声明变量 conset 用来声明常量","categories":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/tags/ES6/"},{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"ES6简介","date":"2021-10-30T09:00:28.000Z","path":"2021/ES6/ES6简介/","permalink":"https://sukksa.github.io/2021/ES6/ES6%E7%AE%80%E4%BB%8B/","excerpt":"ES6简介ECMAScript 6.0(以下简称 ES6)是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。","categories":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/tags/ES6/"},{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"jQuery轮播图","date":"2021-10-26T13:13:14.000Z","path":"2021/实战/jQuery轮播图/","permalink":"https://sukksa.github.io/2021/%E5%AE%9E%E6%88%98/jQuery%E8%BD%AE%E6%92%AD%E5%9B%BE/","excerpt":"jQuery实现轮播图 功能说明: 点击向右(左)的图标, 平滑切换到下(上)一页 无限循环切换: 第一页的上一页为最后页, 最后一页的下一页是第一页 每隔3s自动滑动到下一页 当鼠标进入图片区域时, 自动切换停止, 当鼠标离开后,又开始自动切换 切换页面时, 下面的圆点也同步更新 点击圆点图标切换到对应的页 bug: 快速点击时, 翻页不正常","categories":[{"name":"实战","slug":"实战","permalink":"https://sukksa.github.io/categories/%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"},{"name":"DOM","slug":"DOM","permalink":"https://sukksa.github.io/tags/DOM/"},{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/tags/jQuery/"}]},{"title":"jQuery插件","date":"2021-10-24T11:21:52.000Z","path":"2021/jQuery/jQuery插件/","permalink":"https://sukksa.github.io/2021/jQuery/jQuery%E6%8F%92%E4%BB%B6/","excerpt":"jQuery插件 我们可以扩展 jQuery 来实现自定义方法。这种方式也称为编写 jQuery 插件。 在使用jQuery插件时，应该先引入jQuery库文件，然后在引用jQuery插件","categories":[{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/tags/jQuery/"}]},{"title":"jQuery动画","date":"2021-10-24T05:11:29.000Z","path":"2021/jQuery/jQuery动画/","permalink":"https://sukksa.github.io/2021/jQuery/jQuery%E5%8A%A8%E7%94%BB/","excerpt":"jQuery动画slideUp &#x2F; slideDown滑动动画: 通过不断改变元素的高度(height)实现 slideDown(): 带动画的展开 slideUp(): 带动画的收缩 slideToggle(): 带动画的切换展开&#x2F;收缩","categories":[{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/tags/jQuery/"}]},{"title":"jQuery事件","date":"2021-10-20T15:46:14.000Z","path":"2021/jQuery/jQuery事件/","permalink":"https://sukksa.github.io/2021/jQuery/jQuery%E4%BA%8B%E4%BB%B6/","excerpt":"jQuery事件因为 JavaScript 在浏览器中以单线程模式运行，页面加载后，一旦页面上所有的 JavaScript 代码被执行完后，就只能依赖触发事件来执行 JavaScript 代码。浏览器在接收到用户的鼠标或键盘输入后，会自动在对应的 DOM 节点上触发相应的事件。如果该节点已经绑定了对应的 JavaScript 处理函数，该函数就会自动调用。","categories":[{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/tags/jQuery/"}]},{"title":"jQuery修改DOM结构","date":"2021-10-20T12:26:54.000Z","path":"2021/jQuery/jQuery修改DOM结构/","permalink":"https://sukksa.github.io/2021/jQuery/jQuery%E4%BF%AE%E6%94%B9DOM%E7%BB%93%E6%9E%84/","excerpt":"修改DOM结构直接使用浏览器提供的 API 对 DOM 结构进行修改，不但代码复杂，而且要针对浏览器写不同的代码。 有了 jQuery，我们就专注于操作 jQuery 对象本身，底层的 DOM 操作由 jQuery 完成就可以了，这样一来，修改 DOM 也大大简化了","categories":[{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/tags/jQuery/"}]},{"title":"jQuery操作DOM元素","date":"2021-10-20T11:40:59.000Z","path":"2021/jQuery/jQuery操作DOM/","permalink":"https://sukksa.github.io/2021/jQuery/jQuery%E6%93%8D%E4%BD%9CDOM/","excerpt":"jQuery操作DOMjQuery对象提供了许多修改DOM元素的功能","categories":[{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/tags/jQuery/"}]},{"title":"jQuery选择器","date":"2021-10-19T01:55:03.000Z","path":"2021/jQuery/jQuery选择器/","permalink":"https://sukksa.github.io/2021/jQuery/jQuery%E9%80%89%E6%8B%A9%E5%99%A8/","excerpt":"jQuery选择器 jQuery 选择器允许对 HTML 元素组或单个元素进行操作。 jQuery 选择器基于元素的 id、类、类型、属性、属性值等”查找”（或选择）HTML 元素。 它基于已经存在的 CSS 选择器，除此之外，它还有一些自定义的选择器。 jQuery 中所有选择器都以美元符号开头：$()。 jQuery选择器不是同时执行，而是顺序执行","categories":[{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/tags/jQuery/"}]},{"title":"jQuery介绍","date":"2021-10-18T15:03:28.000Z","path":"2021/jQuery/jQuery简介/","permalink":"https://sukksa.github.io/2021/jQuery/jQuery%E7%AE%80%E4%BB%8B/","excerpt":"jQuery介绍jQuery 是 JavaScript 世界中使用最广泛的一个库。鼎盛时期全世界大约有 80~90%的网站直接或间接地使用了 jQuery。","categories":[{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/tags/jQuery/"}]},{"title":"线程机制与事件机制","date":"2021-10-17T14:36:27.000Z","path":"2021/javaScript/线程机制与事件机制/","permalink":"https://sukksa.github.io/2021/javaScript/%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/","excerpt":"线程 进程：程序的一次执行, 它占有一片独有的内存空间 线程： CPU的基本调度单位, 是程序执行的一个完整流程","categories":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"对象","date":"2021-10-17T14:13:23.000Z","path":"2021/javaScript/对象/","permalink":"https://sukksa.github.io/2021/javaScript/%E5%AF%B9%E8%B1%A1/","excerpt":"对象（Object） 对象是JS中的引用数据类型 对象是一种复合数据类型，在对象中可以保存多个不同数据类型的属性 使用typeof检查一个对象时，会返回object","categories":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"函数","date":"2021-10-15T14:17:45.000Z","path":"2021/javaScript/函数/","permalink":"https://sukksa.github.io/2021/javaScript/%E5%87%BD%E6%95%B0/","excerpt":"函数（Function） 函数也是一个对象，也具有普通对象的功能 函数中可以封装一些代码，在需要的时候可以去调用函数来执行这些代码 使用typeof检查一个函数时会返回function","categories":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"事件","date":"2021-10-15T12:51:28.000Z","path":"2021/DOM/事件/","permalink":"https://sukksa.github.io/2021/DOM/%E4%BA%8B%E4%BB%B6/","excerpt":"事件HTML 事件是发生在 HTML 元素上的事情。 当在 HTML 页面中使用 JavaScript 时， JavaScript 可以触发这些事件。","categories":[{"name":"DOM","slug":"DOM","permalink":"https://sukksa.github.io/categories/DOM/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"https://sukksa.github.io/tags/DOM/"}]},{"title":"变量与作用域","date":"2021-10-15T12:49:28.000Z","path":"2021/javaScript/变量与作用域/","permalink":"https://sukksa.github.io/2021/javaScript/%E5%8F%98%E9%87%8F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/","excerpt":"变量 字面量字面量（常量），都是一些不可改变的值比如 ：1 2 3 4 5字面量都是可以直接使用，但是我们一般都不会直接使用字面量 变量变量可以用来保存字面量，而且变量的值是可以任意改变的变量更加方便我们使用，所以在开发中都是通过变量去保存一个字面量，而很少直接使用字面量，可以通过变量对字面量进行描述","categories":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"事件对象","date":"2021-04-27T11:47:26.000Z","path":"2021/DOM/事件对象/","permalink":"https://sukksa.github.io/2021/DOM/%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/","excerpt":"事件对象 当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递进响应函数,在事件对象中封装了当前事件相关的一切信息，比如：鼠标的坐标，键盘哪个按键被按下，鼠标滚轮滚动的方向…","categories":[{"name":"DOM","slug":"DOM","permalink":"https://sukksa.github.io/categories/DOM/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"},{"name":"DOM","slug":"DOM","permalink":"https://sukksa.github.io/tags/DOM/"}]},{"title":"DOM介绍","date":"2021-04-27T11:45:31.000Z","path":"2021/DOM/DOM/","permalink":"https://sukksa.github.io/2021/DOM/DOM/","excerpt":"DOM DOM全称Document Object Model(文档对象模型) 文档:整个HTML网页文档对象 对象:网页中的每一个部分都被转换为了一个对象 模型:使用模型表示对象之间的关系，方便我们获取对象","categories":[{"name":"DOM","slug":"DOM","permalink":"https://sukksa.github.io/categories/DOM/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"},{"name":"DOM","slug":"DOM","permalink":"https://sukksa.github.io/tags/DOM/"}]},{"title":"字符串方法","date":"2021-04-27T06:25:31.000Z","path":"2021/javaScript/字符串方法/","permalink":"https://sukksa.github.io/2021/javaScript/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95/","excerpt":"字符串的相关方法 在底层字符串是以字符数组的形式保存的 var str &#x3D; “abc”;&#x2F;&#x2F; [“a”,”b”,”c”] length属性 可以用来获取字符串的长度 console.log(str.length); &#x2F;&#x2F;输出字符串str的长度","categories":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"正则表达式","date":"2021-04-27T06:23:30.000Z","path":"2021/javaScript/正则表达式/","permalink":"https://sukksa.github.io/2021/javaScript/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"正则表达式正则表达式用于定义一些字符串的规则，计算机可以根据正则表达式，来检查一个字符串是否符合规则，获取将字符串中符合规则的内容提取出来","categories":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"数组","date":"2021-04-27T06:21:47.000Z","path":"2021/javaScript/数组/","permalink":"https://sukksa.github.io/2021/javaScript/%E6%95%B0%E7%BB%84/","excerpt":"数组 数组也是一个对象 普通对象是使用字符串作为属性名的，而数组时使用数字来作为索引操作元素 数组中的元素可以是任意的数据类型，可以是对象","categories":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"类型转换","date":"2021-04-27T06:18:39.000Z","path":"2021/javaScript/类型转换/","permalink":"https://sukksa.github.io/2021/javaScript/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"类型转换 类型转换就是指将其他的数据类型，转换为String Number 或 Boolean","categories":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]},{"title":"基本语法","date":"2021-04-27T06:15:36.000Z","path":"2021/javaScript/基本语法/","permalink":"https://sukksa.github.io/2021/javaScript/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"JavaScript的基本语法JavaScript编写位置 可以将js代码编写到标签的onclick属性或超链接的href属性中（当我们点击按钮时，js代码才会执行 123&lt;button onclick=&quot;alert(&#x27;xxx&#x27;);&quot;&gt;button&lt;/button&gt;`&lt;a href=&quot;javascript:alert(&#x27;xxx&#x27;);&quot;&gt;&lt;/a&gt;&lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt; 可以将js代码编写到script标签 1&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;我是script标签中的代码&quot;);&lt;/script&gt; 可以将js代码编写到外部js文件中，然后通过script标签引入 1&lt;script type=&quot;text/javascript&quot; src=&quot;js/script.js&quot;&gt;&lt;/script&gt; 注：script标签一旦用于引入外部文件了，就不能在编写代码了，即使编写了浏览器也会忽略如果需要则可以在创建一个新的script标签用于编写内部代码","categories":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/categories/javaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"}]}],"categories":[{"name":"shader","slug":"shader","permalink":"https://sukksa.github.io/categories/shader/"},{"name":"Threejs","slug":"Threejs","permalink":"https://sukksa.github.io/categories/Threejs/"},{"name":"git","slug":"git","permalink":"https://sukksa.github.io/categories/git/"},{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/categories/Vue/"},{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/categories/ES6/"},{"name":"Ajax","slug":"Ajax","permalink":"https://sukksa.github.io/categories/Ajax/"},{"name":"node","slug":"node","permalink":"https://sukksa.github.io/categories/node/"},{"name":"less","slug":"less","permalink":"https://sukksa.github.io/categories/less/"},{"name":"实战","slug":"实战","permalink":"https://sukksa.github.io/categories/%E5%AE%9E%E6%88%98/"},{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/categories/jQuery/"},{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/categories/javaScript/"},{"name":"DOM","slug":"DOM","permalink":"https://sukksa.github.io/categories/DOM/"}],"tags":[{"name":"Threejs","slug":"Threejs","permalink":"https://sukksa.github.io/tags/Threejs/"},{"name":"shader","slug":"shader","permalink":"https://sukksa.github.io/tags/shader/"},{"name":"git","slug":"git","permalink":"https://sukksa.github.io/tags/git/"},{"name":"Vue","slug":"Vue","permalink":"https://sukksa.github.io/tags/Vue/"},{"name":"ES6","slug":"ES6","permalink":"https://sukksa.github.io/tags/ES6/"},{"name":"javaScript","slug":"javaScript","permalink":"https://sukksa.github.io/tags/javaScript/"},{"name":"Ajax","slug":"Ajax","permalink":"https://sukksa.github.io/tags/Ajax/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://sukksa.github.io/tags/JavaScript/"},{"name":"node","slug":"node","permalink":"https://sukksa.github.io/tags/node/"},{"name":"less","slug":"less","permalink":"https://sukksa.github.io/tags/less/"},{"name":"DOM","slug":"DOM","permalink":"https://sukksa.github.io/tags/DOM/"},{"name":"jQuery","slug":"jQuery","permalink":"https://sukksa.github.io/tags/jQuery/"}]}