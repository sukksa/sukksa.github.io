<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/04/03/node/node%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/"/>
    <url>/2025/04/03/node/node%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">title: node<br>date: 2021<span class="hljs-string">-11</span><span class="hljs-string">-18</span> 19:18:41<br><span class="hljs-keyword">tags:</span><br> - node<br>categories: node<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/04/03/hello-world/"/>
    <url>/2025/04/03/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Vuex</title>
    <link href="/2022/10/07/vue/Vuex/"/>
    <url>/2022/10/07/vue/Vuex/</url>
    
    <content type="html"><![CDATA[<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><p>Vuex 是在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间通信。</p><span id="more"></span><h2 id="Vuex-理解"><a href="#Vuex-理解" class="headerlink" title="Vuex 理解"></a>Vuex 理解</h2><p><strong>Vuex 是一个全局的共享存储区域，相当于是一个数据仓库</strong></p><p>Vuex 是为了保存组件之间的共享数据而诞生的，如果组件之间要有共享数据，可以直接挂载到 Vuex 中，而不必通过父子组件直接的传值了，而私有的数据则不需要挂载到 Vuex 中，<strong>只有需要共享的数据才放在 Vuex 中，私有的数据只需要放在组件的 data 中即可</strong></p><h3 id="多组件共享状态的问题"><a href="#多组件共享状态的问题" class="headerlink" title="多组件共享状态的问题"></a>多组件共享状态的问题</h3><ol><li><p>多个视图依赖于同一状态</p></li><li><p>来自不同视图的行为需要变更同一状态</p></li><li><p>以前的解决办法：</p><p>a. 将数据以及操作数据的行为都定义在父组件</p><p>b. 将数据以及操作数据的行为传递给需要的各个子组件(有可能需要多级传递)</p></li></ol><p>vuex 就是用来解决这个问题的</p><h3 id="状态自管理应用"><a href="#状态自管理应用" class="headerlink" title="状态自管理应用"></a>状态自管理应用</h3><p>这个状态自管理应用包含以下几个部分：</p><ol><li><code>state</code>: 驱动应用的数据源</li><li><code>view</code>: 以声明方式将 <code>state</code> 映射到视图</li><li><code>actions</code>: 响应在 <code>view</code> 上的用户输入导致的状态变化(包含 n 个更新状态的方法)</li></ol><p>以下是一个表示“单向数据流”理念的简单示意：</p><p><img src="/%5Cimages%5Cvue%5Cvue_Vuex_%E7%8A%B6%E6%80%81%E8%87%AA%E7%AE%A1%E7%90%86%E5%BA%94%E7%94%A8.png" alt="vue_Vuex_状态自管理应用"></p><h3 id="Vuex-的结构模型"><a href="#Vuex-的结构模型" class="headerlink" title="Vuex 的结构模型"></a>Vuex 的结构模型</h3><p><img src="/%5Cimages%5Cvue%5Cvue_Vuex_%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B.png" alt="vue_Vuex_结构模型"></p><h2 id="搭建vuex环境"><a href="#搭建vuex环境" class="headerlink" title="搭建vuex环境"></a>搭建vuex环境</h2><ol><li><p>下载<code>vuex</code>插件：<code>npm i vuex</code></p><p>注：<code>vue2</code>环境中不支持 <code>vuex4</code>，所以在 <code>vue2</code> 中应该使用 <code>npm i vuex@3</code> 命令安装 <code>vuex3</code></p></li><li><p>创建文件：<code>src/store/index.js</code></p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//引入Vue核心库</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-comment">//引入Vuex</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><span class="hljs-comment">//应用Vuex插件</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)<br><br><span class="hljs-comment">//准备actions对象——响应组件中用户的动作</span><br><span class="hljs-keyword">const</span> actions = &#123;&#125;<br><span class="hljs-comment">//准备mutations对象——修改state中的数据</span><br><span class="hljs-keyword">const</span> mutations = &#123;&#125;<br><span class="hljs-comment">//准备state对象——保存具体的数据</span><br><span class="hljs-keyword">const</span> state = &#123;&#125;<br><br><span class="hljs-comment">//创建并暴露store</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>actions,<br>mutations,<br>state<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="3"><li>在<code>main.js</code>中创建<code>vm</code>时传入<code>store</code>配置项</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//引入store</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span><br><br><span class="hljs-comment">//创建vm</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,<br><span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),<br>store,<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p><code>Vuex</code> 并不限制你的代码结构。但是，它规定了一些需要遵守的规则：</p><ol><li>应用层级的状态应该集中到单个 <code>store</code> 对象中。</li><li>提交 <code>mutation</code> 是更改状态的唯一方法，并且这个过程是同步的。</li><li>异步逻辑都应该封装到 <code>action</code> 里面。</li></ol><p>只要你遵守以上规则，如何组织代码随你便。如果你的 <code>store</code> 文件太大，只需将 <code>action</code>、<code>mutation</code> 和 <code>getter</code> 分割到单独的文件。</p><p>对于大型应用，我们会希望把 <code>Vuex</code> 相关代码分割到模块中。下面是项目结构示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── index.html<br>├── main.js<br>├── api<br>│   └── ... <span class="hljs-comment"># 抽取出API请求</span><br>├── components<br>│   ├── App.vue<br>│   └── ...<br>└── store<br>    ├── index.js          <span class="hljs-comment"># 我们组装模块并导出 store 的地方</span><br>    ├── actions.js        <span class="hljs-comment"># 根级别的 action</span><br>    ├── mutations.js      <span class="hljs-comment"># 根级别的 mutation</span><br>    └── modules<br>        ├── cart.js       <span class="hljs-comment"># 购物车模块</span><br>        └── products.js   <span class="hljs-comment"># 产品模块</span><br></code></pre></td></tr></table></figure><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><blockquote><p>vuex中一共有五个状态 State Getter Mutation  Action  Module </p></blockquote><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><ol><li><p><code>state</code> 提供唯一的公共数据源，所有共享的数据统一放到<code>store</code>的<code>state</code>进行储存，类似于 <code>Vue</code> 中的 <code>data</code>属性</p></li><li><p>在<code>vuex</code>中<code>state</code>中定义数据，可以在任何组件中进行调用</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>    <span class="hljs-comment">//数据，相当于data</span><br>    <span class="hljs-attr">state</span>: &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">12</span>,<br>        <span class="hljs-attr">sum</span>: <span class="hljs-number">0</span>,<br>    &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="3"><li>使用：</li></ol><p>在标签中直接使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; $store.state.name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; $store.state.age &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>组件中使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">name</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">age</span><br></code></pre></td></tr></table></figure><h3 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a>Mutations</h3><ol><li>包含多个直接更新 <code>state</code> 的方法(回调函数)的对象</li><li>谁来触发: <code>action 中的 commit(&#39;mutationName&#39;)</code></li><li>只能包含同步的代码, 不能写异步代码</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-keyword">const</span> mutations = &#123;<br><span class="hljs-title function_">mutationName</span> (state, value) &#123;<br><span class="hljs-comment">// 更新 state 某个属性的操作</span><br>&#125;<br>&#125;<br>第一个参数：state 等同于 store.<span class="hljs-property">state</span> ，若在模块中则为局部状态<br><br>第二个参数：value 可以为任意类型，但最后都会包装成一个对象<br></code></pre></td></tr></table></figure><p>以加法、减法操作为例，<code>state.sum</code> 加上或减去 <code>value</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">mutations</span>: &#123;<br>    <span class="hljs-title function_">JIA</span>(<span class="hljs-params">state, value</span>) &#123;<br>        state.<span class="hljs-property">sum</span> += value<br>    &#125;,<br>    <span class="hljs-title function_">JIAN</span>(<span class="hljs-params">state, value</span>) &#123;<br>        state.<span class="hljs-property">sum</span> -= value<br>    &#125;,<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h3><ol><li><p>包含多个事件回调函数的对象</p></li><li><p>通过执行: <code>commit()</code>来触发 <code>mutation</code> 的调用，间接更新 <code>state</code></p></li><li><p>谁来触发: 组件中: <code>this.$store.dispatch(&#39;actionName&#39;, value) value为参数</code></p></li><li><p>可以包含异步代码（如定时器，ajax）</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> actions = &#123;<br><span class="hljs-title function_">actionName</span> (context, value) &#123;<br><span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;对应的mutationsName&#x27;</span>, value)<br>&#125;<br> &#125;<br>第一个参数：context对象<br>包含：&#123;<br>  state,      <span class="hljs-comment">// 等同于 `store.state`，若在模块中则为局部状态</span><br>  rootState,  <span class="hljs-comment">// 等同于 `store.state`，只存在于模块中</span><br>  commit,     <span class="hljs-comment">// 等同于 `store.commit`</span><br>  dispatch,   <span class="hljs-comment">// 等同于 `store.dispatch`</span><br>  getters,    <span class="hljs-comment">// 等同于 `store.getters`</span><br>  rootGetters <span class="hljs-comment">// 等同于 `store.getters`，只存在于模块中</span><br>&#125;<br>第二个参数： 可以为任意类型，但最后都会包装成一个对象<br></code></pre></td></tr></table></figure><p>以 0.5s 后如果<code>sum</code>为奇数则加的加法操作为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> actions = &#123;<br>    <span class="hljs-title function_">jiaWait</span>(<span class="hljs-params">context, value</span>) &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (context.<span class="hljs-property">state</span>.<span class="hljs-property">sum</span> % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>            context.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;JIA&#x27;</span>, value)<br>        &#125;<br>        &#125;, <span class="hljs-number">500</span>)<br>    &#125;,<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h3><ol><li>包含多个计算属性(<code>get</code>)的对象</li><li>当<code>state</code>中的数据需要经过加工后再使用时，可以使用<code>getters</code>加工，类似于 <code>Vue</code> 中的 <code>computed</code>属性</li><li>谁来读取: 组件中: <code>$store.getters.xxx</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> getters = &#123;<br>    <span class="hljs-title function_">getterName</span>(<span class="hljs-params">state</span>) &#123;<br>        <span class="hljs-keyword">return</span> <br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>以将 <code>sum</code>乘 10 为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> getters = &#123;<br>    <span class="hljs-title function_">bigSum</span>(<span class="hljs-params">state</span>) &#123;<br>        <span class="hljs-keyword">return</span> state.<span class="hljs-property">sum</span> * <span class="hljs-number">10</span><br>    &#125;,<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><ol><li>包含多个 <code>module</code></li><li>一个 <code>module</code> 是一个 <code>store</code> 的配置对象，可分别写在不同 <code>js</code>文件中，然后暴露即可，但是需要加上<code>namespaced: true,</code></li><li>与一个组件(包含有共享数据)对应</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)<br><br><span class="hljs-keyword">const</span> moduleA = &#123;<br>    <span class="hljs-attr">namespaced</span>:<span class="hljs-literal">true</span>,<span class="hljs-comment">//开启命名空间</span><br>    <span class="hljs-attr">state</span>: &#123;&#125;,<br>    <span class="hljs-attr">mutations</span>: &#123;&#125;,<br>    <span class="hljs-attr">actions</span>: &#123;&#125;,<br>    <span class="hljs-attr">getters</span>: &#123;&#125;,<br>&#125;<br><span class="hljs-keyword">const</span> moduleB = &#123;<br>    <span class="hljs-attr">namespaced</span>:<span class="hljs-literal">true</span>,<span class="hljs-comment">//开启命名空间</span><br>    <span class="hljs-attr">state</span>: &#123;&#125;,<br>    <span class="hljs-attr">mutations</span>: &#123;&#125;,<br>    <span class="hljs-attr">actions</span>: &#123;&#125;,<br>    <span class="hljs-attr">getters</span>: &#123;&#125;,<br>&#125;<br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>    <span class="hljs-attr">modules</span>: &#123;<br>        <span class="hljs-attr">moduleA</span>: moduleA,<br>        <span class="hljs-attr">moduleB</span>: moduleB,<br>        <span class="hljs-comment">// ES6 简写</span><br>        <span class="hljs-comment">// moduleA,</span><br>        <span class="hljs-comment">// moduleB,</span><br>    &#125;,<br>&#125;)<br>store.<span class="hljs-property">state</span>.<span class="hljs-property">moduleA</span> <span class="hljs-comment">// -&gt; moduleA 的状态</span><br>store.<span class="hljs-property">state</span>.<span class="hljs-property">moduleB</span> <span class="hljs-comment">// -&gt; moduleB 的状态</span><br></code></pre></td></tr></table></figure><h2 id="四个map方法的使用"><a href="#四个map方法的使用" class="headerlink" title="四个map方法的使用"></a>四个<code>map</code>方法的使用</h2><p>导入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;mapState, mapGetters, mapActions, mapMutations&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="mapState方法："><a href="#mapState方法：" class="headerlink" title="mapState方法："></a><code>mapState</code>方法：</h3><p>用于帮助我们映射<code>state</code>中的数据为计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-comment">//借助mapState生成计算属性：sum、school、subject（对象写法）</span><br>     ...<span class="hljs-title function_">mapState</span>(&#123;<span class="hljs-attr">sum</span>:<span class="hljs-string">&#x27;sum&#x27;</span>,<span class="hljs-attr">school</span>:<span class="hljs-string">&#x27;school&#x27;</span>,<span class="hljs-attr">subject</span>:<span class="hljs-string">&#x27;subject&#x27;</span>&#125;),<br>         <br>    <span class="hljs-comment">//借助mapState生成计算属性：sum、school、subject（数组写法）</span><br>    ...<span class="hljs-title function_">mapState</span>([<span class="hljs-string">&#x27;sum&#x27;</span>,<span class="hljs-string">&#x27;school&#x27;</span>,<span class="hljs-string">&#x27;subject&#x27;</span>]),<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="mapGetters方法："><a href="#mapGetters方法：" class="headerlink" title="mapGetters方法："></a><code>mapGetters</code>方法：</h3><p>用于帮助我们映射<code>getters</code>中的数据为计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-comment">//借助mapGetters生成计算属性：bigSum（对象写法）</span><br>    ...<span class="hljs-title function_">mapGetters</span>(&#123;<span class="hljs-attr">bigSum</span>:<span class="hljs-string">&#x27;bigSum&#x27;</span>&#125;),<br><br>    <span class="hljs-comment">//借助mapGetters生成计算属性：bigSum（数组写法）</span><br>    ...<span class="hljs-title function_">mapGetters</span>([<span class="hljs-string">&#x27;bigSum&#x27;</span>])<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="mapActions方法："><a href="#mapActions方法：" class="headerlink" title="mapActions方法："></a><code>mapActions</code>方法：</h3><p>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-comment">//靠mapActions生成：incrementOdd、incrementWait（对象形式）</span><br>    ...<span class="hljs-title function_">mapActions</span>(&#123;<span class="hljs-attr">incrementOdd</span>:<span class="hljs-string">&#x27;jiaOdd&#x27;</span>,<span class="hljs-attr">incrementWait</span>:<span class="hljs-string">&#x27;jiaWait&#x27;</span>&#125;)<br><br>    <span class="hljs-comment">//靠mapActions生成：incrementOdd、incrementWait（数组形式）</span><br>    ...<span class="hljs-title function_">mapActions</span>([<span class="hljs-string">&#x27;jiaOdd&#x27;</span>,<span class="hljs-string">&#x27;jiaWait&#x27;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="mapMutations方法："><a href="#mapMutations方法：" class="headerlink" title="mapMutations方法："></a><code>mapMutations</code>方法：</h3><p>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-comment">//靠mapActions生成：increment、decrement（对象形式）</span><br>    ...<span class="hljs-title function_">mapMutations</span>(&#123;<span class="hljs-attr">increment</span>:<span class="hljs-string">&#x27;JIA&#x27;</span>,<span class="hljs-attr">decrement</span>:<span class="hljs-string">&#x27;JIAN&#x27;</span>&#125;),<br>    <br>    <span class="hljs-comment">//靠mapMutations生成：JIA、JIAN（对象形式）</span><br>    ...<span class="hljs-title function_">mapMutations</span>([<span class="hljs-string">&#x27;JIA&#x27;</span>,<span class="hljs-string">&#x27;JIAN&#x27;</span>]),<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则传的参数是事件对象(event)。</p></blockquote><p>具体案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;h1&gt;当前求和为：&#123;&#123; sum &#125;&#125;&lt;/h1&gt;<br>        &lt;h3&gt;当前求和放大10倍为：&#123;&#123; bigSum &#125;&#125;&lt;/h3&gt;<br>        &lt;h3&gt;年龄：&#123;&#123; age &#125;&#125;&lt;/h3&gt;<br>        &lt;h3&gt;姓名：&#123;&#123; name &#125;&#125;&lt;/h3&gt;<br>        &lt;select v-model.number=&quot;n&quot;&gt;<br>            &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;<br>            &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;<br>            &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;<br>        &lt;/select&gt;<br>        &lt;!-- 用了mapActions 和 mapMutations 的话要主动传参 --&gt;<br>        &lt;button @click=&quot;increment(n)&quot;&gt;+&lt;/button&gt;<br>        &lt;button @click=&quot;decrement(n)&quot;&gt;-&lt;/button&gt;<br>        &lt;button @click=&quot;incrementOdd(n)&quot;&gt;当前求和为奇数再加&lt;/button&gt;<br>        &lt;button @click=&quot;incrementWait(n)&quot;&gt;等0.5s再加&lt;/button&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br>  <br>&lt;script&gt;<br>    import &#123; mapState, mapGetters, mapActions, mapMutations &#125; from &#x27;vuex&#x27;<br>    export default &#123;<br>        name: &#x27;Count&#x27;,<br>        data() &#123;<br>            return &#123;<br>                n: 1, //用户选择的数字<br>            &#125;<br>        &#125;,<br>        computed: &#123;<br>            ...mapState([&#x27;sum&#x27;, &#x27;age&#x27;, &#x27;name&#x27;]),<br>            ...mapGetters([&#x27;bigSum&#x27;]),<br>        &#125;,<br>        methods: &#123;<br>            ...mapActions(&#123; incrementOdd: &#x27;sumOdd&#x27;, incrementWait: &#x27;sumWait&#x27; &#125;),<br>            ...mapMutations(&#123; increment: &#x27;sum&#x27;, decrement: &#x27;reduce&#x27; &#125;),<br>        &#125;,<br>        mounted() &#123;<br>            console.log(&#x27;Count&#x27;, this)<br>        &#125;,<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>目的：让代码更好维护，让多种数据分类更加明确。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>以加法操作为例，直接写在<code>store.js</code>中</p><p><code>store.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)<br><br><span class="hljs-keyword">const</span> addCountOptions = &#123;<br>    <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//开启命名空间</span><br>    <span class="hljs-attr">actions</span>: &#123;<br>        <span class="hljs-title function_">jiaWait</span>(<span class="hljs-params">context, value</span>) &#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                <span class="hljs-keyword">if</span> (context.<span class="hljs-property">state</span>.<span class="hljs-property">sum</span> % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>                    context.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;JIA&#x27;</span>, value)<br>                &#125;<br>            &#125;, <span class="hljs-number">500</span>)<br>        &#125;,<br>    &#125;,<br>    <span class="hljs-attr">mutations</span>: &#123;<br>        <span class="hljs-title function_">JIA</span>(<span class="hljs-params">state, value</span>) &#123;<br>            context.<span class="hljs-property">sum</span> += value<br>        &#125;,<br>        <span class="hljs-title function_">JIAN</span>(<span class="hljs-params">state, value</span>) &#123;<br>            context.<span class="hljs-property">sum</span> -= value<br>        &#125;,<br>    &#125;,<br>    <span class="hljs-attr">state</span>: &#123;<br>        <span class="hljs-attr">sum</span>: <span class="hljs-number">0</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;tom&#x27;</span>,<br>    &#125;,<br>    <span class="hljs-attr">getters</span>: &#123;<br>        <span class="hljs-title function_">bigSum</span>(<span class="hljs-params">state</span>) &#123;<br>            <span class="hljs-keyword">return</span> state.<span class="hljs-property">sum</span> * <span class="hljs-number">10</span><br>        &#125;,<br>    &#125;,<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>    <span class="hljs-attr">modules</span>: &#123;<br>        addCountOptions,<br>    &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><p>或者写入单独的<code>js</code>文件中</p><p><code>addCount.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//开启命名空间</span><br>    <span class="hljs-attr">actions</span>: &#123;&#125;,<br>    <span class="hljs-attr">mutations</span>: &#123;&#125;,<br>    <span class="hljs-attr">state</span>: &#123;&#125;,<br>    <span class="hljs-attr">getters</span>: &#123;&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p><code>store.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><span class="hljs-keyword">import</span> addCountOptions <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./addCount&#x27;</span><br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>    <span class="hljs-attr">modules</span>: &#123;<br>        addCountOptions,<br>    &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="读取state数据"><a href="#读取state数据" class="headerlink" title="读取state数据"></a>读取<code>state</code>数据</h3><p>开启命名空间后，组件中读取<code>state</code>数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//方式一：自己直接读取</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">addCountOptions</span>.<span class="hljs-property">sum</span><br><br><span class="hljs-comment">//方式二：借助mapState读取：</span><br><span class="hljs-comment">// 用 mapState 取 addCountOptions 中的state 必须加上 &#x27;addCountOptions&#x27;</span><br>...<span class="hljs-title function_">mapState</span>(<span class="hljs-string">&#x27;countAbout&#x27;</span>,[<span class="hljs-string">&#x27;sum&#x27;</span>,<span class="hljs-string">&#x27;name&#x27;</span>]),<br></code></pre></td></tr></table></figure><h3 id="读取getters数据"><a href="#读取getters数据" class="headerlink" title="读取getters数据"></a>读取<code>getters</code>数据</h3><p>开启命名空间后，组件中读取<code>getters</code>数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//方式一：自己直接读取，getters中没有addCountOptions属性，</span><br><span class="hljs-comment">//因此只能使用 addCountOptions/bigSum</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">getters</span>[<span class="hljs-string">&#x27;addCountOptions/bigSum&#x27;</span>]<br><br><span class="hljs-comment">//方式二：借助mapGetters读取：</span><br>...<span class="hljs-title function_">mapGetters</span>(<span class="hljs-string">&#x27;addCountOptions&#x27;</span>,[<span class="hljs-string">&#x27;bigSum&#x27;</span>])<br></code></pre></td></tr></table></figure><h3 id="调用dispatch"><a href="#调用dispatch" class="headerlink" title="调用dispatch"></a>调用<code>dispatch</code></h3><p>开启命名空间后，组件中调用<code>dispatch</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//方式一：自己直接dispatch</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;addCountOptions/jiaWait&#x27;</span>,value)<br><br><span class="hljs-comment">//方式二：借助mapActions：在标签绑定method时必须手动传入参数 incrementWait(value)</span><br>...<span class="hljs-title function_">mapActions</span>(<span class="hljs-string">&#x27;addCountOptions&#x27;</span>,&#123;<span class="hljs-attr">incrementWait</span>:<span class="hljs-string">&#x27;jiaWait&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure><h3 id="调用commit"><a href="#调用commit" class="headerlink" title="调用commit"></a>调用<code>commit</code></h3><p>开启命名空间后，组件中调用<code>commit</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//方式一：自己直接commit</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;addCountOptions/JIA&#x27;</span>,value)<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;addCountOptions/JIAN&#x27;</span>,value)<br><br><span class="hljs-comment">//方式二：借助mapMutations：在标签绑定method时必须手动传入参数 increment(value)</span><br>...<span class="hljs-title function_">mapMutations</span>(<span class="hljs-string">&#x27;addCountOptions&#x27;</span>,&#123;<span class="hljs-attr">increment</span>:<span class="hljs-string">&#x27;JIA&#x27;</span>,<span class="hljs-attr">decrement</span>:<span class="hljs-string">&#x27;JIAN&#x27;</span>&#125;),<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 插件</title>
    <link href="/2022/10/07/vue/Vue%E6%8F%92%E4%BB%B6/"/>
    <url>/2022/10/07/vue/Vue%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-插件"><a href="#Vue-插件" class="headerlink" title="Vue 插件"></a>Vue 插件</h1><p>插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制,一般有下面几种：</p><ul><li><p>添加全局方法或者 <code>property</code>。如：<code>vue-custom-element</code></p></li><li><p>添加全局资源：指令&#x2F;过滤器&#x2F;过渡等。如 <code>vue-touch</code></p></li><li><p>通过全局混入来添加一些组件选项。如 <code>vue-router</code></p></li><li><p>添加 Vue 实例方法，通过把它们添加到 <code>Vue.prototype</code> 上实现</p></li><li><p>一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 <code>vuex</code>，<code>vue-router</code></p></li></ul><span id="more"></span><h2 id="定义插件"><a href="#定义插件" class="headerlink" title="定义插件"></a>定义插件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">对象.<span class="hljs-property">install</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">Vue, options</span>) &#123;<br>    <span class="hljs-comment">// 1. 添加全局过滤器</span><br>    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">filter</span>(....)<br><br>    <span class="hljs-comment">// 2. 添加全局指令</span><br>    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(....)<br><br>    <span class="hljs-comment">// 3. 配置全局混入(合)</span><br>    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>(....)<br><br>    <span class="hljs-comment">// 4. 添加实例方法</span><br>    <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$myMethod</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;...&#125;<br>    <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$myProperty</span> = xxxx<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><p>通过全局方法 <code>Vue.use()</code> 使用插件。它需要在你调用 <code>new Vue()</code> 启动应用之前完成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 调用 `MyPlugin.install(Vue)`</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">MyPlugin</span>)<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-comment">// ...组件选项</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>本质：包含<code>install</code>方法的一个对象，<code>install</code>的第一个参数是<code>Vue</code>，第二个以后的参数是插件使用者传递的数据。</p><h2 id="具体案例"><a href="#具体案例" class="headerlink" title="具体案例"></a>具体案例</h2><p><code>plugin.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-title function_">install</span>(<span class="hljs-params">Vue, x, y, z</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y, z)<br>        <span class="hljs-comment">//全局过滤器</span><br>        <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-string">&#x27;mySlice&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>            <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>)<br>        &#125;)<br><br>        <span class="hljs-comment">//定义全局指令</span><br>        <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;fbind&#x27;</span>, &#123;<br>            <span class="hljs-comment">//指令与元素成功绑定时（一上来）</span><br>            <span class="hljs-title function_">bind</span>(<span class="hljs-params">element, binding</span>) &#123;<br>                element.<span class="hljs-property">value</span> = binding.<span class="hljs-property">value</span><br>            &#125;,<br>            <span class="hljs-comment">//指令所在元素被插入页面时</span><br>            <span class="hljs-title function_">inserted</span>(<span class="hljs-params">element, binding</span>) &#123;<br>                element.<span class="hljs-title function_">focus</span>()<br>            &#125;,<br>            <span class="hljs-comment">//指令所在的模板被重新解析时</span><br>            <span class="hljs-title function_">update</span>(<span class="hljs-params">element, binding</span>) &#123;<br>                element.<span class="hljs-property">value</span> = binding.<span class="hljs-property">value</span><br>            &#125;<br>        &#125;)<br><br>        <span class="hljs-comment">//定义混入</span><br>        <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>(&#123;<br>            <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-keyword">return</span> &#123;<br>                    <span class="hljs-attr">x</span>: <span class="hljs-number">100</span>,<br>                    <span class="hljs-attr">y</span>: <span class="hljs-number">200</span><br>                &#125;<br>            &#125;,<br>        &#125;)<br><br>        <span class="hljs-comment">//给Vue原型上添加一个方法（vm和vc就都能用了）</span><br>        <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hello</span> = <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;你好啊aaaa&#x27;</span>) &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>main.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入插件</span><br><span class="hljs-keyword">import</span> plugin <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./plugin&#x27;</span><br><br><span class="hljs-comment">// 使用插件</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(plugin)<br></code></pre></td></tr></table></figure><p>然后就可以在别的组件使用插件里的功能了。</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue-router</title>
    <link href="/2022/10/07/vue/Vue-router/"/>
    <url>/2022/10/07/vue/Vue-router/</url>
    
    <content type="html"><![CDATA[<h1 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h1><p><code>vue-router</code>是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。<br>我们可以访问其官方网站对其进行学习：<a href="https://router.vuejs.org/zh/">https://router.vuejs.org/zh/</a></p><p><code>vue-router</code>是基于路由和组件的</p><ul><li>路由用户设定访问路径的，将路径和组件映射起来。</li><li>在<code>vue-router</code>的单页面应用中，页面的路径的改变就是组件的切换</li></ul><span id="more"></span><h2 id="路由的定义"><a href="#路由的定义" class="headerlink" title="路由的定义"></a>路由的定义</h2><ul><li><p>后端路由：对于普通的网站，所有的超链接都是 URL 地址，所有的 url 地址都对应服务器上对应的资源</p><p><strong>后端路由是处理请求的回调函数</strong></p></li><li><p>前端路由：对于单页面应用程序来说，主要通过 URL 中的 hash(#号)来实现不同页面之间的切换，同时，hash 有一个特点：HTTP 请求中不会包含 hash 相关的内容；所以，单页面程序中的页面跳转主要用 hash 实现,在单页面应用中这就叫做前端路由</p><p><strong>前端路由让构建单页面应用变得易如反掌</strong></p></li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol><li><p>安装vue-router，命令：<code>npm i vue-router</code></p></li><li><p>编写router配置项:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//引入VueRouter</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">VueRouter</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><span class="hljs-comment">//引入Luyou 组件</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">About</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/About&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Home&#x27;</span><br><br><span class="hljs-comment">//创建router实例对象，去管理一组一组的路由规则</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      route这个配置对象中的route表示路由器匹配规则的意思</span><br><span class="hljs-comment">      每个路由规则都是一个规则对象,身上有两个必须的属性:</span><br><span class="hljs-comment">      第一个属性为path,表示监听哪个路由链接地址</span><br><span class="hljs-comment">      第二个属性为component,表示如果路由前面匹配到了path路径,则展示component属性对于的组件</span><br><span class="hljs-comment">      */</span><br><span class="hljs-attr">routes</span>:[<br>         <span class="hljs-comment">//通过redirect属性设置路由重定向,当访问根目录的时候自动跳转到/login目录</span><br>         &#123; <br>             <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>, <br>             <span class="hljs-attr">redirect</span>: <span class="hljs-string">&quot;/login&quot;</span> <br>         &#125;,<br><br>&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/about&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">About</span><br>&#125;,<br>&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/home&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Home</span><br>&#125;<br>]<br>&#125;)<br><br><span class="hljs-comment">//暴露router</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br></code></pre></td></tr></table></figure></li><li><p>挂载到vue实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">VueRouter</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span><br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">VueRouter</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">render</span>: <span class="hljs-function">(<span class="hljs-params">h</span>) =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),<br>    router,<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>实现切换（active-class可配置高亮样式）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">active-class</span>=<span class="hljs-string">&quot;active&quot;</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/about&quot;</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>指定展示位置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="多级（嵌套）路由"><a href="#多级（嵌套）路由" class="headerlink" title="多级（嵌套）路由"></a>多级（嵌套）路由</h2><p>如果想要在一层路由组件下面开启第二层组件，不能够直接通过二级的路由链接得到二级的路由组件，因为这样一级的链接组件就会消失</p><p>需要通过<code>routes</code>路由器匹配规则中相应规则的 <code>children</code> 属性，在该属性构成的数组中写入子路由来实现路由嵌套的功能</p><ol><li><p>配置路由规则，使用<code>children</code>配置项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>    <span class="hljs-attr">routes</span>:[<br>        &#123;<br>            <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/about&#x27;</span>,<br>            <span class="hljs-attr">component</span>:<span class="hljs-title class_">About</span>,<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/home&#x27;</span>,<br>            <span class="hljs-attr">component</span>:<span class="hljs-title class_">Home</span>,<br>            <span class="hljs-attr">children</span>:[ <span class="hljs-comment">//通过children配置子级路由</span><br>                &#123;<br>                    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;news&#x27;</span>, <span class="hljs-comment">//此处一定不要写：/news</span><br>                    <span class="hljs-attr">component</span>:<span class="hljs-title class_">News</span><br>                &#125;,<br>                &#123;<br>                    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;message&#x27;</span>,<span class="hljs-comment">//此处一定不要写：/message</span><br>                    <span class="hljs-attr">component</span>:<span class="hljs-title class_">Message</span><br>                &#125;<br>            ]<br>        &#125;<br>    ]<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>跳转（要写完整路径）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/home/news&quot;</span>&gt;</span>News<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>指定展示位置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><p>通过在<code>&lt;router-link&gt;&lt;/router-link&gt;</code>的组件中 <code>to</code> 指向一个带有 <code>name</code> 属性的对象，而在路由规则中也添加一个对应的 <code>name</code> 属性实现路由跳转，该方法能让我们更加轻松的进行路由规则的匹配</p><ol><li>给路由命名：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>    <span class="hljs-attr">routes</span>:[    <br>        &#123;<br>            <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/demo&#x27;</span>,<br>            <span class="hljs-attr">component</span>:<span class="hljs-title class_">Demo</span>,<br>            <span class="hljs-attr">children</span>:[<br>                &#123;<br>                    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;test&#x27;</span>,<br>                    <span class="hljs-attr">component</span>:<span class="hljs-title class_">Test</span>,<br>                    <span class="hljs-attr">children</span>:[<br>                        &#123;<br>                              <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;hello&#x27;</span> <span class="hljs-comment">//给路由命名</span><br>                            <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;welcome&#x27;</span>,<br>                            <span class="hljs-attr">component</span>:<span class="hljs-title class_">Hello</span>,<br>                        &#125;<br>                    ]<br>                &#125;<br>            ]<br>        &#125;<br>    ]<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="2"><li>简化跳转：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--简化前，需要写完整的路径 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/demo/test/welcome&quot;</span>&gt;</span>跳转<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--简化后，直接通过名字跳转 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;</span>&gt;</span>跳转<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--简化写法配合传递参数 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> </span><br><span class="hljs-tag"><span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123;</span></span><br><span class="hljs-string"><span class="hljs-tag">name:&#x27;hello&#x27;,</span></span><br><span class="hljs-string"><span class="hljs-tag">query:&#123;</span></span><br><span class="hljs-string"><span class="hljs-tag">   id:666,</span></span><br><span class="hljs-string"><span class="hljs-tag">            title:&#x27;你好&#x27;</span></span><br><span class="hljs-string"><span class="hljs-tag">&#125;</span></span><br><span class="hljs-string"><span class="hljs-tag">&#125;&quot;</span></span><br><span class="hljs-tag">&gt;</span><br>    跳转<br><span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h2><p>一个 Vue 组件内置的<code>$route</code> 属性可以代表着正在进行跳转的路由</p><h3 id="query"><a href="#query" class="headerlink" title="query"></a>query</h3><p>当在路由器中链接中使用查询字符串(<code>url</code> 后面的<code>?</code>后的一系列值),不用修改路由规则中的 <code>path</code> 属性的路径，在路由视图的组件中可用通过 <code>this.$route</code> 获取该路由实例，通过该实例的 <code>query</code> 属性获取传入的参数的属性和值</p><ol><li>传递参数</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/home/message/detail?id=666&amp;title=你好&quot;</span>&gt;</span>跳转<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123;</span></span><br><span class="hljs-string"><span class="hljs-tag">        path:&#x27;/home/message/detail&#x27;,</span></span><br><span class="hljs-string"><span class="hljs-tag">        query:&#123;</span></span><br><span class="hljs-string"><span class="hljs-tag">            id:666,</span></span><br><span class="hljs-string"><span class="hljs-tag">            title:&#x27;你好&#x27;</span></span><br><span class="hljs-string"><span class="hljs-tag">        &#125;</span></span><br><span class="hljs-string"><span class="hljs-tag">    &#125;&quot;</span></span><br><span class="hljs-tag">&gt;</span><br>    跳转<br><span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>接收参数：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">$route.<span class="hljs-property">query</span>.<span class="hljs-property">id</span><br>$route.<span class="hljs-property">query</span>.<span class="hljs-property">title</span><br></code></pre></td></tr></table></figure><h3 id="params"><a href="#params" class="headerlink" title="params"></a>params</h3><p>使用 <code>params</code> 来获取参数需要在路由规则中定义参数，然后在路由器链接中需要在后面跟上对应数量的<code>/+值</code>传给参数实现传参，通过该实例的 <code>params</code> 属性获取传入的参数的属性和值</p><ol><li>配置路由，声明接收<code>params</code>参数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>    <span class="hljs-attr">routes</span>:[<br>        &#123;<br>            <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/home&#x27;</span>,<br>            <span class="hljs-attr">component</span>:<span class="hljs-title class_">Home</span>,<br>            <span class="hljs-attr">children</span>:[<br>                &#123;<br>                    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;news&#x27;</span>,<br>                    <span class="hljs-attr">component</span>:<span class="hljs-title class_">News</span>,<br>                &#125;,<br>                &#123;<br>                    <span class="hljs-attr">component</span>:<span class="hljs-title class_">Message</span>,<br>                    <span class="hljs-attr">children</span>:[<br>                        &#123;<br>                            <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xiangqing&#x27;</span>,<br>                            <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;detail/:id/:title&#x27;</span>, <span class="hljs-comment">//使用占位符声明接收params参数</span><br>                            <span class="hljs-attr">component</span>:<span class="hljs-title class_">Detail</span>,<br>                        &#125;<br>                    ]<br>                &#125;<br>            ]<br>        &#125;<br>    ]<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="2"><li>传递参数</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;/home/message/detail/666/你好&quot;</span>&gt;</span>跳转<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> </span><br><span class="hljs-tag"><span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123;</span></span><br><span class="hljs-string"><span class="hljs-tag">name:&#x27;xiangqing&#x27;, // 必须使用name属性，不能用path</span></span><br><span class="hljs-string"><span class="hljs-tag">params:&#123;</span></span><br><span class="hljs-string"><span class="hljs-tag">   id:666,</span></span><br><span class="hljs-string"><span class="hljs-tag">            title:&#x27;你好&#x27;</span></span><br><span class="hljs-string"><span class="hljs-tag">&#125;</span></span><br><span class="hljs-string"><span class="hljs-tag">&#125;&quot;</span></span><br><span class="hljs-tag">&gt;</span><br>    跳转<br><span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>特别注意</strong>：路由携带<code>params</code>参数时，若使用<code>to</code>的对象写法，则不能使用<code>path</code>配置项，必须使用<code>name</code>配置！</p><ol start="3"><li>接收参数：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">$route.<span class="hljs-property">params</span>.<span class="hljs-property">id</span><br>$route.<span class="hljs-property">params</span>.<span class="hljs-property">title</span><br></code></pre></td></tr></table></figure><h2 id="路由的props"><a href="#路由的props" class="headerlink" title="路由的props"></a>路由的props</h2><p>作用：让路由组件更方便的收到参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>    <span class="hljs-attr">routes</span>: [<br>        &#123;<br>            <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xiangqing&#x27;</span>,<br>            <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;detail&#x27;</span>,<br>            <span class="hljs-attr">component</span>:<span class="hljs-title class_">Detail</span>,<br><br>            <span class="hljs-comment">//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件</span><br>            <span class="hljs-comment">// props:&#123;a:900&#125;</span><br><br>            <span class="hljs-comment">//第二种写法：props值为布尔值，布尔值为true，</span><br>            <span class="hljs-comment">//则把路由收到的所有params参数通过props传给Detail组件</span><br>            <span class="hljs-comment">// props:true</span><br><br>            <span class="hljs-comment">//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件</span><br>            <span class="hljs-title function_">props</span>(<span class="hljs-params">$route</span>) &#123;<br>                <span class="hljs-keyword">return</span> &#123;<br>                  <span class="hljs-attr">id</span>: $route.<span class="hljs-property">query</span>.<span class="hljs-property">id</span>,<br>                  <span class="hljs-attr">title</span>:$route.<span class="hljs-property">query</span>.<span class="hljs-property">title</span>,<br>                  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>                  <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;hello&#x27;</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>对应组件的具体代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;ul&gt;<br>      &lt;h1&gt;Detail&lt;/h1&gt;<br>      &lt;li&gt;消息编号：&#123;&#123;id&#125;&#125;&lt;/li&gt;<br>      &lt;li&gt;消息标题：&#123;&#123;title&#125;&#125;&lt;/li&gt;<br>      &lt;li&gt;a:&#123;&#123;a&#125;&#125;&lt;/li&gt;<br>      &lt;li&gt;b:&#123;&#123;b&#125;&#125;&lt;/li&gt;<br>  &lt;/ul&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>    name: &#x27;Detail&#x27;,<br>    props: [&#x27;id&#x27;, &#x27;title&#x27;, &#x27;a&#x27;, &#x27;b&#x27;],<br>    mounted () &#123;<br>        console.log(this.$route);<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="route-与-router"><a href="#route-与-router" class="headerlink" title="$route 与 $router"></a>$route 与 $router</h2><ul><li><code>this.$route</code> 是路由的参数对象，所有的路由参数如 <code>pararms</code> 和 <code>query</code> 都属于该属性的参数</li><li><code>this.$router</code> 是一个路由导航对象，用它可以方便的使用 JS 代码，实现路由器的前进，后退，跳转到新的 <code>url</code> 地址</li></ul><h3 id="route-表示-当前路由信息对象"><a href="#route-表示-当前路由信息对象" class="headerlink" title="$route 表示(当前路由信息对象)"></a>$route 表示(当前路由信息对象)</h3><p>表示当前激活的路由的状态信息，包含了当前 URL 解析得到的信息，还有 URL 匹配到的 route records（路由记录）。<br>路由信息对象：即<code>$router</code>会被注入每个组件中，可以利用它进行一些信息的获取。</p><ol><li><p><code>$route.path</code></p><p>字符串，对应当前路由的路径，总是解析为绝对路径，如 “&#x2F;foo&#x2F;bar”。</p></li><li><p><code>$route.params</code></p><p>一个 key&#x2F;value 对象，包含了 动态片段 和 全匹配片段，<br>  如果没有路由参数，就是一个空对象。</p></li><li><p><code>$route.query</code></p><p> 一个 key&#x2F;value 对象，表示 URL 查询参数。<br>  例如，对于路径 <code>/foo?user=1</code>，则有 <code>$route.query.user == 1</code>，<br>  如果没有查询参数，则是个空对象。</p></li><li><p><code>$route.hash</code></p><p>当前路由的 hash 值 (不带 #) ，如果没有 hash 值，则为空字符串。锚点</p></li><li><p><code>$route.fullPath</code></p><p> 完成解析后的 URL，包含查询参数和 hash 的完整路径。</p></li><li><p><code>$route.matched</code></p><p>数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。</p></li><li><p><code>$route.name</code></p><p>当前路径名字</p></li><li><p><code>$route.meta</code>  </p><p>对象，路由元信息，可以以对象的形式添加自定义的信息</p></li></ol><h3 id="router对象"><a href="#router对象" class="headerlink" title="$router对象"></a>$router对象</h3><p>全局的路由实例，是<code>router</code>构造方法的实例。<br>在 Vue 实例内部，你可以通过 <code>$router</code> 访问路由实例</p><h4 id="this-router-push"><a href="#this-router-push" class="headerlink" title="this.$router.push()"></a>this.$router.push()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 字符串</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;home&#x27;</span>)<br><span class="hljs-comment">// 对象</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;home&#x27;</span> &#125;)<br><span class="hljs-comment">// 命名的路由</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">userId</span>: <span class="hljs-number">123</span> &#125;&#125;)<br><span class="hljs-comment">// 带查询参数，变成 /register?plan=123</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;register&#x27;</span>, <span class="hljs-attr">query</span>: &#123; <span class="hljs-attr">plan</span>: <span class="hljs-string">&#x27;123&#x27;</span> &#125;&#125;)<br></code></pre></td></tr></table></figure><p><code>push</code>方法其实和<code>&lt;router-link :to=&quot;...&quot;&gt;</code>是等同的。<br> <strong>注意：push方法的跳转会向 history 栈添加一个新的记录，当我们点击浏览器的返回按钮时可以看到之前的页面。</strong></p><h4 id="this-router-go"><a href="#this-router-go" class="headerlink" title="this.$router.go()"></a>this.$router.go()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 页面路由跳转 正数前进或者负数后退</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">go</span>(-<span class="hljs-number">1</span>) <span class="hljs-comment">// 后退1步</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">go</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 前进2步</span><br><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">forward</span>() <span class="hljs-comment">//前进</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">back</span>() <span class="hljs-comment">//后退</span><br></code></pre></td></tr></table></figure><h4 id="this-router-replace"><a href="#this-router-replace" class="headerlink" title="this.$router.replace()"></a>this.$router.replace()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//push方法会向 history 栈添加一个新的记录，而replace方法是替换当前的页面，</span><br>不会向 history 栈添加一个新的记录<br>&lt;router-link to=<span class="hljs-string">&quot;/05&quot;</span> replace&gt;<span class="hljs-number">05</span>&lt;/router-link&gt;<br><br><span class="hljs-comment">// 一般使用replace来做404页面</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;/&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="缓存路由组件"><a href="#缓存路由组件" class="headerlink" title="缓存路由组件"></a>缓存路由组件</h2><ol><li><p>作用：让不展示的路由组件保持挂载，不被销毁。</p></li><li><p>具体编码：</p><p>这个 <code>include</code> 指的是组件名</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">include</span>=<span class="hljs-string">&quot;News&quot;</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="route生命周期钩子"><a href="#route生命周期钩子" class="headerlink" title="route生命周期钩子"></a>route生命周期钩子</h2><p>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。<br>具体名字：</p><ul><li><code>activated</code>路由组件被激活时触发。</li><li><code>deactivated</code>路由组件失活时触发。</li></ul><blockquote><p>这两个生命周期钩子需要配合前面的缓存路由组件使用（没有缓存路由组件不起效果）</p></blockquote><h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><ol><li><p>作用：对路由进行权限控制</p></li><li><p>分类：全局守卫、独享守卫、组件内守卫</p></li></ol><h3 id="全局守卫"><a href="#全局守卫" class="headerlink" title="全局守卫"></a>全局守卫</h3><p>全局前置守卫包含三个 <code>beforeEach</code> 前置守卫，<code>affterEach</code> 后置守卫，<code>beforeResolve</code> 解析守卫</p><h4 id="router-beforeEach"><a href="#router-beforeEach" class="headerlink" title="router.beforeEach"></a>router.beforeEach</h4><p><code>router.beforeEach((to,from,next)=&gt;&#123;&#125;)</code></p><p>回调函数中的参数，</p><ul><li><p><code>to</code>：进入到哪个路由去</p></li><li><p><code>from</code>：从哪个路由离开</p></li><li><p><code>next</code>：函数，决定是否展示你要看到的路由页面。</p><p><code>next</code>方法的调用参数。</p><ul><li><code>next()</code>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 <strong>confirmed</strong> (确认的)。</li><li><code>next(false)</code>: 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 <code>from</code> 路由对应的地址。</li><li><code>next(&#39;/&#39;)</code> 或者 <code>next(&#123; path: &#39;/&#39; &#125;)</code>: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 <code>next</code> 传递任意位置对象，且允许设置诸如 <code>replace: true</code>、<code>name: &#39;home&#39;</code> 之类的选项以及任何用在 <a href="https://router.vuejs.org/zh/api/#to"><code>router-link</code> 的 <code>to</code>prop</a> 或 <a href="https://router.vuejs.org/zh/api/#router-push"><code>router.push</code></a> 中的选项。</li><li><code>next(error)</code>: (2.4.0+) 如果传入 <code>next</code> 的参数是一个 <code>Error</code> 实例，则导航会被终止且该错误会被传递给 <a href="https://router.vuejs.org/zh/api/#router-onerror"><code>router.onError()</code></a> 注册过的回调。</li></ul></li></ul><p>从名字全局前置守卫不难理解，它是全局的，即对 整个单页应用（SPA） 中的所有路由都生效，所以当定义了全局的前置守卫，在进入每一个路由之前都会调用这个回调</p><h4 id="router-beforeResolve"><a href="#router-beforeResolve" class="headerlink" title="router.beforeResolve"></a>router.beforeResolve</h4><p><code>router.beforeResolve((to, from, next) =&gt; &#123;&#125;)</code></p><p>​参数与<code>beforeEach</code>相同</p><ul><li><code>to</code>：进入到哪个路由去</li><li><code>from</code>：从哪个路由离开</li><li><code>next</code>：函数，决定是否展示你要看到的路由页面。</li></ul><p>他们两个的区别</p><ul><li><p>执行的时机不一样</p><p><code>beforeEach</code> 是在路由规则被循环之前执行<br><code>beforResolve</code> 是在组件被解析之后调用</p></li><li><p>执行顺序</p><p><code>beforeEach</code> 要比 <code>beforResolve</code> 先执行</p></li></ul><h4 id="router-afterEach"><a href="#router-afterEach" class="headerlink" title="router.afterEach"></a>router.afterEach</h4><p><code>router.afterEach((to, from) =&gt; &#123;&#125;)</code></p><p>​    只有两个参数，</p><ul><li><code>to</code>：进入到哪个路由去</li><li><code>from</code>：从哪个路由离开</li></ul><p>全局后置守卫是整个单页应用中每一次路由跳转后都会执行其中的回调。所以多用于路由跳转后的相应页面操作，并不像全局前置守卫那样会在回调中进行页面的重定向或跳转。</p><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//全局前置守卫：初始化时执行、每次路由切换前执行</span><br>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">if</span>(to.<span class="hljs-property">meta</span>.<span class="hljs-property">isAuth</span>)&#123; <span class="hljs-comment">//判断当前路由是否需要进行权限控制</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;school&#x27;</span>) === <span class="hljs-string">&#x27;zhejiang&#x27;</span>)&#123; <span class="hljs-comment">//权限控制的具体规则</span><br><span class="hljs-title function_">next</span>() <span class="hljs-comment">//放行</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;暂无权限查看&#x27;</span>)<br><span class="hljs-comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span><br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-title function_">next</span>() <span class="hljs-comment">//放行</span><br>&#125;<br>&#125;)<br><br><span class="hljs-comment">//全局后置守卫：初始化时执行、每次路由切换后执行</span><br>router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span></span>)=&gt;</span>&#123;<br><span class="hljs-keyword">if</span>(to.<span class="hljs-property">meta</span>.<span class="hljs-property">title</span>)&#123; <br><span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = to.<span class="hljs-property">meta</span>.<span class="hljs-property">title</span> <span class="hljs-comment">//修改网页的title</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">&#x27;vue_test&#x27;</span><br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="独享守卫"><a href="#独享守卫" class="headerlink" title="独享守卫"></a>独享守卫</h3><p>独享守卫只有<code>beforeEnter</code>，并且写在<code>routes</code>的子路由中，仅对配置的一个路由生效</p><h4 id="beforeEnter"><a href="#beforeEnter" class="headerlink" title="beforeEnter"></a>beforeEnter</h4><p><code>beforeEnter:(to,from,next)=&gt;&#123;&#125;</code></p><p>​参数与<code>beforeEach</code>相同</p><ul><li><code>to</code>：进入到哪个路由去</li><li><code>from</code>：从哪个路由离开</li><li><code>next</code>：函数，决定是否展示你要看到的路由页面。</li></ul><p>​    与全局路由守卫用法一致，但是只能针对一个页面使用</p><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> router =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>    <span class="hljs-attr">routes</span>: [<br>        &#123;<br>            <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xinwen&#x27;</span>,<br>            <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;news&#x27;</span>,<br>            <span class="hljs-attr">component</span>:<span class="hljs-title class_">News</span>,<br>            <span class="hljs-attr">meta</span>:&#123;<span class="hljs-attr">isAuth</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">title</span>:<span class="hljs-string">&#x27;新闻&#x27;</span>&#125;,<br>            <span class="hljs-attr">beforeEnter</span>: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;独享路由守卫&#x27;</span>,to,<span class="hljs-keyword">from</span>)<br>                <span class="hljs-keyword">if</span>(to.<span class="hljs-property">meta</span>.<span class="hljs-property">isAuth</span>)&#123; <span class="hljs-comment">//判断是否需要鉴权</span><br>                    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;school&#x27;</span>)===<span class="hljs-string">&#x27;atguigu&#x27;</span>)&#123;<br>                        <span class="hljs-title function_">next</span>()<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;学校名不对，无权限查看！&#x27;</span>)<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-title function_">next</span>()<br>                &#125;<br>            &#125;<br>        &#125;,<br>    ]<br>)&#125;<br></code></pre></td></tr></table></figure><h3 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a>组件内的守卫</h3><p>组件内的守卫包含三个 <code>beforeRouterEnter</code> ，<code>beforeRouterUpdated</code>， <code>beforeRouterLeave</code> </p><h3 id="beforeRouterEnter"><a href="#beforeRouterEnter" class="headerlink" title="beforeRouterEnter"></a>beforeRouterEnter</h3><p><code>beforeRouteEnter:(to,from,next)=&gt;&#123;&#125;</code></p><p>参数与全局路由守卫一致，触发在进入组件之前。当守卫执行前，组件实例还没被创建，故无法访问 <code>this</code></p><p>项目需要在进入某个页面前，判断从特定页面进来时，做某些处理。例如：只有从详情页回到列表页需要重新调接口。此时，用到了<code>beforeRouteEnter</code>方法。</p><p><strong>注意</strong>：在内部获取不到外部的<code>this</code>，方法、变量等都获取不到。但<code>vm</code>可以获取到<code>method</code>中的方法以及变量</p><h3 id="beforeRouterUpdated"><a href="#beforeRouterUpdated" class="headerlink" title="beforeRouterUpdated"></a>beforeRouterUpdated</h3><p><code>beforeRouterUpdated:(to,from,next)=&gt;&#123;&#125;</code></p><p>参数与全局路由守卫一致</p><p>在当前路由改变，但是该组件被复用时调用，即路由路径不变，调用的是同个界面，即组件被连续复用的时候，会调用到<code>beforeRouteUpdate</code>触发</p><h3 id="beforeRouterLeave"><a href="#beforeRouterLeave" class="headerlink" title="beforeRouterLeave"></a>beforeRouterLeave</h3><p><code>beforeRouterLeave:(to,from,next)=&gt;&#123;&#125;</code></p><p>参数与全局路由守卫一致，导航离开该组件的对应路由时调用</p><p>在页面离开时做的操作，最常见的场景：用户修改了页面某些字段，还没有保存就要离开当前页面。此时在页面离开前需要给用户提示</p><p><strong>注意</strong>：此时函数内部可以访问到<code>this</code>，执行完要做的操作后，必须写 <code>next()</code>，否则页面不会跳转</p><h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;About&#x27;</span>,<br><span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeCreate&#x27;</span>)<br>&#125;,<br><br><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;mounted&#x27;</span>)<br>&#125;,<br><span class="hljs-title function_">beforeDestroy</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeDestroy&#x27;</span>)<br>&#125;,<br><br><span class="hljs-comment">//通过路由规则，进入该组件时被调用</span><br><span class="hljs-title function_">beforeRouteEnter</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeRouteEnter&#x27;</span>, to, <span class="hljs-keyword">from</span>)<br><span class="hljs-keyword">if</span> (to.<span class="hljs-property">meta</span>.<span class="hljs-property">isAuth</span>) &#123;<br><span class="hljs-comment">//判断是否需要鉴权</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;school&#x27;</span>) === <span class="hljs-string">&#x27;xuexiao&#x27;</span>) &#123;<br><span class="hljs-title function_">next</span>()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;学校名不对，无权限查看！&#x27;</span>)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-title function_">next</span>()<br>&#125;<br>&#125;,<br><br><span class="hljs-comment">//通过路由规则，离开该组件时被调用</span><br><span class="hljs-title function_">beforeRouteLeave</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeRouteLeave&#x27;</span>, to, <span class="hljs-keyword">from</span>)<br><span class="hljs-title function_">next</span>()<br>&#125;,<br>&#125;<br><br><span class="hljs-comment">//输出：</span><br><span class="hljs-comment">// beforeRouteEnter </span><br><span class="hljs-comment">// beforeCreate</span><br><span class="hljs-comment">// mounted</span><br><span class="hljs-comment">// beforeRouteLeave</span><br><span class="hljs-comment">// beforeDestroy</span><br></code></pre></td></tr></table></figure><h2 id="路由器的两种工作模式"><a href="#路由器的两种工作模式" class="headerlink" title="路由器的两种工作模式"></a>路由器的两种工作模式</h2><p>路由器的两种工作模式分别为<code>hash</code>模式和<code>history</code>模式，默认是<code>hash</code>模式。</p><ol><li><p>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。</p></li><li><p>hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。</p></li></ol><h3 id="设置模式"><a href="#设置模式" class="headerlink" title="设置模式"></a>设置模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br><span class="hljs-attr">mode</span>:<span class="hljs-string">&#x27;history&#x27;</span>, <span class="hljs-comment">// 默认不写mode 是hash</span><br><span class="hljs-attr">routes</span>:[&#123;&#125;],<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="hash模式"><a href="#hash模式" class="headerlink" title="hash模式"></a>hash模式</h3><p>路由器默认的工作模式是<code>hash</code>模式。因此我们看到的是</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">http:</span>//localhost:<span class="hljs-number">8080</span>/<span class="hljs-meta">#/</span><br><span class="hljs-symbol">http:</span>//localhost:<span class="hljs-number">8080</span>/<span class="hljs-meta">#/about</span><br><span class="hljs-symbol">http:</span>//localhost:<span class="hljs-number">8080</span>/<span class="hljs-meta">#/home</span><br></code></pre></td></tr></table></figure><ol><li>地址中永远带着#号，不美观 。</li><li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li><li>兼容性较好，<code>hash</code>模式所有浏览器天生支持</li></ol><h3 id="history模式"><a href="#history模式" class="headerlink" title="history模式"></a>history模式</h3><p>路由器工作模式为<code>history</code>模式时，我们看到的是</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//localhost:8080/</span><br><span class="hljs-symbol">http:</span><span class="hljs-comment">//localhost:8080/about</span><br><span class="hljs-symbol">http:</span><span class="hljs-comment">//localhost:8080/home</span><br></code></pre></td></tr></table></figure><ol><li>地址干净，美观 。</li><li><code>history</code>模式，它内部使用的是<code>h5</code>中提供的<code>api</code>，兼容性没有<code>hash</code>模式的兼容性好</li><li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mixin (混入)</title>
    <link href="/2022/10/07/vue/mixin/"/>
    <url>/2022/10/07/vue/mixin/</url>
    
    <content type="html"><![CDATA[<h1 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h1><p><strong>混入 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项</strong></p><p>Mixins 是一种分发 Vue 组件中可复用功能的非常灵活的一种方式。页面的风格不用，但是执行的方法和需要的数据类似就可以选择使用混入</p><p>混合对于封装一小段想要复用的代码来讲是有用的。它们当然不是唯一可行的。混合很好，它不需要传递状态，但是这种模式当然也可能会被滥用</p><span id="more"></span><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="mixin混入对象和Vuex的区别"><a href="#mixin混入对象和Vuex的区别" class="headerlink" title="mixin混入对象和Vuex的区别"></a>mixin混入对象和Vuex的区别</h3><ul><li><p>Vuex是<strong>状态共享管理</strong>，所以Vuex中的<strong>所有变量和方法都是可以读取和更改并相互影响的</strong></p></li><li><p>mixin可以<strong>定义公用的变量或方法</strong>，但是mixin中的<strong>数据是不共享的</strong>，也就是每个组件中的mixin实例都是不一样的，都是<strong>单独存在的个体，不存在相互影响的</strong></p></li><li><p>mixin混入对象值为函数的同名函数选项将会进行递归合并为数组，两个函数都会执行，只不过先执行mixin中的同名函数</p></li><li><p>mixin混入对象值为对象的同名对象将会进行替换，都优先执行组件内的同名对象，也就是组件内的同名对象将mixin混入对象的同名对象进行覆盖</p></li></ul><h3 id="与公共组件的区别"><a href="#与公共组件的区别" class="headerlink" title="与公共组件的区别"></a>与公共组件的区别</h3><ul><li>组件：在父组件中引入组件，相当于在父组件中给出一片独立的空间供子组件使用，然后根据props来传值，但本质上两者是相对独立的</li><li>Mixins：则是在引入组件之后与组件中的对象和方法进行合并，相当于扩展了父组件的对象与方法，可以理解为形成了一个新的组件</li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义一个混入对象 mixin.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> myMixin = &#123;<br>    <span class="hljs-attr">methods</span>: &#123;<br>        <span class="hljs-title function_">hello</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello from mixin!&#x27;</span>)<br>        &#125;,<br>    &#125;,<br>    <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hello</span>()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义一个使用混入对象的组件 </span><br><span class="hljs-keyword">import</span> &#123; myMixin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../mixin&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MixinComponent</span> = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">extend</span>(&#123;<br>    <span class="hljs-attr">mixins</span>: [myMixin],<br>&#125;)<br><span class="hljs-comment">// or</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;MixinComponent&#x27;</span>,<br>    <span class="hljs-attr">mixins</span>: [myMixin],<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="选项合并规则"><a href="#选项合并规则" class="headerlink" title="选项合并规则"></a>选项合并规则</h2><p>当组件和混入对象含有同名选项时，这些选项将以恰当的方式混合。</p><h3 id="数据对象内"><a href="#数据对象内" class="headerlink" title="数据对象内"></a>数据对象内</h3><p>mixin 的数据对象和组件的数据发生冲突时以组件数据优先。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> mixin = &#123;<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello&#x27;</span>,<br>            <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;abc&#x27;</span>,<br>        &#125;<br>    &#125;,<br>&#125;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">mixins</span>: [mixin],<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;goodbye&#x27;</span>,<br>            <span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;def&#x27;</span>,<br>        &#125;<br>    &#125;,<br>    <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>)<br>        <span class="hljs-comment">// =&gt; &#123; message: &quot;goodbye&quot;, foo: &quot;abc&quot;, bar: &quot;def&quot; &#125;</span><br>    &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><p>同名钩子函数将会混合为一个数组，都将被调用到，但是混入对象的钩子将在组件自身钩子之前调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> mixin = &#123;<br>    <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;混入对象的钩子被调用&#x27;</span>)<br>    &#125;,<br>&#125;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">mixins</span>: [mixin],<br>    <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;组件钩子被调用&#x27;</span>)<br>    &#125;,<br>&#125;)<br><span class="hljs-comment">// =&gt; &quot;混入对象的钩子被调用&quot;</span><br><span class="hljs-comment">// =&gt; &quot;组件钩子被调用&quot;</span><br></code></pre></td></tr></table></figure><h3 id="值为对象的选项"><a href="#值为对象的选项" class="headerlink" title="值为对象的选项"></a>值为对象的选项</h3><p>值为对象的选项，例如 <code>methods</code>，<code>components</code> 和 <code>directives</code>，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> mixin = &#123;<br>    <span class="hljs-attr">methods</span>: &#123;<br>        <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<br>        &#125;,<br>        <span class="hljs-title function_">conflicting</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;from mixin&#x27;</span>)<br>        &#125;,<br>    &#125;,<br>&#125;<br><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">mixins</span>: [mixin],<br>    <span class="hljs-attr">methods</span>: &#123;<br>        <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;bar&#x27;</span>)<br>        &#125;,<br>        <span class="hljs-title function_">conflicting</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;from self&#x27;</span>)<br>        &#125;,<br>    &#125;,<br>&#125;)<br>vm.<span class="hljs-title function_">foo</span>() <span class="hljs-comment">// =&gt; &quot;foo&quot;</span><br>vm.<span class="hljs-title function_">bar</span>() <span class="hljs-comment">// =&gt; &quot;bar&quot;</span><br>vm.<span class="hljs-title function_">conflicting</span>() <span class="hljs-comment">// =&gt; &quot;from self&quot;</span><br></code></pre></td></tr></table></figure><h2 id="全局混入（不推荐）"><a href="#全局混入（不推荐）" class="headerlink" title="全局混入（不推荐）"></a>全局混入（不推荐）</h2><p>全局混合被注册到了每个单一组件上。因此，它们的使用场景极其有限并且要非常的小心。一个我能想到的用途就是它像一个插件，你需要赋予它访问所有东西的权限。但即使在这种情况下，我也对你正在做的保持警惕，尤其是你在应用中扩展的函数，可能对你来说是不可知的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>(&#123;<br>    <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;我是mixin&quot;</span>)<br>    &#125;<br>&#125;)<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>注意:</strong> 一旦使用全局混入对象，将会影响到<strong>所有</strong>之后创建的 Vue 实例。使用恰当时，可以为自定义对象注入处理逻辑</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 为自定义的选项 &#x27;myOption&#x27; 注入一个处理器。</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>(&#123;<br>    <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> myOption = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">myOption</span><br>        <span class="hljs-keyword">if</span> (myOption) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myOption)<br>        &#125;<br>    &#125;,<br>&#125;)<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">myOption</span>: <span class="hljs-string">&#x27;hello!&#x27;</span>,<br>&#125;)<br><br><span class="hljs-comment">// =&gt; &quot;hello!&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 脚手架</title>
    <link href="/2022/10/06/vue/Vue%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <url>/2022/10/06/vue/Vue%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-脚手架"><a href="#Vue-脚手架" class="headerlink" title="Vue 脚手架"></a>Vue 脚手架</h1><blockquote><p>使用前置：</p><p>第一步(没有安装过的执行)：全局安装 @vue&#x2F;cli</p><p>npm install -g @vue&#x2F;cli</p><p>第二步：切换到要创建项目的目录，然后使用命令创建项目</p><p>vue create xxxxx</p><p>第三步：启动项目</p><p>npm run serve</p></blockquote><span id="more"></span><h2 id="脚手架文件结构"><a href="#脚手架文件结构" class="headerlink" title="脚手架文件结构"></a>脚手架文件结构</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stylus">├── node_modules <br>├── public<br>│   ├── favicon<span class="hljs-selector-class">.ico</span>: 页签图标<br>│   └── index<span class="hljs-selector-class">.html</span>: 主页面<br>├── <span class="hljs-attribute">src</span><br>│   ├── assets: 存放静态资源<br>│   │   └── logo<span class="hljs-selector-class">.png</span><br>│   │── component: 存放组件<br>│   │   └── HelloWorld<span class="hljs-selector-class">.vue</span><br>│   │── App<span class="hljs-selector-class">.vue</span>: 汇总所有组件<br>│   │── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.js</span>: 入口文件<br>├── <span class="hljs-selector-class">.gitignore</span>: git版本管制忽略的配置<br>├── babel<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.js</span>: babel的配置文件<br>├── package<span class="hljs-selector-class">.json</span>: 应用包配置文件 <br>├── README<span class="hljs-selector-class">.md</span>: 应用描述文件<br>├── package-lock.json：包版本控制文件<br></code></pre></td></tr></table></figure><h2 id="脚手架demo"><a href="#脚手架demo" class="headerlink" title="脚手架demo"></a>脚手架demo</h2><h3 id="components"><a href="#components" class="headerlink" title="components:"></a>components:</h3><p>就直接把单文件组件的 School.vue 和 Student.vue 两个文件直接拿来用，不需要修改。</p><h3 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue:"></a>App.vue:</h3><p>引入这两个组件，注册一下这两个组件，再使用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Vue logo&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./assets/logo.png&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Student</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Student</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">School</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">School</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">School</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/School.vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Student.vue&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;App&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title class_">School</span>,</span><br><span class="language-javascript">    <span class="hljs-title class_">Student</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-id">#app</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">font-family</span>: Avenir, Helvetica, Arial, sans-serif;</span><br><span class="language-css">  -webkit-<span class="hljs-attribute">font-smoothing</span>: antialiased;</span><br><span class="language-css">  -moz-osx-<span class="hljs-attribute">font-smoothing</span>: grayscale;</span><br><span class="language-css">  <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">  <span class="hljs-attribute">color</span>: <span class="hljs-number">#2c3e50</span>;</span><br><span class="language-css">  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">60px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="main-js"><a href="#main-js" class="headerlink" title="main.js:"></a>main.js:</h3><p>入口文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p>接下来就要详细讲解 main.js 中的 render 函数</p><h2 id="render函数"><a href="#render函数" class="headerlink" title="render函数"></a>render函数</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>之前的写法是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#root&#x27;</span>,<br><span class="hljs-attr">template</span>:<span class="hljs-string">`&lt;App&gt;&lt;/App&gt;`</span>,<br><span class="hljs-attr">components</span>:&#123;<span class="hljs-title class_">App</span>&#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><p>如果这样子写，运行的话会引发如下的报错</p><p><img src="/%5Cimages%5Cvue%5Cvue_%E8%84%9A%E6%89%8B%E6%9E%B6_render%E5%87%BD%E6%95%B0.png" alt="vue_脚手架_render函数"></p><p>报错的意思是，是在使用运行版本的 vue ，没有模板解析器。</p><p>从上面的小知识可以知道，我们引入的 vue 不是完整版的，是残缺的（为了减小vue的大小）。所以残缺的<code>vue.js</code> 只有通过 <code>render</code> 函数才能把项目给跑起来。</p><p>来解析一下<code>render</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// render最原始写的方式</span><br><span class="hljs-comment">// render是个函数，还能接收到参数a</span><br><span class="hljs-comment">// 这个 createElement 很关键，是个回调函数</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params">createElement</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> createElement)<br>      <span class="hljs-comment">// 这个 createElement 回调函数能创建元素</span><br>      <span class="hljs-comment">// 因为残缺的vue 不能解析 template，所以render就来帮忙解决这个问题</span><br>      <span class="hljs-comment">// createElement 能创建具体的元素</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;h1&#x27;</span>, <span class="hljs-string">&#x27;hello&#x27;</span>)<br>  &#125;<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p><img src="/%5Cimages%5Cvue%5Cvue_%E8%84%9A%E6%89%8B%E6%9E%B6_render%E5%87%BD%E6%95%B02.png" alt="vue_脚手架_render函数2"></p><p>因为 <code>render</code> 函数内并没有用到 <code>this</code>，所以可以简写成箭头函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-comment">// render: h =&gt; h(App),</span><br>  <span class="hljs-attr">render</span>: <span class="hljs-function">(<span class="hljs-params">createElement</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-title class_">App</span>)<br>  &#125;<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p>再简写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-comment">// render: h =&gt; h(App),</span><br>  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">createElement</span> =&gt;</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-title class_">App</span>)<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p>最后把 <code>createElement</code> 换成 <code>h</code> 就完事了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对象内写方法最原始的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;aaa&#x27;</span>,<br>    <span class="hljs-attr">work</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">salary</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;工资&#x27;</span> + salary;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ES6 简化版：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;aaa&#x27;</span>,<br>    <span class="hljs-title function_">work</span>(<span class="hljs-params">salary</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;工资&#x27;</span> + salary;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>箭头函数简化版:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;aaa&#x27;</span>,<br>    <span class="hljs-attr">work</span>: <span class="hljs-function">(<span class="hljs-params">salary</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;工资&#x27;</span> + salary;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>箭头函数再简化（最终版）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 只有一个参数就可以把圆括号去了，函数体内部只有一个 return 就可以把大括号去掉，return去掉</span><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;aaa&#x27;</span>,<br>    <span class="hljs-attr">work</span>: <span class="hljs-function"><span class="hljs-params">salary</span> =&gt;</span> <span class="hljs-string">&#x27;工资&#x27;</span> + salary;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以理解 <code>render</code> 函数的简写方式了。</p><p>来个不同版本 vue 的区别</p><ul><li><code>vue.js</code>与<code>vue.runtime.xxx.js</code>的区别：<ul><li><code>vue.js</code>是完整版的Vue，包含：核心功能+模板解析器。</li><li><code>vue.runtime.xxx.js</code>是运行版的Vue，只包含：核心功能；没有模板解析器。</li></ul></li><li>因为<code>vue.runtime.xxx.js</code>没有模板解析器，所以不能使用<code>template</code>配置项，需要使用<code>render</code>函数接收到的<code>createElement</code>函数去指定具体内容。</li></ul><h2 id="修改脚手架的默认配置"><a href="#修改脚手架的默认配置" class="headerlink" title="修改脚手架的默认配置"></a>修改脚手架的默认配置</h2><ul><li>使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。</li><li>使用vue.config.js可以对脚手架进行个性化定制，详情见：<a href="https://cli.vuejs.org/zh">https://cli.vuejs.org/zh</a></li></ul><h2 id="脚手架中的index-html"><a href="#脚手架中的index-html" class="headerlink" title="脚手架中的index.html"></a>脚手架中的index.html</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 针对IE浏览器的一个特殊配置，含义是让IE浏览器以最高的渲染级别渲染页面 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 开启移动端的理想视口 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width,initial-scale=1.0&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 配置页签图标 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;icon&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 引入第三方样式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&lt;%= BASE_URL %&gt;css/bootstrap.css&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 配置网页标题 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>硅谷系统<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 当浏览器不支持js时noscript中的元素就会被渲染 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>We&#x27;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#x27;t work properly without JavaScript enabled. Please enable it to continue.<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">noscript</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 容器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- built files will be auto injected --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组件间通信</title>
    <link href="/2022/10/06/vue/%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <url>/2022/10/06/vue/%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h1><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><p>一个组件里面引入另外一个组件，此时构成了一种“父子关系”，当前组件为“父”，引入的组件为“子”，如当前组件（父），在父组件中通过 <code>:message</code>向子组件通信。</p><span id="more"></span><p>父组件 <code>Parent.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div class=&quot;parent-box&quot;&gt;<br>        &lt;div&gt;<br>            &lt;div&gt;我是父组件&lt;/div&gt;<br>            &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;<br>        &lt;/div&gt;<br>        &lt;children :message=&quot;toChildrenMsg&quot;&gt;&lt;/children&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br>  <br>&lt;script&gt;<br>    import Children from &#x27;./Children.vue&#x27; //当前页引入子组件<br>    export default &#123;<br>        name: &#x27;Parent&#x27;,<br>        components: &#123;<br>            Children,<br>        &#125;,<br>        data() &#123;<br>            return &#123;<br>                message: &#x27;我是父组件的内容&#x27;,<br>                toChildrenMsg: &#x27;从父组件传过到子组件的内容&#x27;,<br>            &#125;<br>        &#125;,<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>子组件 <code>Children.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div class=&quot;children-box&quot;&gt;<br>        &lt;div&gt;<br>            &lt;div&gt;我是子组件&lt;/div&gt;<br>            &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;<br>        &lt;/div&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br>  <br>&lt;script&gt;<br>    export default &#123;<br>        name: &#x27;Children&#x27;,<br>        props: &#123;<br>            message: &#123;<br>                type: String, //类型判断<br>                default: &#x27;&#x27;, //默认值<br>            &#125;,<br>        &#125;,<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>在子组件通过<code>props</code>进行接收，注意子组件<code>props</code>里面接收的对象名称必须与父组件中在子组件绑定的名称一致，当前例子为<code>message</code>，可以在组件中<code>this.message</code>的方式使用<code>props</code>里面的值。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ol><li><p>此方式用于父组件向子组件传递数据</p></li><li><p>所有标签属性都会成为组件对象的属性，模板组件可以直接引用</p></li><li><p>问题:</p><p>a. 如果需要向非子后代传递数据必须多层逐层传递</p><p>b. 兄弟组件间也不能直接 props 通信，必须借助父组件才可以</p></li></ol><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>组件自定义事件是一种组件间通信的方式，适用于：<strong style="color:red">子组件 &#x3D;&#x3D;&#x3D;&gt; 父组件</strong></p><p><strong>使用场景</strong></p><p>A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style="color:red">事件的回调在A中</span>）。</p><h3 id="第一种绑定方式"><a href="#第一种绑定方式" class="headerlink" title="第一种绑定方式"></a>第一种绑定方式</h3><p>在父组件中：<code>&lt;Demo @hello=&quot;test&quot;/&gt;</code>或 <code>&lt;Demo v-on:hello=&quot;test&quot;/&gt;</code></p><p><code>App.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div class=&quot;app&quot;&gt;<br>&lt;!-- 通过父组件给子组件绑定一个自定义事件实现：子给父传递数据（第一种写法，使用@或v-on） --&gt;<br>&lt;Student @atguigu=&quot;getStudentName&quot;/&gt; <br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import Student from &#x27;./components/Student&#x27;<br><br>export default &#123;<br>name:&#x27;App&#x27;,<br>components:&#123;Student&#125;,<br>data() &#123;<br>return &#123;<br>msg:&#x27;你好啊！&#x27;,<br>studentName:&#x27;&#x27;<br>&#125;<br>&#125;,<br>methods: &#123;<br>getStudentName(name,...params)&#123;<br>console.log(&#x27;App收到了学生名：&#x27;,name,params)<br>this.studentName = name<br>&#125;<br>&#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><code>Student.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div class=&quot;student&quot;&gt;<br>&lt;button @click=&quot;sendStudentlName&quot;&gt;把学生名给App&lt;/button&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>name:&#x27;Student&#x27;,<br>data() &#123;<br>return &#123;<br>name:&#x27;张三&#x27;,<br>&#125;<br>&#125;,<br>methods: &#123;<br>sendStudentlName()&#123;<br>//触发Student组件实例身上的atguigu事件<br>this.$emit(&#x27;atguigu&#x27;,this.name,666,888,900)<br>&#125;<br>&#125;,<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;less&quot; scoped&gt;<br>.student&#123;<br>background-color: pink;<br>padding: 5px;<br>margin-top: 30px;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>当子组件<code>Student.vue</code>触发点击事件时，<code>Student.vue</code>中<code>$emit</code>执行，触发 <code>App.vue</code>组件上<code>Student</code>组件实例身上的<code>atguigu</code>事件，将<code>this.$emit(&#39;atguigu&#39;,this.name,666,888,900)</code>中，需要的参数交给<code>App.vue</code>以实现子组件向父组件传参。</p><h3 id="第二种绑定方式"><a href="#第二种绑定方式" class="headerlink" title="第二种绑定方式"></a>第二种绑定方式</h3><p>在父组件中：使用 <code>this.$refs.xxx.$on()</code> </p><p>这样写起来更灵活，比如可以加定时器啥的。</p><p><code>App.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div class=&quot;app&quot;&gt;<br>&lt;!-- 通过父组件给子组件绑定一个自定义事件实现：子给父传递数据（第二种写法，使用ref） --&gt;<br>&lt;Student ref=&quot;student&quot;/&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import Student from &#x27;./components/Student&#x27;<br><br>export default &#123;<br>name:&#x27;App&#x27;,<br>components:&#123;Student&#125;,<br>data() &#123;<br>return &#123;<br>studentName:&#x27;&#x27;<br>&#125;<br>&#125;,<br>methods: &#123;<br>getStudentName(name,...params)&#123;<br>console.log(&#x27;App收到了学生名：&#x27;,name,params)<br>this.studentName = name<br>&#125;,<br>&#125;,<br>mounted() &#123;<br>this.$refs.student.$on(&#x27;atguigu&#x27;,this.getStudentName) //绑定自定义事件<br>// this.$refs.student.$once(&#x27;atguigu&#x27;,this.getStudentName) //绑定自定义事件（一次性）<br>&#125;,<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><code>Student.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div class=&quot;student&quot;&gt;<br>&lt;button @click=&quot;sendStudentlName&quot;&gt;把学生名给App&lt;/button&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>name:&#x27;Student&#x27;,<br>data() &#123;<br>return &#123;<br>name:&#x27;张三&#x27;,<br>&#125;<br>&#125;,<br>methods: &#123;<br>sendStudentlName()&#123;<br>//触发Student组件实例身上的atguigu事件<br>this.$emit(&#x27;atguigu&#x27;,this.name,666,888,900)<br>&#125;<br>&#125;,<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>上述实例代码中，在父组件 <code>App.vue</code> 中为 <code>Student</code>组件取别名 <code>&lt;Student ref=&quot;student&quot;/&gt;</code>，通过<code>this.$refs.student.$on(&#39;atguigu&#39;,this.getStudentName)</code>绑定自定义事件 <code>atguigu</code> ，然后在子组件<code>Student</code>中触发事件传参</p><blockquote><p>注意：通过<code>this.$refs.xxx.$on(&#39;atguigu&#39;,回调)</code>绑定自定义事件时，回调<span style="color:red">要么配置在methods中</span>，<span style="color:red">要么用箭头函数</span>，否则this指向会出问题！</p></blockquote><h3 id="解绑自定义事件"><a href="#解绑自定义事件" class="headerlink" title="解绑自定义事件"></a>解绑自定义事件</h3><p>解绑自定义事件，<code>this.$off(&#39;atguigu&#39;)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">this.$off(&#x27;atguigu&#x27;) //解绑一个自定义事件<br>// this.$off([&#x27;atguigu&#x27;,&#x27;demo&#x27;]) //解绑多个自定义事件<br>// this.$off() //解绑所有的自定义事件<br></code></pre></td></tr></table></figure><p>在绑定自定义事件后，如果组价执行完毕，在<code>beforeDestroy</code>钩子中解绑自定义事件，防止冲突</p><h2 id="全局事件总线"><a href="#全局事件总线" class="headerlink" title="全局事件总线"></a>全局事件总线</h2><p>全局事件总线是一种组件间通信的方式，适用于<strong>任意组件间通信</strong>。</p><h3 id="安装全局事件总线"><a href="#安装全局事件总线" class="headerlink" title="安装全局事件总线"></a>安装全局事件总线</h3><p>在<code>main.js</code>中，创建 <code>Vue</code>实例时，使用<code>Vue.prototype.$bus = this</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,<br><span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),<br><span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$bus</span> = <span class="hljs-variable language_">this</span> <span class="hljs-comment">//安装全局事件总线，$bus就是当前应用的vm</span><br>&#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="使用全局事件总线"><a href="#使用全局事件总线" class="headerlink" title="使用全局事件总线"></a>使用全局事件总线</h3><ol><li><p>接收数据：A组件想接收数据，则在A组件中给<code>$bus</code>绑定自定义事件，事件的<span style="color:red">回调留在A组件自身。</span></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">methods</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">demo</span>(<span class="hljs-params">data</span>)&#123;&#125;<br>&#125;<br><span class="hljs-comment">// </span><br><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.$on(<span class="hljs-string">&#x27;xxxx&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">demo</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>提供数据：<code>this.$bus.$emit(&#39;xxxx&#39;,数据)</code></p></li><li><p>最好在<code>beforeDestroy</code>钩子中，用<code>$off</code>去解绑<span style="color:red">当前组件所用到的</span>事件。</p></li></ol><h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><p><code>School.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div class=&quot;school&quot;&gt;<br>&lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;<br>&lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>name:&#x27;School&#x27;,<br>data() &#123;<br>return &#123;<br>name:&#x27;尚硅谷&#x27;,<br>address:&#x27;北京&#x27;,<br>&#125;<br>&#125;,<br>        methods: &#123;<br>            demo(data) &#123;<br>                console.log(&#x27;我是School组件，收到了数据&#x27;,data)<br>            &#125;<br>        &#125;<br>mounted() &#123;<br>            // 在接收数据的组件上绑定事件<br>this.$bus.$on(&#x27;hello&#x27;,this.demo)<br>&#125;,<br>beforeDestroy() &#123;<br>            // 解绑事件<br>this.$bus.$off(&#x27;hello&#x27;)<br>&#125;,<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><code>Student.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div class=&quot;student&quot;&gt;<br>&lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;<br>&lt;h2&gt;学生性别：&#123;&#123;sex&#125;&#125;&lt;/h2&gt;<br>&lt;button @click=&quot;sendStudentName&quot;&gt;把学生名给School组件&lt;/button&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>name:&#x27;Student&#x27;,<br>data() &#123;<br>return &#123;<br>name:&#x27;张三&#x27;,<br>sex:&#x27;男&#x27;,<br>&#125;<br>&#125;,<br>methods: &#123;<br>sendStudentName()&#123;<br>                // 触发想接收数据的组件上的事件，传入想发送的数据<br>this.$bus.$emit(&#x27;hello&#x27;,this.name)<br>&#125;<br>&#125;,<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><img src="/%5Cimages%5Cvue%5Cvue_%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1_%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF.png" alt="vue_组件间通信_全局事件总线"></p><h2 id="消息订阅与发布"><a href="#消息订阅与发布" class="headerlink" title="消息订阅与发布"></a>消息订阅与发布</h2><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li><p>安装pubsub：<code>npm i pubsub-js</code></p></li><li><p>引入: <code>import pubsub from &#39;pubsub-js&#39;</code></p></li><li><p>接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的<span style="color:red">回调留在A组件自身。</span></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">PubSub</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pubsub-js&#x27;</span> <span class="hljs-comment">//引入</span><br><span class="hljs-title class_">PubSub</span>.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&#x27;delete&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">msg, data</span>)&#123; &#125;) <span class="hljs-comment">//订阅</span><br><span class="hljs-title class_">PubSub</span>.<span class="hljs-title function_">publish</span>(<span class="hljs-string">&#x27;delete&#x27;</span>, data) <span class="hljs-comment">//发布消息</span><br></code></pre></td></tr></table></figure></li><li><p>提供数据：<code>pubsub.publish(&#39;xxx&#39;,数据)</code></p></li><li><p>最好在beforeDestroy钩子中，用<code>PubSub.unsubscribe(pid)</code>去<span style="color:red">取消订阅。</span></p></li></ol><h3 id="实例代码-1"><a href="#实例代码-1" class="headerlink" title="实例代码"></a>实例代码</h3><p>订阅消息<code>School.vue</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;school&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学校名称：&#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学校地址：&#123;&#123;address&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> pubsub <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pubsub-js&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;School&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript"><span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;尚硅谷&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">address</span>:<span class="hljs-string">&#x27;北京&#x27;</span>,</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript"><span class="hljs-comment">/* this.$bus.$on(&#x27;hello&#x27;,(data)=&gt;&#123;</span></span><br><span class="hljs-comment"><span class="language-javascript">console.log(&#x27;我是School组件，收到了数据&#x27;,data)</span></span><br><span class="hljs-comment"><span class="language-javascript">&#125;) */</span></span><br><span class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">pubId</span> = pubsub.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">msgName,data</span>)=&gt;</span>&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)</span><br><span class="language-javascript"><span class="hljs-comment">// console.log(&#x27;有人发布了hello消息，hello消息的回调执行了&#x27;,msgName,data)</span></span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-title function_">beforeDestroy</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript"><span class="hljs-comment">// this.$bus.$off(&#x27;hello&#x27;)</span></span><br><span class="language-javascript">pubsub.<span class="hljs-title function_">unsubscribe</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">pubId</span>)</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>发布消息<code>Student.vue</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;student&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学生姓名：&#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学生性别：&#123;&#123;sex&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sendStudentName&quot;</span>&gt;</span>把学生名给School组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> pubsub <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pubsub-js&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Student&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript"><span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">sex</span>:<span class="hljs-string">&#x27;男&#x27;</span>,</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript"><span class="hljs-comment">// console.log(&#x27;Student&#x27;,this.x)</span></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript"><span class="hljs-title function_">sendStudentName</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-comment">// this.$bus.$emit(&#x27;hello&#x27;,this.name)</span></span><br><span class="language-javascript">pubsub.<span class="hljs-title function_">publish</span>(<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-number">666</span>)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="slot插槽"><a href="#slot插槽" class="headerlink" title="slot插槽"></a>slot插槽</h2><ol><li><p>插槽（slot）是 vue 为组件的封装者提供的能力。允许开发者在封装组件时，把不确定的、希望由用户指定的部分定义为插槽。可以把插槽认为是组件封装期间，为用户预留的内容的占位符。 </p></li><li><p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 &#x3D;&#x3D;&#x3D;&gt; 子组件</strong> 。</p></li><li><p>分类：默认插槽、具名插槽、作用域插槽</p></li><li><p>注意：<strong>插槽内容是在父组件中编译后, 再传递给子组件的</strong>。</p></li></ol><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>vue 官方规定：每一个 <code>slot</code> 插槽，都要有一个 <code>name</code> 名称</p><p>如果省略了 <code>slot</code> 的 <code>name</code> 属性，则有一个默认名称叫做 <code>default</code> </p><p>在封装组件时，可以通过 <code>&lt;slot&gt;&lt;/slot&gt;</code> 元素定义插槽，从而为用户预留内容占位符。</p><p>如果在父组件引用子组件中没有结构，则会显示子组件中插槽<code>&lt;slot&gt;&lt;/slot&gt;</code>的内容</p><h3 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html">// 父组件中：<br><span class="hljs-tag">&lt;<span class="hljs-name">Category</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>html结构1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Category</span>&gt;</span><br>//子组件中：<br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 定义插槽 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span>插槽默认内容...<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><ul><li><p>子组件：如果在封装组件时需要预留多个插槽节点，则需要为每个 <code>&lt;slot&gt;&lt;/slot&gt;</code> 插槽指定具体的<code>name</code> 名称。这种带有具体名称的插槽叫做“具名插槽”。</p></li><li><p>父组件：在向具名插槽提供内容的时候，我们可以在一个 <code>&lt;template&gt;</code> 元素上使用<code>v-slot</code> 指令，并以<code>v-slot</code> 的参数的形式提供其名称，<code>v-slot</code>也有缩写，即把参数之前的所有内容<code>v-slot:</code> 替换为字符<code>#</code></p></li></ul><p>注意：没有指定 <code>name</code> 名称的插槽，会有隐含的名称叫做 <code>default</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html">// 父组件中：<br><span class="hljs-tag">&lt;<span class="hljs-name">Category</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>html结构1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>html结构2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">footer</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>html结构3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Category</span>&gt;</span><br>// 子组件中：<br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 定义插槽 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>插槽默认内容1...<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span>插槽默认内容2...<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span>插槽默认内容3...<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>理解：<span style="color:red">数据在组件的自身（子组件），但根据数据生成的结构需要组件的使用者（父组件）来决定。</span>（games数据在Category（子）组件中，但使用数据所遍历出来的结构由App（父）组件决定）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html">// 父组件中：<br><span class="hljs-tag">&lt;<span class="hljs-name">Category</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;scopeData&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 生成的是ul列表 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;g in scopeData.games&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;g&quot;</span>&gt;</span>&#123;&#123;g&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Category</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">Category</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">&quot;scopeData&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 生成的是h4标题 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h4</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;g in scopeData.games&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;g&quot;</span>&gt;</span>&#123;&#123;g&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Category</span>&gt;</span><br><br>// 子组件中：<br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 通过数据绑定就可以把子组件的数据传到父组件 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">:games</span>=<span class="hljs-string">&quot;games&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Category&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;title&#x27;</span>],</span><br><span class="language-javascript">        <span class="hljs-comment">//数据在子组件自身</span></span><br><span class="language-javascript">        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">                <span class="hljs-attr">games</span>: [<span class="hljs-string">&#x27;红色警戒&#x27;</span>, <span class="hljs-string">&#x27;穿越火线&#x27;</span>, <span class="hljs-string">&#x27;劲舞团&#x27;</span>, <span class="hljs-string">&#x27;超级玛丽&#x27;</span>],</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>按键修饰符</title>
    <link href="/2022/10/06/vue/%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <url>/2022/10/06/vue/%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h1><p>在绑定了键盘或鼠标的点击事件后,可以通过按下的按键触发要进行的事件,这时需要在后方添加表示按键的修辞符</p><span id="more"></span><h2 id="按键码"><a href="#按键码" class="headerlink" title="按键码"></a>按键码</h2><p>可以通过 <code>keyCode</code> 的值来绑定需要触发的按键</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-on:keyup.13</span>=<span class="hljs-string">&quot;submit&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p><strong>部分特殊的按键码可以使用别名</strong></p><ul><li><code>.enter</code></li><li><code>.tab</code></li><li><code>.delete</code> (捕获“删除”和“退格”键)</li><li><code>.esc</code></li><li><code>.space</code></li><li><code>.up</code></li><li><code>.down</code></li><li><code>.left</code></li><li><code>.right</code></li></ul><p>也可以自定义按键修饰符的别名</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Vue<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.keyCodes</span><span class="hljs-selector-class">.f1</span> =<span class="hljs-number">112</span><br><span class="hljs-comment">//使用Vue对象上的全局属性config.keyCodes来定义别名 </span><br><span class="hljs-comment">//在绑定时就可以使用v-on:keyup.f1直接对f1按键进行操作了</span><br></code></pre></td></tr></table></figure><h2 id="系统修饰符"><a href="#系统修饰符" class="headerlink" title="系统修饰符"></a>系统修饰符</h2><p>系统修辞符监听仅在同时按下了绑定键盘或鼠标按钮时才会触发事件</p><h3 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h3><ul><li><code>.ctrl</code></li><li><code>.alt</code></li><li><code>.shift</code></li><li><code>.meta</code></li></ul><p><strong>注意</strong>:</p><p>在 Mac 系统键盘上，<code>meta</code> 对应 command 键 (⌘)。在 Windows 系统键盘 <code>meta</code> 对应 Windows 徽标键 (⊞)。</p><p>在 Sun 操作系统键盘上，<code>meta</code> 对应实心宝石键 (◆)。</p><p>在其他特定键盘上，尤其在 MIT 和 Lisp 机器的键盘、以及其后继产品，比如 Knight 键盘、space-cadet 键盘，meta 被标记为“META”。</p><p>在 Symbolics 键盘上，<code>meta</code> 被标记为“META”或者“Meta”。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Alt + C --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">keyup.alt.67</span>=<span class="hljs-string">&quot;clear&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- Ctrl + Click --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click.ctrl</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span>Do something<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="鼠标"><a href="#鼠标" class="headerlink" title="鼠标"></a>鼠标</h3><ul><li><code>.left</code></li><li><code>.right</code></li><li><code>.middle</code>  鼠标中键</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>注:修饰键与常规按键不同，在和 <code>keyup</code> 事件一起用时，事件触发时修饰键必须处于按下状态。</p><p>换句话说，只有在按住 <code>ctrl</code> 的情况下释放其它按键，才能触发 <code>keyup.ctrl</code>。而单单释放 <code>ctrl</code> 也不会触发事件。如果只想要单独触发，则需要使用 <code>keycode</code> 编码或<code>.exact</code>修饰符 </p><p><code>.exact</code></p><p><code>.exact</code> 修饰符允许用户控制由精确的系统修饰符组合触发的事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.ctrl</span>=<span class="hljs-string">&quot;onClick&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.ctrl.exact</span>=<span class="hljs-string">&quot;onCtrlClick&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.exact</span>=<span class="hljs-string">&quot;onClick&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 组件</title>
    <link href="/2022/10/05/vue/%E7%BB%84%E4%BB%B6/"/>
    <url>/2022/10/05/vue/%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-组件"><a href="#Vue-组件" class="headerlink" title="Vue 组件"></a>Vue 组件</h1><h2 id="组件的定义"><a href="#组件的定义" class="headerlink" title="组件的定义"></a>组件的定义</h2><p><strong>组件的出现是为了拆分 Vue 实例的代码量，能够让我们以不同的组件来划分不同的功能模板，将来需要什么样的功能，只需要调用对应的组件就可以了</strong></p><p><strong>组件化与模块化的区别</strong></p><ul><li>模块化是从代码逻辑的角度进行划分的;方便代码分层开发，保证每个功能模块的职能单一</li><li>组件化是从 UI 界面的角度进行划分的，前端的组件化是为了方便 UI 组件的重用</li></ul><span id="more"></span><h2 id="组件基本使用"><a href="#组件基本使用" class="headerlink" title="组件基本使用"></a>组件基本使用</h2><p><strong>组件的注意事项:</strong></p><ul><li><strong>每个组件必须只有一个根元素，</strong>可以将模板的内容包裹在一个父元素内来解决这个问题</li><li>组件中可以有自己的 <code>data</code> 数据，使用方式同 Vue 实例中一样，<strong>但是组件的 <code>data</code> 只能是一个方法，而且必须要返回一个包含了数据的对象</strong>，因为需要每个组件之间相互独立，如果不是一个函数，那么每个组件就会影响其他的组件 <strong>如果要想同时影响其他数据，可以创建一个外部的镀锡，每次 <code>data</code> 返回这个对象</strong></li></ul><h3 id="组件名"><a href="#组件名" class="headerlink" title="组件名"></a>组件名</h3><p><strong>在创建一个组件时，我们始终需要给该组件一个名字用作标识</strong>，组件名的有多种写法</p><ul><li><p><strong>短横线命名法</strong>，使用短横线命名法来命名组件在使用的时候也是直接将引用的组件名作为标签名来使用</p></li><li><p><strong>驼峰命名法，</strong>使用驼峰命名法命名的组件在引用这个组件时可以通过两种命名的方式来引用 </p><p>**注意:**当用作标签时只能使用短横线命名法，所以最好都使用短横线命名法来命名</p></li></ul><h3 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h3><ul><li>方式1：先创建一个组件构造器，然后由组件构造器创建组件，如:<code>var myCom =Vue.extend(option)</code></li><li>方式2：使用<code>Vue.component()</code>直接创建组件。<code>Vue.component(&#39;componentName&#39;,option) </code>， <code>option</code>相当于创建vue对象传入的配置对象</li><li>方式3：把组件的 <code>name</code> 属性作为注册后组件的名称</li></ul><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs xquery"> //方式<span class="hljs-number">1</span> 创建hello组件<br> const hello = Vue.extend(&#123;<br>     template:`<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>你好啊！</span><span class="language-xquery">&#123;<span class="hljs-built_in">&#123;name</span>&#125;</span><span class="language-xml">&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>`,<br>     data()&#123;<br>         <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-built_in"> name</span>:<span class="hljs-string">&#x27;Tom&#x27;</span><br>         &#125;<br>     &#125;<br> &#125;)<br> <br> // 方式<span class="hljs-number">2</span><br> Vue.component(<span class="hljs-string">&#x27;hello&#x27;</span>, &#123;<br>     template:`<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>你好啊！</span><span class="language-xquery">&#123;<span class="hljs-built_in">&#123;name</span>&#125;</span><span class="language-xml">&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>`,<br>     data()&#123;<br>         <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-built_in"> name</span>:<span class="hljs-string">&#x27;Tom&#x27;</span><br>         &#125;<br>     &#125;<br> &#125;)<br> <br> //方式<span class="hljs-number">3</span><br> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"> </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"> </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>你好啊！</span><span class="language-xquery">&#123;<span class="hljs-built_in">&#123;name</span>&#125;</span><span class="language-xml">&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> </span></span><span class="language-xquery">&#123;</span><br><span class="language-xquery">   <span class="hljs-built_in">name</span>: <span class="hljs-string">&#x27;hello&#x27;</span>,        </span><br><span class="language-xquery">   data()&#123;</span><br><span class="language-xquery">         <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-xquery">            <span class="hljs-built_in"> name</span>:<span class="hljs-string">&#x27;Tom&#x27;</span></span><br><span class="language-xquery">         &#125;</span><span class="language-xml"></span><br><span class="language-xml"> &#125;</span><br><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="注册组件"><a href="#注册组件" class="headerlink" title="注册组件"></a>注册组件</h3><h4 id="全局组件注册"><a href="#全局组件注册" class="headerlink" title="全局组件注册"></a>全局组件注册</h4><p>在<code>&lt;script&gt;</code>标签中直接使用 <code>Vue.component(componentName, component)</code> 方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//全局注册组件 hello</span></span><br><span class="language-javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;school&#x27;</span>, school)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="局部组件注册"><a href="#局部组件注册" class="headerlink" title="局部组件注册"></a>局部组件注册</h4><p>在需要使用的页面中，创建的<code>vue</code> 实例中，<code>component</code>项中注册</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">//创建vm</span></span><br><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#root&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;你好啊！&#x27;</span></span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-comment">//注册组件（局部注册）</span></span><br><span class="language-javascript">        <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">hello</span>: hello,</span><br><span class="language-javascript">            <span class="hljs-comment">// ES6简写形式</span></span><br><span class="language-javascript">            <span class="hljs-comment">// hello,</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>被全局注册的组件，可以在全局任何一个组件内使用</li><li>被局部注册的组件，只能在当前注册的范围内使用</li></ul><p><strong>应用场景</strong></p><ul><li>如果某些组件在开发期间的使用频率很高，推荐进行全局注册</li><li>如果某些组件只在特定的情况下会被用到，推荐进行局部注册</li></ul><h3 id="使用组件"><a href="#使用组件" class="headerlink" title="使用组件"></a>使用组件</h3><p>在页面注册组件后，使用 <code>&lt;组件名/&gt;</code> 或 <code>&lt;组件名&gt;&lt;组件名/&gt;</code> 的方式</p><h4 id="关于组件名"><a href="#关于组件名" class="headerlink" title="关于组件名"></a>关于组件名</h4><p>一个单词组成：</p><ul><li>第一种写法(首字母小写)：<code>school</code></li><li>第二种写法(首字母大写)：<code>School</code></li></ul><p>多个单词组成：</p><ul><li>第一种写法(kebab-case命名)：<code>my-school</code></li><li>第二种写法(CamelCase命名)：<code>MySchool</code> (需要Vue脚手架支持)</li></ul><blockquote><p> 备注：</p><p> (1).组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行。</p><p> (2).可以使用<code>name</code>配置项指定组件在开发者工具中呈现的名字。</p></blockquote><h4 id="关于组件标签"><a href="#关于组件标签" class="headerlink" title="关于组件标签"></a>关于组件标签</h4><p>第一种写法：<code>&lt;school&gt;&lt;/school&gt;</code></p><p>第二种写法：<code>&lt;school/&gt;</code></p><blockquote><p>备注：不用使用脚手架时，<code>&lt;school/&gt;</code>会导致后续组件不能渲染。</p></blockquote><h2 id="VueComponent"><a href="#VueComponent" class="headerlink" title="VueComponent"></a>VueComponent</h2><ul><li><code>hello</code>组件本质是一个名为<code>VueComponent</code>的构造函数，且不是程序员定义的，是<code>Vue.extend()</code>生成的。</li><li>我们只需要写<code>&lt;school/&gt;</code>或<code>&lt;school&gt;&lt;/school&gt;</code>，<code>Vue</code>解析时会帮我们创建<code>hello</code>组件的实例对象，即<code>Vue</code>帮我们执行的：<code>new VueComponent(options)</code>。</li><li>特别注意：**每次调用<code>Vue.extend</code>，返回的都是一个全新的<code>VueComponent</code>**！(这个<code>VueComponent</code>可不是实例对象)</li><li>关于<code>this</code>指向：<ul><li>组件配置中：<code>data</code>函数、<code>methods</code>中的函数、<code>watch</code>中的函数、<code>computed</code>中的函数 它们的<code>this</code>均是【<code>VueComponent</code>实例对象】。</li><li><code>new Vue(options)</code>配置中：<code>data</code>函数、<code>methods</code>中的函数、<code>watch</code>中的函数、<code>computed</code>中的函数 它们的<code>this</code>均是【<code>Vue</code>实例对象】。</li></ul></li><li><code>VueComponent</code>的实例对象，以后简称<code>vc</code>（也可称之为：组件实例对象）。<code>Vue</code>的实例对象，以后简称<code>vm</code>。</li></ul><h3 id="一个重要的内置关系"><a href="#一个重要的内置关系" class="headerlink" title="一个重要的内置关系"></a>一个重要的内置关系</h3><ul><li>一个重要的内置关系：<code>VueComponent.prototype.__proto__ === Vue.prototype</code></li><li>为什么要有这个关系：让组件实例对象（vc）可以访问到 Vue原型上的属性、方法。</li></ul><p><img src="/%5Cimages%5Cvue%5Cvue_%E7%BB%84%E4%BB%B6_%E4%B8%80%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E5%86%85%E7%BD%AE%E5%85%B3%E7%B3%BB.png" alt="vue_组件_一个重要的内置关系"></p><h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><ol><li><p>功能：让组件接收外部传过来的数据</p></li><li><p>传递数据：<code>&lt;Demo name=&quot;xxx&quot;/&gt;</code></p></li><li><p>接收数据：</p><ol><li><p>第一种方式（只接收）：<code>props:[&#39;name&#39;] </code></p></li><li><p>第二种方式（限制类型）：<code>props:&#123;name:String&#125;</code></p></li><li><p>第三种方式（限制类型、限制必要性、指定默认值）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">props</span>:&#123;<br><span class="hljs-attr">name</span>:&#123;<br>        <span class="hljs-attr">type</span>:<span class="hljs-title class_">String</span>, <span class="hljs-comment">//类型</span><br>        <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>, <span class="hljs-comment">//必要性</span><br>        <span class="hljs-attr">default</span>:<span class="hljs-string">&#x27;老王&#x27;</span> <span class="hljs-comment">//默认值</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>备注：<code>props</code>是只读的，Vue底层会监测你对<code>props</code>的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制<code>props</code>的内容到<code>data</code>中一份，然后去修改<code>data</code>中的数据。</p></blockquote></li></ol><p>子组件是无法直接使用父组件的 <code>data</code> 中的数据的，需要通过 <code>props</code> 属性才能够使用父组件传入过来的值</p><h3 id="向子组件传入数据"><a href="#向子组件传入数据" class="headerlink" title="向子组件传入数据"></a>向子组件传入数据</h3><p>在父组件的引用中填入属性名与对应的属性值,然后在子组件的 <code>props</code> 值填入与引用子组件的属性名一致的属性名，就可以在子组件中引用父组件的数据了，就如访问 <code>data</code> 中的值一样</p><p>父组件 <code>App.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div id=&quot;app&quot;&gt;<br>        // 向子组件传入 &#123;name:&#x27;haha&#x27;, age:this.age&#125;<br>        &lt;School name=&quot;haha&quot; :age=&quot;this.age&quot;&gt;&lt;/School&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br>  <br>  &lt;script&gt;<br>    import School from &#x27;./components/School.vue&#x27;<br><br>    export default &#123;<br>        name: &#x27;App&#x27;,<br>        data() &#123;<br>            return &#123;<br>                age: 360,<br>            &#125;<br>        &#125;,<br>        components: &#123;<br>            School,<br>        &#125;,<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>子组件 <code>School.vue</code></p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学校名称：</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">name</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学校年龄：</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">age</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学校地址：</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">address</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;School&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 最简单的写法：props: [&#x27;name&#x27;, &#x27;age&#x27;]</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">props</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">name</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 必须要传的</span></span></span><br><span class="language-javascript"><span class="language-xml">            &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">age</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-attr">address</span>: <span class="hljs-string">&#x27;北京昌平&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li>**一个组件默认可以拥有任意数量的 <code>prop</code>**，任何值都可以传递给任何 <code>prop</code>，但是为了方便可以传入一个对象,调用对象的属性来使用传入的数据</li><li>组件中的所有 <code>props</code> 中的数据都是通过父组件传递给子组件的，**不要试图去修改 <code>props</code> 中传入的数据,**一般都是只读的，如果修改 Vue 会抛出报错信息</li><li><strong>可以通过 <code>v-bind</code> 动态传递给 <code>prop</code> 一个值</strong></li><li>子组件的 <code>data</code> 数据并不是通过父组件传递过来的,而是子组件自身私有的，比如子组件通过 <code>Ajax</code> 请求回来的数据都可以放在 <code>data</code> 身上，子组件的 <code>data</code> 上的数据都是可读可写的</li></ul><h3 id="Prop-的大小写"><a href="#Prop-的大小写" class="headerlink" title="Prop 的大小写"></a>Prop 的大小写</h3><p>HTML 中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当使用 DOM 中的模板时，<strong>驼峰命名法的 <code>prop</code> 名需要使用其等价的短横线分隔命名</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">post-title</span>=<span class="hljs-string">&quot;hello!&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span><br><span class="language-xml"><span class="language-handlebars">    Vue.component(&#x27;blog-post&#x27;, &#123;</span></span><br><span class="language-xml"><span class="language-handlebars">        props: [&#x27;postTitle&#x27;],</span></span><br><span class="language-xml"><span class="language-handlebars">        template: &#x27;<span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">postTitle</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>&#x27;,</span></span><br><span class="language-xml"><span class="language-handlebars">    &#125;)</span></span><br><span class="language-xml"><span class="language-handlebars"></span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Prop-类型"><a href="#Prop-类型" class="headerlink" title="Prop 类型"></a>Prop 类型</h3><p>如果希望传入的 <code>prop</code> 都有指令的值类型,可以用对象的方式来，可以以对象形式列出 <code>prop</code>，这些属性的名称和值分别是 <code>prop</code> 各自的名称和类型。除此之外，还可以用于配置其他高级选项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//数组形式</span><br><span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;likes&#x27;</span>, <span class="hljs-string">&#x27;isPublished&#x27;</span>, <span class="hljs-string">&#x27;commentIds&#x27;</span>, <span class="hljs-string">&#x27;author&#x27;</span>]<br><span class="hljs-comment">//对象形式</span><br><span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">likes</span>: <span class="hljs-title class_">Number</span>,<br>    <span class="hljs-attr">isPublished</span>: <span class="hljs-title class_">Boolean</span>,<br>    <span class="hljs-attr">commentIds</span>: <span class="hljs-title class_">Array</span>,<br>    <span class="hljs-attr">author</span>: <span class="hljs-title class_">Object</span>,<br>&#125;<br><span class="hljs-comment">// 简单语法</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;props-demo-simple&#x27;</span>, &#123;<br>    <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;size&#x27;</span>, <span class="hljs-string">&#x27;myMessage&#x27;</span>],<br>&#125;)<br><br><span class="hljs-comment">// 对象语法，提供校验</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;props-demo-advanced&#x27;</span>, &#123;<br>    <span class="hljs-attr">props</span>: &#123;<br>        <span class="hljs-comment">// 检测类型</span><br>        <span class="hljs-attr">height</span>: <span class="hljs-title class_">Number</span>,<br>        <span class="hljs-comment">// 检测类型 + 其他验证</span><br>        <span class="hljs-attr">age</span>: &#123;<br>            <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br>            <span class="hljs-attr">default</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">//设置默认值</span><br>            <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//是否必须</span><br>            <span class="hljs-attr">validator</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>                <span class="hljs-comment">//对值进行验证</span><br>                <span class="hljs-keyword">return</span> value &gt;= <span class="hljs-number">0</span><br>            &#125;,<br>        &#125;,<br>    &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="动态传递-Prop"><a href="#动态传递-Prop" class="headerlink" title="动态传递 Prop"></a>动态传递 Prop</h3><p>可以通过 <code>v-bind</code> 的方式动态传递一个变量值给一个 <code>prop</code>，通过 <code>name=&quot;xxx&quot;</code>的方式，会将 <code>xxx</code> 解析为字符串，因此应用 <code>v-bind</code>方式传入一个 js 表达式</p><ul><li>传入一个数字</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span><br><span class="hljs-comment">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind:likes</span>=<span class="hljs-string">&quot;42&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 用一个变量进行动态赋值。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind:likes</span>=<span class="hljs-string">&quot;post.likes&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>传入一个布尔值</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 包含该 prop 没有值的情况在内，都意味着 `true`。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">is-published</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 即便 `false` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span><br><span class="hljs-comment">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind:is-published</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 用一个变量进行动态赋值。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind:is-published</span>=<span class="hljs-string">&quot;post.isPublished&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>传入一个数组</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 即便数组是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span><br><span class="hljs-comment">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind:comment-ids</span>=<span class="hljs-string">&quot;[234, 266, 273]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 用一个变量进行动态赋值。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind:comment-ids</span>=<span class="hljs-string">&quot;post.commentIds&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>传入一个对象</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 即便对象是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span><br><span class="hljs-comment">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span></span><br><span class="hljs-tag">  <span class="hljs-attr">v-bind:author</span>=<span class="hljs-string">&quot;&#123;</span></span><br><span class="hljs-string"><span class="hljs-tag">    name: &#x27;Veronica&#x27;,</span></span><br><span class="hljs-string"><span class="hljs-tag">    company: &#x27;Veridian Dynamics&#x27;</span></span><br><span class="hljs-string"><span class="hljs-tag">  &#125;&quot;</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 用一个变量进行动态赋值。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind:author</span>=<span class="hljs-string">&quot;post.author&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>传入一个对象的所有属性</li></ul><p>如果想要将一个对象的所有属性都作为 prop 传入，你可以使用不带参数的 <code>v-bind</code>(取代 <code>v-bind:prop-name</code>)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">post</span>: &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;My Journey with Vue&#x27;</span><br>&#125;<br>&lt;blog-post v-bind=<span class="hljs-string">&quot;post&quot;</span>&gt;&lt;/blog-post&gt;<br><br>&lt;!--与下面的方法等价--&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">&quot;post.id&quot;</span>  <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">&quot;post.title&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="ref-属性"><a href="#ref-属性" class="headerlink" title="$ref 属性"></a>$ref 属性</h2><ul><li>被用来给元素或子组件注册引用信息（<code>id</code>的替代者），通过这个引用的 ID,父组件可以直接通过<code>this.$refs</code>访问这个组件或子元素</li><li>应用在<code>html</code>标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</li><li>使用方式：<ul><li>打标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;&lt;/h1&gt;</code>或 <code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></li><li>获取：<code>this.$refs.xxx</code></li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;获取元素内容&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;getElement&quot;</span> /&gt;</span><br>        <span class="hljs-comment">&lt;!-- 使用 ref 获取元素 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;myh1&quot;</span>&gt;</span>这是一个大大的H1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span><br>        <span class="hljs-comment">&lt;!-- 使用 ref 获取子组件 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">my-com</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;mycom&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-com</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;my-com&#x27;</span>, &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;h5&gt;这是一个子组件&lt;/h5&gt;&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">                <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;子组件&#x27;</span>,</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 创建 Vue 实例，得到 ViewModel</span></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">data</span>: &#123;&#125;,</span><br><span class="language-javascript">        <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">            <span class="hljs-title function_">getElement</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-comment">// 通过 this.$refs 来获取元素</span></span><br><span class="language-javascript">                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">myh1</span>.<span class="hljs-property">innerText</span>) <span class="hljs-comment">// 这是一个大大的H1</span></span><br><span class="language-javascript">                <span class="hljs-comment">// 通过 this.$refs 来获取组件</span></span><br><span class="language-javascript">                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">mycom</span>.<span class="hljs-property">name</span>) <span class="hljs-comment">// 子组件</span></span><br><span class="language-javascript">            &#125;,</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>过渡与动画</title>
    <link href="/2022/10/05/vue/%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB/"/>
    <url>/2022/10/05/vue/%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="过渡与动画"><a href="#过渡与动画" class="headerlink" title="过渡与动画"></a>过渡与动画</h1><p><strong>Vue 中可以通过<code>transition</code>组件来实现过渡效果 Vue 在插入,更新或者移除 DOM 时,提供多种不同方式的应用过渡效果</strong></p><ul><li>在 CSS 过渡和动画中自动应用 class</li><li>可以配合使用第三方 CSS 动画库，如 Animate.css</li><li>在过渡钩子函数中使用 JavaScript 直接操作 DOM</li><li>可以配合使用第三方 JavaScript 动画库，如 Velocity.js</li></ul><span id="more"></span><h2 id="过渡的类名"><a href="#过渡的类名" class="headerlink" title="过渡的类名"></a>过渡的类名</h2><h3 id="自身实现的类名"><a href="#自身实现的类名" class="headerlink" title="自身实现的类名"></a>自身实现的类名</h3><p><strong>这些类名是 transition 组件中自定好的,在使用的时候只需要在 CSS 中写入特定的类名和样式就可以了</strong></p><ul><li><code>v-enter</code>：定义进入过渡的开始状态。在元素被插入之前生效，此时元素还没有进入过渡，在元素被插入之后的下一帧移除</li><li><code>v-enter-active</code>：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡&#x2F;动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数</li><li><code>v-enter-to</code>: 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 <code>v-enter</code> 被移除)，在过渡&#x2F;动画完成之后移除</li><li><code>v-leave</code>: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除</li><li><code>v-leave-active</code>：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡&#x2F;动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数</li><li><code>v-leave-to</code>:定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 <code>v-leave</code> 被删除)，在过渡&#x2F;动画完成之后移除</li></ul><p><strong>注:</strong></p><ul><li><strong>一般都是使用 <code>v-enter</code>,<code>v-leave-to</code> 与 <code>v-enter-active</code> 和 <code>v-leave-active</code> 的组合</strong></li><li>对于这些在过渡中切换的类名来说,如果使用一个没有名字的 <code>&lt;transition&gt;</code>,则 <code>v-</code> 是这些类名的默认前缀,如果使用了 <code>&lt;transition name=&quot;my-transition&quot;&gt;</code>,那么 <code>v-enter</code> 会替换为 <code>my-transition-enter</code>,通过这个可以绑定:<code>name</code> 实现动态过渡的效果</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">// 动画进入，离开的样式</span><br><span class="language-css">    <span class="hljs-selector-class">.fade-enter-active</span>,</span><br><span class="language-css">    <span class="hljs-selector-class">.fade-leave-active</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">0.5s</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    // 动画进入的起点，动画离开的终点</span><br><span class="language-css">    <span class="hljs-selector-class">.fade-enter</span>,</span><br><span class="language-css">    <span class="hljs-selector-class">.fade-leave-to</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;show = !show&quot;</span>&gt;</span>Toggle<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fade&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#demo&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">show</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>动画效果同过渡效果，只是在动画中 <code>v-enter</code> 这个类名在插入 DOM 中后不会立刻被删除，而是在<code>animationend</code>事件触发时才会被删除</p><h3 id="自定义过渡的类名"><a href="#自定义过渡的类名" class="headerlink" title="自定义过渡的类名"></a>自定义过渡的类名</h3><p><strong>可以通过引入第三方库实现过渡效果,这时需要使用自定义过渡的类名来加第三方库的过渡效果使用</strong></p><p>可以通过以下特性来自定义过渡类名,这些类名分别也对应着上方的执行时期,它们的优先级高于普通的类名</p><ul><li><code>enter-class</code></li><li><code>enter-active-class</code></li><li><code>enter-to-class</code></li><li><code>leave-class</code></li><li><code>leave-active-class</code></li><li><code>leave-to-class</code></li></ul><p><strong>在这些自定义的属性中可以写入要引入的第三方库的 CSS 样式就能实现效果</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">link</span></span><br><span class="hljs-tag">    <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/animate.css@3.5.1&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span></span><br><span class="hljs-tag">/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;show = !show&quot;</span>&gt;</span>Toggle render<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">transition</span></span><br><span class="hljs-tag">        <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;custom-classes-transition&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">enter-active-class</span>=<span class="hljs-string">&quot;animated tada&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">leave-active-class</span>=<span class="hljs-string">&quot;animated bounceOutRight&quot;</span></span><br><span class="hljs-tag">    &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#example&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">show</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>过渡与动画<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">            <span class="hljs-selector-class">.fade1-enter</span>,</span><br><span class="language-css">            <span class="hljs-selector-class">.fade1-leave-to</span> &#123;</span><br><span class="language-css">                <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">            &#125;</span><br><span class="language-css">            <span class="hljs-selector-class">.fade1-enter-active</span>,</span><br><span class="language-css">            <span class="hljs-selector-class">.fade1-leave-active</span> &#123;</span><br><span class="language-css">                <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">1s</span>;</span><br><span class="language-css">            &#125;</span><br><span class="language-css">            <span class="hljs-selector-class">.fade2-enter</span> &#123;</span><br><span class="language-css">                <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">                <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">20px</span>);</span><br><span class="language-css">            &#125;</span><br><span class="language-css">            <span class="hljs-selector-class">.fade2-leave-to</span> &#123;</span><br><span class="language-css">                <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">                <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">20px</span>);</span><br><span class="language-css">            &#125;</span><br><span class="language-css">            <span class="hljs-selector-class">.fade2-enter-active</span>,</span><br><span class="language-css">            <span class="hljs-selector-class">.fade2-leave-active</span> &#123;</span><br><span class="language-css">                <span class="hljs-attribute">transition</span>: all <span class="hljs-number">3s</span>;</span><br><span class="language-css">            &#125;</span><br><span class="language-css">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        1. vue动画的理解</span><br><span class="hljs-comment">            操作css的transition或animation</span><br><span class="hljs-comment">            vue会给目标元素添加/移除特定的class</span><br><span class="hljs-comment">        2. 基本过渡动画的编码</span><br><span class="hljs-comment">            1). 在目标元素外包裹&lt;transition name=&quot;xxx&quot;&gt;</span><br><span class="hljs-comment">            2). 定义class样式</span><br><span class="hljs-comment">                1&gt;. 指定过渡样式: transition</span><br><span class="hljs-comment">                2&gt;. 指定隐藏时的样式: opacity/其它</span><br><span class="hljs-comment">        3. 过渡的类名</span><br><span class="hljs-comment">            xxx-enter-active: 指定显示的transition</span><br><span class="hljs-comment">            xxx-leave-active: 指定隐藏的transition</span><br><span class="hljs-comment">            xxx-enter: 指定隐藏时的样式</span><br><span class="hljs-comment">    --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app1&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;isShow = !isShow&quot;</span>&gt;</span>Destroy<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fade1&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isShow&quot;</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app2&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;isShow = !isShow&quot;</span>&gt;</span>Destroy<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fade2&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isShow&quot;</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">                <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app1&#x27;</span>,</span><br><span class="language-javascript">                <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">                        <span class="hljs-attr">isShow</span>: <span class="hljs-string">&#x27;false&#x27;</span>,</span><br><span class="language-javascript">                    &#125;</span><br><span class="language-javascript">                &#125;,</span><br><span class="language-javascript">            &#125;)</span><br><span class="language-javascript">            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">                <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app2&#x27;</span>,</span><br><span class="language-javascript">                <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">                        <span class="hljs-attr">isShow</span>: <span class="hljs-string">&#x27;false&#x27;</span>,</span><br><span class="language-javascript">                    &#125;</span><br><span class="language-javascript">                &#125;,</span><br><span class="language-javascript">            &#125;)</span><br><span class="language-javascript">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="初始渲染过渡"><a href="#初始渲染过渡" class="headerlink" title="初始渲染过渡"></a>初始渲染过渡</h2><p><strong>为<code>transition</code>组件添加一个简单的属性 appear 就能够实现在刚开始渲染的时候就使用一次<code>enter-active-class</code>来实现开始渲染列表的过渡效果</strong></p><p><strong>初始渲染时也可以使用自定义的 CSS 类名进行初始渲染</strong></p><ul><li><code>appear-class</code> </li><li><code>appear-active-class</code></li><li><code>appear-to-class</code></li></ul><p><strong>注意</strong>:使用自定义类名进行渲染时也需要添加 appear 属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span></span><br><span class="hljs-tag">    <span class="hljs-attr">appear</span></span><br><span class="hljs-tag">    <span class="hljs-attr">appear-class</span>=<span class="hljs-string">&quot;custom-appear-class&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">appear-to-class</span>=<span class="hljs-string">&quot;custom-appear-to-class&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">appear-active-class</span>=<span class="hljs-string">&quot;custom-appear-active-class&quot;</span></span><br><span class="hljs-tag">&gt;</span><br>    <span class="hljs-comment">&lt;!-- ... --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--当然也可以使用JS的钩子函数--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">transition</span></span><br><span class="hljs-tag">    <span class="hljs-attr">appear</span></span><br><span class="hljs-tag">    <span class="hljs-attr">v-on:before-appear</span>=<span class="hljs-string">&quot;customBeforeAppearHook&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">v-on:appear</span>=<span class="hljs-string">&quot;customAppearHook&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">v-on:after-appear</span>=<span class="hljs-string">&quot;customAfterAppearHook&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">v-on:appear-cancelled</span>=<span class="hljs-string">&quot;customAppearCancelledHook&quot;</span></span><br><span class="hljs-tag">&gt;</span><br>    <span class="hljs-comment">&lt;!-- ... --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="显性定义过渡时间"><a href="#显性定义过渡时间" class="headerlink" title="显性定义过渡时间"></a>显性定义过渡时间</h2><p><strong>默认情况下，Vue 会等待其在过渡效果的根元素的第一个 <code>transitionend</code> 或 <code>animationend</code> 事件</strong>。然而也可以不这样设定——比如，我们可以拥有一个精心编排的一系列过渡效果，其中一些嵌套的内部元素相比于过渡效果的根元素有延迟的或更长的过渡效果。</p><p>在这种情况下，<strong>可以用 <code>&lt;transition&gt;</code> 组件上的绑定的 <code>duration</code> 属性定制一个显性的过渡持续时间 (以毫秒为单位)</strong> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">:duration</span>=<span class="hljs-string">&quot;1000&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>可以传入一个对象分别对移入和移除的时间进行设置</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">:duration</span>=<span class="hljs-string">&quot;&#123; enter: 500, leave: 800 &#125;&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="JS-钩子"><a href="#JS-钩子" class="headerlink" title="JS 钩子"></a>JS 钩子</h2><p><strong>除了通过 CSS 实现过渡效果，还可以用 JS 中的钩子函数实现过渡效果</strong>，这些钩子可以结合 CSS 使用，也可以全部单独使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs html">    <span class="hljs-tag">&lt;<span class="hljs-name">transition</span></span><br><span class="hljs-tag">        <span class="hljs-attr">v-on:before-enter</span>=<span class="hljs-string">&quot;beforeEnter&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">v-on:enter</span>=<span class="hljs-string">&quot;enter&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">v-on:after-enter</span>=<span class="hljs-string">&quot;afterEnter&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">v-on:enter-cancelled</span>=<span class="hljs-string">&quot;enterCancelled&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">v-on:before-leave</span>=<span class="hljs-string">&quot;beforeLeave&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">v-on:leave</span>=<span class="hljs-string">&quot;leave&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">v-on:after-leave</span>=<span class="hljs-string">&quot;afterLeave&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">v-on:leave-cancelled</span>=<span class="hljs-string">&quot;leaveCancelled&quot;</span></span><br><span class="hljs-tag">    &gt;</span><br>        <span class="hljs-comment">&lt;!-- ... --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br>// ----<br>methods :&#123;<br>    // --------<br>    // 进入中<br>    // --------<br>    beforeEnter: function (el) &#123;<br>        // ...<br>    &#125;,<br>    // 当与 CSS 结合使用时<br>    // 回调函数 done 是可选的 enter:<br>    enter: function(el, done) &#123;<br>        // ...<br>        el.offsetWidth<br>        //玄学操作,不加这个设置全JS样式时,动画不会有过渡效果出现,可以认为是这个操作会强制动画刷新<br>        done()<br>        //done()所代表的函数就是下一个结束afterEnter的函数,只有调用了这个回调函数才会执行下面的方法<br>    &#125;,<br>    afterEnter: function (el) &#123;<br>        // ...<br>    &#125;,<br>    enterCancelled: function (el) &#123;<br>        // ...<br>    &#125;,<br>    // --------<br>    // 离开时<br>    // --------<br>    beforeLeave: function (el) &#123;<br>        // ...<br>    &#125;,<br>    // 当与 CSS 结合使用时<br>    // 回调函数 done 是可选的 leave:<br>    function(el, done) &#123;<br>        //  ...<br>        done()<br>    &#125;,<br>    afterLeave: function (el) &#123;<br>        // ...<br>    &#125;,<br>    // leaveCancelled 只用于  v-show 中<br>    leaveCancelled: function (el) &#123;<br>        // ...<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li>推荐对于仅使用 JavaScript 过渡的元素添加 <code>v-bind:css=&quot;false&quot;</code>，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响</li><li>当只用 JavaScript 过渡的时候，<strong>在 <code>enter</code> 和 <code>leave</code> 中必须使用 <code>done</code> 进行回调</strong>。否则，它们将被同步调用，过渡会立即完成。</li></ul><h2 id="多个元素过渡"><a href="#多个元素过渡" class="headerlink" title="多个元素过渡"></a>多个元素过渡</h2><p>对于原生标签可以使用 <code>v-if</code>和<code>v-else</code> 来实现多标签过渡效果</p><p><strong>注意</strong>:当有相同标签名的元素切换时，需要通过 <code>key</code> 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isEditing&quot;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;save&quot;</span>&gt;</span>Save<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-else</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;edit&quot;</span>&gt;</span>Edit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br><span class="hljs-comment">&lt;!--也可以也可以通过给同一个元素的 key 特性设置不同的状态来代替 v-if 和 v-else--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">transition</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">&quot;isEditing&quot;</span>&gt;</span><br>        &#123;&#123; isEditing ? &#x27;Save&#x27; : &#x27;Edit&#x27; &#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>过渡模式</strong></p><p><strong>通过 mode 属性来定义多个元素过渡时的过渡模式</strong></p><ul><li><strong>in-out</strong>：新元素先进行过渡，完成之后当前元素过渡离开</li><li><strong>out-in</strong>：当前元素先进行过渡，完成之后新元素过渡进入</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;out-in&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="列表过渡"><a href="#列表过渡" class="headerlink" title="列表过渡"></a>列表过渡</h2><p><strong>渲染一整个列表时,如用 <code>v-for</code> 来渲染,就需要使用<code>&lt; transition-group&gt;</code> 组件</strong>、</p><p><strong>注意:</strong></p><ul><li>不同于 <code>&lt; transition&gt;</code>组件，<code>&lt; transition-group&gt;</code>组件会以一个真实元素呈现,默认为一个 <code>&lt;span&gt;</code>标签,可以通过 tag 特性更换为其他元素 **如:**内部是 <code>li</code> 列表,那么可以用<code>&lt;transition-grounp tag=&quot;ul&quot;&gt;</code>来让该组件被渲染时表现为 <code>ul</code></li><li>过渡模式不可用，因为不再相互切换特有的元素</li><li>内部元素必须要有提供唯一的 <code>key</code> 属性值</li></ul><h3 id="添加与删除列表"><a href="#添加与删除列表" class="headerlink" title="添加与删除列表"></a>添加与删除列表</h3><p><strong>通过对一个<code>transiton-grounp</code>用过渡的类名和实现当个成员在过渡时的效果</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.list-item</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">display</span>: inline-block;</span><br><span class="language-css">        <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.list-enter-active</span>,</span><br><span class="language-css">    <span class="hljs-selector-class">.list-leave-active</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.list-enter</span>, <span class="hljs-selector-class">.list-leave-to</span></span><br><span class="language-css">    <span class="hljs-comment">/* .list-leave-active for below version 2.1.8 */</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">30px</span>);</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list-demo&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>Add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;remove&quot;</span>&gt;</span>Remove<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">transition-group</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">&quot;p&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-item&quot;</span>&gt;</span><br>            &#123;&#123; item &#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">transition-group</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#list-demo&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">items</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>],</span><br><span class="language-javascript">            <span class="hljs-attr">nextNum</span>: <span class="hljs-number">10</span>,</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">randomIndex</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span>)</span><br><span class="language-javascript">            &#125;,</span><br><span class="language-javascript">            <span class="hljs-attr">add</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">splice</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">randomIndex</span>(), <span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">nextNum</span>++)</span><br><span class="language-javascript">            &#125;,</span><br><span class="language-javascript">            <span class="hljs-attr">remove</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">splice</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">randomIndex</span>(), <span class="hljs-number">1</span>)</span><br><span class="language-javascript">            &#125;,</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="排序过渡列表"><a href="#排序过渡列表" class="headerlink" title="排序过渡列表"></a>排序过渡列表</h3><p><strong>上方的添加与删除列表只会对进行操作的成员自身产生过渡效果，对组件中的其他成员没有过渡效果,如果要想通过过渡效果进行添加,需要使用 <code>v-move</code> 的类名写入 CSS 样式</strong>，该效果会在组件的成员改变其定位的时候起作用，所以要想起过渡效果还需要在过渡时将元素的定位改变为绝对定位，也可以通过 <code>name</code> 属性来自定义前缀，也能通过 <code>move-class</code> 属性 CSS 效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.flip-list-move</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">1s</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;flip-list-demo&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;shuffle&quot;</span>&gt;</span>Shuffle<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">transition-group</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;flip-list&quot;</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">&quot;ul&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">transition-group</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#flip-list-demo&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">items</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>],</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">shuffle</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = _.<span class="hljs-title function_">shuffle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>)</span><br><span class="language-javascript">            &#125;,</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="交错过渡列表"><a href="#交错过渡列表" class="headerlink" title="交错过渡列表"></a>交错过渡列表</h3><p><strong>通过 JS 钩子来实现列表的过渡效果,使 <code>data</code> 属性与 JS 进行数据通信,就可以实现列表的交错过渡效果</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;staggered-list-demo&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;query&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">transition-group</span></span><br><span class="hljs-tag">        <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;staggered-fade&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">tag</span>=<span class="hljs-string">&quot;ul&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">v-bind:css</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">v-on:before-enter</span>=<span class="hljs-string">&quot;beforeEnter&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">v-on:enter</span>=<span class="hljs-string">&quot;enter&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">v-on:leave</span>=<span class="hljs-string">&quot;leave&quot;</span></span><br><span class="hljs-tag">    &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span></span><br><span class="hljs-tag">            <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in computedList&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">&quot;item.msg&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">v-bind:data-index</span>=<span class="hljs-string">&quot;index&quot;</span></span><br><span class="hljs-tag">        &gt;</span><br>            &#123;&#123; item.msg &#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">transition-group</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#staggered-list-demo&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">query</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">list</span>: [</span><br><span class="language-javascript">                &#123; <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;Bruce Lee&#x27;</span> &#125;,</span><br><span class="language-javascript">                &#123; <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;Jackie Chan&#x27;</span> &#125;,</span><br><span class="language-javascript">                &#123; <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;Chuck Norris&#x27;</span> &#125;,</span><br><span class="language-javascript">                &#123; <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;Jet Li&#x27;</span> &#125;,</span><br><span class="language-javascript">                &#123; <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;Kung Fury&#x27;</span> &#125;,</span><br><span class="language-javascript">            ],</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-attr">computed</span>: &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">computedList</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">var</span> vm = <span class="hljs-variable language_">this</span></span><br><span class="language-javascript">                <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) &#123;</span><br><span class="language-javascript">                    <span class="hljs-keyword">return</span> (</span><br><span class="language-javascript">                        item.<span class="hljs-property">msg</span></span><br><span class="language-javascript">                            .<span class="hljs-title function_">toLowerCase</span>()</span><br><span class="language-javascript">                            .<span class="hljs-title function_">indexOf</span>(vm.<span class="hljs-property">query</span>.<span class="hljs-title function_">toLowerCase</span>()) !== -<span class="hljs-number">1</span></span><br><span class="language-javascript">                    )</span><br><span class="language-javascript">                &#125;)</span><br><span class="language-javascript">            &#125;,</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">beforeEnter</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) &#123;</span><br><span class="language-javascript">                el.<span class="hljs-property">style</span>.<span class="hljs-property">opacity</span> = <span class="hljs-number">0</span></span><br><span class="language-javascript">                el.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-number">0</span></span><br><span class="language-javascript">            &#125;,</span><br><span class="language-javascript">            <span class="hljs-attr">enter</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el, done</span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">var</span> delay = el.<span class="hljs-property">dataset</span>.<span class="hljs-property">index</span> * <span class="hljs-number">150</span></span><br><span class="language-javascript">                <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                    <span class="hljs-title class_">Velocity</span>(</span><br><span class="language-javascript">                        el,</span><br><span class="language-javascript">                        &#123; <span class="hljs-attr">opacity</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">height</span>: <span class="hljs-string">&#x27;1.6em&#x27;</span> &#125;,</span><br><span class="language-javascript">                        &#123; <span class="hljs-attr">complete</span>: done &#125;</span><br><span class="language-javascript">                    )</span><br><span class="language-javascript">                &#125;, delay)</span><br><span class="language-javascript">            &#125;,</span><br><span class="language-javascript">            <span class="hljs-attr">leave</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el, done</span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">var</span> delay = el.<span class="hljs-property">dataset</span>.<span class="hljs-property">index</span> * <span class="hljs-number">150</span></span><br><span class="language-javascript">                <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                    <span class="hljs-title class_">Velocity</span>(</span><br><span class="language-javascript">                        el,</span><br><span class="language-javascript">                        &#123; <span class="hljs-attr">opacity</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">0</span> &#125;,</span><br><span class="language-javascript">                        &#123; <span class="hljs-attr">complete</span>: done &#125;</span><br><span class="language-javascript">                    )</span><br><span class="language-javascript">                &#125;, delay)</span><br><span class="language-javascript">            &#125;,</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise</title>
    <link href="/2022/10/03/ES6/Promise/"/>
    <url>/2022/10/03/ES6/Promise/</url>
    
    <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="Promise-是什么"><a href="#Promise-是什么" class="headerlink" title="Promise 是什么"></a>Promise 是什么</h2><h3 id="理解-Promise"><a href="#理解-Promise" class="headerlink" title="理解 Promise"></a>理解 Promise</h3><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 </p><p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件(通常是一个异步操作)的结果。</p><ul><li>从语法上看：<code>Promise</code>是一个构造函数 (自己身上有<code>all</code>、<code>reject</code>、<code>resolve</code>这几个方法，原型上有<code>then</code>、<code>catch</code>等方法)</li><li>功能上看：<code>promise</code>对象用来封装一个异步操作并可以获取其成功&#x2F;失败的结果值</li></ul><span id="more"></span><h3 id="Promise-的三种状态"><a href="#Promise-的三种状态" class="headerlink" title="Promise 的三种状态"></a>Promise 的三种状态</h3><p>实例对象promise中的一个属性 <code>PromiseState</code>，用于存放 <code>Promise</code> 的三种状态 <code>pending</code> <code>resolved/fullfilled</code> <code>rejected</code></p><ol><li><code>pending</code> 变为 <code>resolved</code>&#x2F;<code>fullfilled</code></li><li><code>pending</code> 变为 <code>rejected</code></li></ol><p>注：</p><ul><li>对象的状态不受外界影响</li><li>只有这两种，且一个 <code>promise</code> 对象只能改变一次</li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果</li><li>无论成功还是失败，都会有一个结果数据。成功的结果数据一般称为 <code>value</code>，而失败的一般称为 <code>reason</code>。</li></ul><h3 id="Promise对象的值"><a href="#Promise对象的值" class="headerlink" title="Promise对象的值"></a>Promise对象的值</h3><p>实例对象<code>promise</code>的另一个值 <code>PromiseResult</code><br>保存着对象 成功&#x2F;失败 的值（<code>value</code>&#x2F;<code>reason</code>）</p><h3 id="Promise-的基本使用"><a href="#Promise-的基本使用" class="headerlink" title="Promise 的基本使用"></a>Promise 的基本使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-comment">// ... some code</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 异步操作成功 */</span> ) &#123;<br>        <span class="hljs-title function_">resolve</span>(value)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">reject</span>(reason)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p><code>Promise</code>构造函数接受<strong>一个函数</strong>（执行器函数）作为参数，该函数的<strong>两个参数</strong>分别是<code>resolve</code>和<code>reject</code>。它们是<strong>两个函数</strong>，由 JavaScript 引擎提供，不用自己部署。</p><p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 <code>pending</code> 变为 <code>resolved</code>），在<strong>异步操作成功</strong>时调用，并将异步操作的结果，作为参数<code>value</code>传递出去；<br><code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 <code>pending</code> 变为 <code>rejected</code>），在<strong>异步操作失败</strong>时调用，并将异步操作报出的错误，作为参数<code>error</code>&#x2F;<code>reason</code>传递出去。</p><p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">then</span>(<br>    <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-comment">// success</span><br>    &#125;,<br>    <span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) &#123;<br>        <span class="hljs-comment">// failure</span><br>    &#125;<br>)<br></code></pre></td></tr></table></figure><p><code>then</code>方法可以接受<strong>两个回调函数</strong>作为参数。</p><ul><li>第一个回调函数<code>onResolved()</code>是<code>Promise</code>对象的状态变为<code>resolved</code>时调用</li><li>第二个回调函数<code>onRejected()</code>是<code>Promise</code>对象的状态变为<code>rejected</code>时调用</li><li>这两个函数都是可选的，不一定要提供。它们都接受<code>Promise</code>对象传出的值作为参数</li></ul><p>例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 创建一个新的p对象promise</span><br>const p = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 执行器函数</span><br>    <span class="hljs-comment">// 执行异步操作任务</span><br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        const <span class="hljs-built_in">time</span> = <span class="hljs-built_in">Date</span>.<span class="hljs-built_in">now</span>()<br>        <span class="hljs-comment">// 如果当前时间是偶数代表成功，否则失败</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">time</span> % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 如果成功，调用resolve(value)</span><br>            resolve(<span class="hljs-string">&#x27;成功的数据，time=&#x27;</span> + <span class="hljs-built_in">time</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果失败，调用reject(reason)</span><br>            reject(<span class="hljs-string">&#x27;失败的数据，time=&#x27;</span> + <span class="hljs-built_in">time</span>)<br>        &#125;<br>    &#125;, <span class="hljs-number">1000</span>)<br>&#125;)<br><br>p.then(<br>    <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 接收得到成功的value数据 onResolved</span><br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;成功的回调&#x27;</span>, value) <span class="hljs-comment">// 成功的回调 成功的数据，time=1615015043258</span><br>    &#125;,<br>    (reason) =&gt; &#123;<br>        <span class="hljs-comment">// 接收得到失败的reason数据 onRejected</span><br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;失败的回调&#x27;</span>, reason) <span class="hljs-comment">// 失败的回调 失败的数据，time=1615014995315</span><br>    &#125;<br>)<br><br></code></pre></td></tr></table></figure><blockquote><p>.then() 和执行器(executor)同步执行，.then() 中的回调函数异步执行</p></blockquote><h2 id="为什么要使用-Promise"><a href="#为什么要使用-Promise" class="headerlink" title="为什么要使用 Promise"></a>为什么要使用 Promise</h2><h3 id="指定回调函数的方式更加灵活"><a href="#指定回调函数的方式更加灵活" class="headerlink" title="指定回调函数的方式更加灵活"></a>指定回调函数的方式更加灵活</h3><p>ES5：必须在启动异步任务前指定</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 1. 纯回调的形式</span><br><span class="hljs-comment">// 成功的回调函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">successCallback</span>(<span class="hljs-params">result</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;声音文件创建成功：&#x27;</span> + result)<br>&#125;<br><span class="hljs-comment">// 失败的回调函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">failureCallback</span>(<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;声音文件创建失败：&#x27;</span> + error)<br>&#125;<br><span class="hljs-comment">// 必须先指定回调函数，再执行异步任务</span><br>createAudioFileAsync(audioSettings, successCallback, failureCallback) <br><span class="hljs-comment">// 回调函数在执行异步任务（函数）前就要指定</span><br><br></code></pre></td></tr></table></figure><p>promise：启动异步任务 &#x3D;&gt; 返回promise对象 &#x3D;&gt; 给promise对象绑定回调函数(甚至可以在异步任务结束后指定)</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 2. 使用Promise</span><br>const promise = <span class="hljs-built_in">createAudioFileAsync</span>(audioSettings) <span class="hljs-comment">// 执行2秒</span><br><span class="hljs-function"><span class="hljs-title">setTimeout</span><span class="hljs-params">(()</span></span> =&gt; &#123;<br>  promise<span class="hljs-selector-class">.then</span>(successCallback, failureCallback) <span class="hljs-comment">// 也可以获取</span><br>&#125;, <span class="hljs-number">3000</span>)<br></code></pre></td></tr></table></figure><h3 id="支持链式调用，可以解决回调地狱问题"><a href="#支持链式调用，可以解决回调地狱问题" class="headerlink" title="支持链式调用，可以解决回调地狱问题"></a>支持链式调用，可以解决回调地狱问题</h3><h4 id="什么是回调地狱"><a href="#什么是回调地狱" class="headerlink" title="什么是回调地狱"></a>什么是回调地狱</h4><blockquote><p> 回调函数嵌套调用，外部回调函数异步执行的结果是其内部嵌套的回调函数执行的条件</p></blockquote><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">doSomething(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123;<br>  doSomethingElse(result, <span class="hljs-keyword">function</span>(<span class="hljs-params">newResult</span>) &#123;<br>   doThirdThing(newResult, <span class="hljs-keyword">function</span>(<span class="hljs-params">finalResult</span>) &#123;<br>      <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Got the final result:&#x27;</span> + finalResult)<br>    &#125;, failureCallback)<br>  &#125;, failureCallback)<br>&#125;, failureCallback)<br></code></pre></td></tr></table></figure><p><strong>回调地狱的缺点</strong></p><ol><li>不便于阅读</li><li>不便于异常处理</li></ol><h4 id="使用-promise-的链式调用解决回调地狱"><a href="#使用-promise-的链式调用解决回调地狱" class="headerlink" title="使用 promise 的链式调用解决回调地狱"></a>使用 promise 的链式调用解决回调地狱</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">doSomething()<br>    .<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(result)</span> =&gt;</span> doSomethingElse(result))<br>    .<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(newResult)</span> =&gt;</span> doThirdThing(newResult))<br>    .<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(finalResult)</span> =&gt;</span> &#123;<br>        console.log(<span class="hljs-string">&#x27;Got the final result:&#x27;</span> + finalResult)<br>    &#125;)<br>    .<span class="hljs-keyword">catch</span>(failureCallback)<br></code></pre></td></tr></table></figure><h4 id="回调地狱的终极解决方案-async-await"><a href="#回调地狱的终极解决方案-async-await" class="headerlink" title="回调地狱的终极解决方案 async&#x2F;await"></a>回调地狱的终极解决方案 async&#x2F;await</h4><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">async</span> <span class="hljs-variable">function</span> <span class="hljs-function"><span class="hljs-title">request</span>() &#123;</span><br><span class="hljs-function">    <span class="hljs-variable"><span class="hljs-keyword">try</span></span> &#123;</span><br><span class="hljs-function">        <span class="hljs-variable">const</span> <span class="hljs-variable"><span class="hljs-class">result</span></span> = <span class="hljs-variable">await</span> <span class="hljs-title">doSomething</span>()</span><br>        <span class="hljs-variable">const</span> <span class="hljs-variable">newResult</span> = <span class="hljs-variable">await</span> <span class="hljs-function"><span class="hljs-title">doSomethingElse</span>(<span class="hljs-variable"><span class="hljs-class">result</span></span>)</span><br>        <span class="hljs-variable">const</span> <span class="hljs-variable">finalResult</span> = <span class="hljs-variable">await</span> <span class="hljs-function"><span class="hljs-title">doThirdThing</span>(<span class="hljs-variable">newResult</span>)</span><br>        <span class="hljs-variable">console.log</span>(<span class="hljs-string">&#x27;Got the final result:&#x27;</span> + <span class="hljs-variable">finalResult</span>)<br>    &#125; <span class="hljs-variable">catch</span> (<span class="hljs-variable">error</span>) &#123;<br>        <span class="hljs-function"><span class="hljs-title">failureCallback</span>(<span class="hljs-variable">error</span>)</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Promise-相关方法"><a href="#Promise-相关方法" class="headerlink" title="Promise 相关方法"></a>Promise 相关方法</h2><h3 id="Promise-构造函数：Promise-executor"><a href="#Promise-构造函数：Promise-executor" class="headerlink" title="Promise 构造函数：Promise(executor) {}"></a>Promise 构造函数：<code>Promise(executor) &#123;&#125;</code></h3><ul><li><code>executor</code> 函数：<strong>同步执行</strong> <code>(resolve, reject) =&gt; &#123;&#125;</code></li><li><code>resolve</code> 函数：内部定义成功时调用的函数 <code>resove(value)</code></li><li><code>reject</code> 函数：内部定义失败时调用的函数 <code>reject(reason)</code></li></ul><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p><p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”(即从 <code>pending</code> 变为 <code>resolved</code>)，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去</p><p><code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”(即从 <code>pending</code> 变为 <code>rejected</code>)，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p><blockquote><p><code>executor</code> 是执行器，会在 <code>Promise</code> 内部立即同步回调，异步操作 <code>resolve</code>&#x2F;<code>reject</code> 就在 <code>executor</code> 中执行</p></blockquote><h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then ()"></a>Promise.prototype.then ()</h3><p><code>p.then(onResolved, onRejected)</code></p><p>指定两个回调（成功+失败）</p><ul><li><code>onResolved</code> 函数：成功的回调函数 <code>(value) =&gt; &#123;&#125;</code></li><li><code>onRejected</code> 函数：失败的回调函数 <code>(reason) =&gt; &#123;&#125;</code></li></ul><p><code>then()</code>的作用是为 <code>Promise</code> 实例添加状态改变时的回调函数。<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数(可选)是<code>rejected</code>状态的回调函数。</p><p><code>then</code>方法返回的是一个新的<code>Promise</code>实例(注意，不是原来那个<code>Promise</code>实例)。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p><blockquote><p>指定用于得到成功 <code>value</code> 的成功回调和用于得到失败 <code>reason</code> 的失败回调，返回一个新的 <code>promise</code> 对象</p></blockquote><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><p><code>p.catch(onRejected)</code></p><p>指定失败的回调</p><ul><li><code>onRejected</code> 函数：失败的回调函数 <code>(reason) =&gt; &#123;&#125;</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// excutor执行器函数</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 异步操作成功 */</span>) &#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;成功的数据&#x27;</span>) <span class="hljs-comment">// resolve()函数</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;失败的数据&#x27;</span>) <span class="hljs-comment">//reject()函数</span><br>        &#125;<br>    &#125;, <span class="hljs-number">1000</span>)<br>&#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// onResolved()函数</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value) <span class="hljs-comment">// 成功的数据</span><br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// onRejected()函数</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason) <span class="hljs-comment">// 失败的数据</span><br>    &#125;)<br></code></pre></td></tr></table></figure><blockquote><p>这是<code>then()</code> 的语法糖，相当于 <code>then(undefined, onRejected)</code></p></blockquote><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h3><p><code>Promise.resolve(value)</code></p><ul><li><p><code>value</code>：将被 <code>Promise</code> 对象解析的参数，也可以是一个成功或失败的 <code>Promise</code> 对象</p></li><li><p><code>return</code> ：返回一个带着给定值解析过的 <code>Promise</code> 对象，如果参数本身就是一个 <code>Promise</code> 对象，则直接返回这个 <code>Promise</code> 对象。</p></li></ul><p><code>Promise.resolve</code>方法的参数分成四种情况。</p><ol><li><p>参数是一个<code>Promise</code>实例</p><p>如果参数是 Promise 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">let p2 = <span class="hljs-built_in">Promise</span>.resolve(<br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>        <span class="hljs-regexp">//</span> resolve(<span class="hljs-string">&#x27;OK&#x27;</span>) <span class="hljs-regexp">//</span> 成功的<span class="hljs-built_in">Promise</span><br>        reject(<span class="hljs-string">&#x27;Error&#x27;</span>)<br>    &#125;)<br>)<br>console.log(p2) <span class="hljs-regexp">//</span> <span class="hljs-built_in">Promise</span> &#123;&lt;rejected&gt;: <span class="hljs-string">&#x27;Error&#x27;</span>&#125;<br>p2.<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">(reason)</span> =&gt;</span> &#123;<br>    console.log(reason) <span class="hljs-regexp">//</span> <span class="hljs-built_in">Error</span><br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>参数是一个<code>thenable</code>对象</p><p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> thenable = &#123;<br><span class="hljs-attr">then</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">42</span>)<br>&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Promise.resolve</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> thenable = &#123;<br>  <span class="hljs-attr">then</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">42</span>)<br>  &#125;,<br>&#125;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(thenable);<br>p1.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// 42</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>上面代码中，<code>thenable</code>对象的<code>then</code>方法执行后，对象<code>p1</code>的状态就变为<code>resolved</code>，从而立即执行最后那个<code>then</code>方法指定的回调函数，输出 42。</p></li><li><p>参数不是具有<code>then</code>方法的对象，或根本就不是对象</p><p>如果参数是一个原始值，或者是一个不具有<code>then</code>方法的对象，则<code>Promise.resolve</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br><br>p.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s);<br>&#125;);<br><span class="hljs-comment">// Hello</span><br></code></pre></td></tr></table></figure><p>上面代码生成一个新的 Promise 对象的实例<code>p</code>。由于字符串<code>Hello</code>不属于异步操作(判断方法是字符串对象不具有 then 方法)，返回 Promise 实例的状态从一生成就是<code>resolved</code>，所以回调函数会立即执行。<code>Promise.resolve</code>方法的参数，会同时传给回调函数。</p></li><li><p>不带有任何参数</p><p><code>Promise.resolve</code>方法允许调用时不带参数，直接返回一个<code>resolved</code>状态的 Promise 对象。</p><p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用<code>Promise.resolve</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>();<br><br>p.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>上面代码的变量<code>p</code>就是一个 Promise 对象。</p><p>需要注意的是，立即<code>resolve</code>的 Promise 对象，是在本轮“事件循环”(event loop)的结束时，而不是在下一轮“事件循环”的开始时。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;three&quot;</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;two&quot;</span>)<br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;one&quot;</span>)<br><br><span class="hljs-comment">// one</span><br><span class="hljs-comment">// two</span><br><span class="hljs-comment">// three</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>setTimeout(fn, 0)</code>在下一轮“事件循环”开始时执行，<code>Promise.resolve()</code>在本轮“事件循环”结束时执行，<code>console.log(&#39;one&#39;)</code>则是立即执行，因此最先输出</p></li></ol><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h3><p><code>Promise.resolve(reason)</code></p><ul><li><code>reason</code>：失败的原因</li><li><code>return</code>：返回一个失败的 <code>promise</code> 对象，该实例的状态为<code>rejected</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-number">521</span>)<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;iloveyou&#x27;</span>)<br><span class="hljs-keyword">let</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;OK&#x27;</span>)<br>    &#125;)<br>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p) <span class="hljs-comment">// Promise &#123;&lt;rejected&gt;: 521&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2) <span class="hljs-comment">// Promise &#123;&lt;rejected&gt;: &#x27;iloveyou&#x27;&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p3) <span class="hljs-comment">// Promise &#123;&lt;rejected&gt;: Promise&#125;</span><br><br></code></pre></td></tr></table></figure><p>注：</p><ul><li><code>Promise.resolve()</code>&#x2F;<code>Promise.reject()</code> 方法就是一个语法糖</li><li>用来快速得到<code>Promise</code>对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//产生一个成功值为1的promise对象</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)<br>&#125;)<br><span class="hljs-comment">//相当于</span><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">const</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-number">3</span>)<br><br>p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br>&#125;) <span class="hljs-comment">// 1</span><br>p2.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br>&#125;) <span class="hljs-comment">// 2</span><br>p3.<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason)<br>&#125;) <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p><code>Promise.all(iterable)</code></p><ul><li><code>iterable</code>：包含 n 个 <code>promise</code> 的可迭代对象，如 <code>Array</code> 或 <code>String</code></li><li><code>return</code>：返回一个新的 <code>promise</code>，只有所有的 <code>promise</code> 都成功才成功，只要有一个失败了就直接失败</li></ul><p>成功：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;OK&#x27;</span>)<br>&#125;)<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Success&#x27;</span>)<br><span class="hljs-keyword">let</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Oh Yeah&#x27;</span>)<br><br><span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1, p2, p3])<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result) <span class="hljs-comment">// Promise &#123;&lt;pending&gt;&#125;</span><br>                       [[<span class="hljs-title class_">PromiseResult</span>]]: <span class="hljs-title class_">Array</span>(<span class="hljs-number">3</span>)<br>                        <span class="hljs-number">0</span>: <span class="hljs-string">&quot;OK&quot;</span><br>                        <span class="hljs-number">1</span>: <span class="hljs-string">&quot;Success&quot;</span><br>                        <span class="hljs-number">2</span>: <span class="hljs-string">&quot;Oh Yeah&quot;</span><br>                        <span class="hljs-attr">length</span>: <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>失败：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;OK&#x27;</span>)<br>&#125;)<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;Error&#x27;</span>)<br><span class="hljs-keyword">let</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Oh Yeah&#x27;</span>)<br><br><span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1, p2, p3])<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result) <span class="hljs-comment">//Promise &#123;&lt;pending&gt;&#125;</span><br>[[<span class="hljs-title class_">PromiseResult</span>]]: <span class="hljs-string">&quot;Error&quot;</span><br></code></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p><code>Promise.race(iterable)</code></p><ul><li><code>iterable</code>：包含 n 个 <code>promise</code> 的可迭代对象，如 <code>Array</code> 或 <code>String</code></li><li><code>return</code>：返回一个新的 <code>promise</code>，第一个完成的 <code>promise</code> 的结果状态就是最终的结果状态<br><strong>谁先完成就输出谁(不管是成功还是失败)</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pRace = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([p1, p2, p3])<br><span class="hljs-comment">// 谁先完成就输出谁(不管是成功还是失败)</span><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)<br>    &#125;, <span class="hljs-number">1000</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">const</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-number">3</span>)<br><br>pRace.<span class="hljs-title function_">then</span>(<br>    <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;race onResolved()&#x27;</span>, value)<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;race onRejected()&#x27;</span>, reason)<br>    &#125;<br>)<br><span class="hljs-comment">//race onResolved() 2</span><br></code></pre></td></tr></table></figure><h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><p><code>finally()</code> 方法返回一个<code>Promise</code>。在<code>promise</code>结束时，无论结果是<code>resolved</code>或者是<code>rejected</code>，都会执行指定的回调函数。这为在<code>Promise</code>是否成功完成后都需要执行的代码提供了一种方式，避免了同样的语句需要在<code>then()</code>和<code>catch()</code>中各写一次的情况。</p><p><code>finally</code>本质上是<code>then</code>方法的特例。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">promise.<span class="hljs-keyword">finally</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-regexp">//</span> 语句<br>&#125;)<br><br><span class="hljs-regexp">//</span> 等同于<br>promise.<span class="hljs-keyword">then</span>(<br>    <span class="hljs-function"><span class="hljs-params">(result)</span> =&gt;</span> &#123;<br>        <span class="hljs-regexp">//</span> 语句<br>        <span class="hljs-keyword">return</span> result<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-params">(error)</span> =&gt;</span> &#123;<br>        <span class="hljs-regexp">//</span> 语句<br>        <span class="hljs-keyword">throw</span> error<br>    &#125;<br>)<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> resolve 的值是 <span class="hljs-literal">undefined</span><br><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>).<span class="hljs-keyword">then</span>(<br>    <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;,<br>    <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;<br>)<br><br><span class="hljs-regexp">//</span> resolve 的值是 <span class="hljs-number">2</span><br><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>).<span class="hljs-keyword">finally</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;)<br><br><span class="hljs-regexp">//</span> reject 的值是 <span class="hljs-literal">undefined</span><br><span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">3</span>).<span class="hljs-keyword">then</span>(<br>    <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;,<br>    <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;<br>)<br><br><span class="hljs-regexp">//</span> reject 的值是 <span class="hljs-number">3</span><br><span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">3</span>).<span class="hljs-keyword">finally</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;)<br></code></pre></td></tr></table></figure><h2 id="Promise-的相关问题"><a href="#Promise-的相关问题" class="headerlink" title="Promise 的相关问题"></a>Promise 的相关问题</h2><h3 id="如何改变-promise-的状态"><a href="#如何改变-promise-的状态" class="headerlink" title="如何改变 promise 的状态"></a>如何改变 promise 的状态</h3><ol><li><code>resolve(value)</code>：如果当前是 <code>pending</code> 就会变为 &#96;resolved&#96;&#96;</li><li>&#96;&#96;reject(reason)<code>：如果当前是 </code>pending<code>就会变为</code>rejected&#96;</li><li>抛出异常：如果当前是 <code>pending</code> 就会变为 <code>rejected</code></li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    <span class="hljs-regexp">//resolve(1) /</span>/ promise变为resolved成功状态<br>    <span class="hljs-regexp">//reject(2) /</span>/ promise变为rejected失败状态<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;出错了&#x27;</span>) <span class="hljs-regexp">//</span> 抛出异常，promise变为rejected失败状态，reason为抛出的error<br>&#125;)<br>p.<span class="hljs-keyword">then</span>(<br>    <span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> &#123;&#125;,<br>    <span class="hljs-function"><span class="hljs-params">(reason)</span> =&gt;</span> &#123;<br>        console.log(<span class="hljs-string">&#x27;reason&#x27;</span>, reason)<br>    &#125;<br>)<br><span class="hljs-regexp">//</span> reason <span class="hljs-built_in">Error</span><br></code></pre></td></tr></table></figure><h3 id="一个-promise-指定多个成功-失败回调函数，都会调用吗"><a href="#一个-promise-指定多个成功-失败回调函数，都会调用吗" class="headerlink" title="一个 promise 指定多个成功&#x2F;失败回调函数，都会调用吗"></a>一个 promise 指定多个成功&#x2F;失败回调函数，都会调用吗</h3><p>当 <code>promise</code> <strong>改变</strong>为对应状态时<strong>都会调用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//resolve(1)</span><br>    <span class="hljs-title function_">reject</span>(<span class="hljs-number">2</span>)<br>&#125;)<br>p.<span class="hljs-title function_">then</span>(<br>    <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;&#125;,<br>    <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;reason&#x27;</span>, reason)<br>    &#125;<br>)<br>p.<span class="hljs-title function_">then</span>(<br>    <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;&#125;,<br>    <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;reason2&#x27;</span>, reason)<br>    &#125;<br>)<br><span class="hljs-comment">// reason 2</span><br><span class="hljs-comment">// reason2 2</span><br></code></pre></td></tr></table></figure><h3 id="改变-promise-状态和指定回调函数谁先谁后"><a href="#改变-promise-状态和指定回调函数谁先谁后" class="headerlink" title="改变 promise 状态和指定回调函数谁先谁后"></a>改变 promise 状态和指定回调函数谁先谁后</h3><blockquote><p>都有可能，常规是先指定回调再改变状态，但也可以先改状态再指定回调</p></blockquote><ul><li><p>如何先改状态再指定回调</p><ol><li><p>在执行器中直接调用 <code>resolve()</code>&#x2F;<code>reject()</code></p></li><li><p>延迟更长时间才调用 <code>then()</code></p></li></ol>  <figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">let p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>  <span class="hljs-regexp">//</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  resolve(<span class="hljs-string">&#x27;OK&#x27;</span>)<br>  <span class="hljs-regexp">//</span> &#125;, <span class="hljs-number">1000</span>); <span class="hljs-regexp">//</span> 有异步就先指定回调，否则先改变状态<br>  &#125;)<br><br>  p.<span class="hljs-keyword">then</span>(<br>      <span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> &#123;<br>          console.log(value)<br>      &#125;,<br>      <span class="hljs-function"><span class="hljs-params">(reason)</span> =&gt;</span> &#123;&#125;<br>  )<br>  <br></code></pre></td></tr></table></figure></li><li><p>什么时候才能得到数据？</p><ol><li>如果先指定的回调，那当状态发生改变时，回调函数就会调用得到数据</li><li>如果先改变的状态，那当指定回调时，回调函数就会调用得到数据</li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        resolve(<span class="hljs-number">1</span>) <span class="hljs-regexp">//</span> 改变状态<br>    &#125;, <span class="hljs-number">1000</span>)<br>&#125;).<span class="hljs-keyword">then</span>(<br>    <span class="hljs-regexp">//</span> 指定回调函数 （先指定）<br>    (value) =&gt; &#123;&#125;,<br>    <span class="hljs-function"><span class="hljs-params">(reason)</span> =&gt;</span> &#123;&#125;<br>)<br></code></pre></td></tr></table></figure><p>此时，先指定回调函数，保存当前指定的回调函数；后改变状态(同时指定数据)，然后异步执行之前保存的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 改变状态</span><br>&#125;).<span class="hljs-title function_">then</span>(<br>    <span class="hljs-comment">// 指定回调函数</span><br>    <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;&#125;,<br>    <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;&#125;<br>)<br><br>这种写法，先改变的状态(同时指定数据)，后指定回调函数(不需要再保存)，直接异步执行回调函数<br></code></pre></td></tr></table></figure></li></ul><h3 id="promise-then-返回的新-promise-的结果状态由什么决定"><a href="#promise-then-返回的新-promise-的结果状态由什么决定" class="headerlink" title="promise.then() 返回的新 promise 的结果状态由什么决定"></a>promise.then() 返回的新 promise 的结果状态由什么决定</h3><ul><li>简单表达：由 <code>then()</code> 指定的回调函数执行的结果决定</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>)<br>&#125;)<br><span class="hljs-comment">//执行 then 方法</span><br><span class="hljs-keyword">let</span> result = p.<span class="hljs-title function_">then</span>(<br>    <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value) <span class="hljs-comment">//ok</span><br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(reason)<br>    &#125;<br>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br><span class="hljs-comment">// Promise &#123;&lt;pending&gt;&#125;</span><br><span class="hljs-comment">// [[Prototype]]: Promise</span><br><span class="hljs-comment">// [[PromiseState]]: &quot;fulfilled&quot;</span><br><span class="hljs-comment">// [[PromiseResult]]: undefined</span><br></code></pre></td></tr></table></figure><ul><li>详细表达</li></ul><ol><li>如果抛出异常，新 <code>promise</code> 变为 <code>rejected</code>，<code>reason</code> 为抛出的异常</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>)<br>&#125;)<br><span class="hljs-comment">//执行 then 方法</span><br><span class="hljs-keyword">let</span> result = p.<span class="hljs-title function_">then</span>(<br>    <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//1. 抛出错误</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;出了问题&#x27;</span><br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(reason)<br>    &#125;<br>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br><span class="hljs-comment">// Promise &#123;&lt;pending&gt;&#125;</span><br>        [[<span class="hljs-title class_">Prototype</span>]]: <span class="hljs-title class_">Promise</span><br>        [[<span class="hljs-title class_">PromiseState</span>]]: <span class="hljs-string">&quot;rejected&quot;</span><br>        [[<span class="hljs-title class_">PromiseResult</span>]]: <span class="hljs-string">&quot;出了问题</span><br></code></pre></td></tr></table></figure><ol start="2"><li>如果返回的是非 <code>promise</code> 的任意值，新 <code>promise</code> 变为 <code>resolved</code>，<code>value</code> 为返回的值</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>)<br>&#125;)<br><span class="hljs-comment">//执行 then 方法</span><br><span class="hljs-keyword">let</span> result = p.<span class="hljs-title function_">then</span>(<br>    <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//2. 返回结果是非 Promise 类型的对象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">521</span><br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(reason)<br>    &#125;<br>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br><span class="hljs-comment">// Promise &#123;&lt;pending&gt;&#125;</span><br>        [[<span class="hljs-title class_">Prototype</span>]]: <span class="hljs-title class_">Promise</span><br>        [[<span class="hljs-title class_">PromiseState</span>]]: <span class="hljs-string">&quot;fulfilled&quot;</span><br>        [[<span class="hljs-title class_">PromiseResult</span>]]: <span class="hljs-number">521</span><br></code></pre></td></tr></table></figure><ol start="3"><li>如果返回的是另一个新 <code>promise</code>，此 <code>promise</code> 的结果就会成为新 <code>promise</code> 的结果</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>)<br>&#125;)<br><span class="hljs-comment">//执行 then 方法</span><br><span class="hljs-keyword">let</span> result = p.<span class="hljs-title function_">then</span>(<br>    <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//3. 返回结果是 Promise 对象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">// resolve(&#x27;success&#x27;);</span><br>            <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>)<br>        &#125;)<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(reason)<br>    &#125;<br>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br><span class="hljs-comment">// Promise &#123;&lt;pending&gt;&#125;</span><br>        [[<span class="hljs-title class_">Prototype</span>]]: <span class="hljs-title class_">Promise</span><br>        [[<span class="hljs-title class_">PromiseState</span>]]: <span class="hljs-string">&quot;rejected&quot;</span><br>        [[<span class="hljs-title class_">PromiseResult</span>]]: <span class="hljs-string">&quot;error&quot;</span><br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    resolve(<span class="hljs-number">1</span>)<br>&#125;)<br>    .<span class="hljs-keyword">then</span>(<br>        <span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> &#123;<br>            console.log(<span class="hljs-string">&#x27;onResolved1()&#x27;</span>, value)<br>            <span class="hljs-regexp">//return 2                   /</span>/ onResolved2() <span class="hljs-number">2</span><br>            /<span class="hljs-regexp">/return Promise.resolve(3)  /</span>/ onResolved2() <span class="hljs-number">3</span><br>            /<span class="hljs-regexp">/return Promise.reject(4)   /</span>/ onRejected2() <span class="hljs-number">4</span><br>            /<span class="hljs-regexp">/throw 5                    /</span>/ onRejected2() <span class="hljs-number">5</span><br>        &#125;,<br>        <span class="hljs-function"><span class="hljs-params">(reason)</span> =&gt;</span> &#123;<br>            console.log(<span class="hljs-string">&#x27;onRejected1()&#x27;</span>, reason)<br>        &#125;<br>    )<br>    .<span class="hljs-keyword">then</span>(<br>        <span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> &#123;<br>            console.log(<span class="hljs-string">&#x27;onResolved2()&#x27;</span>, value)<br>        &#125;,<br>        <span class="hljs-function"><span class="hljs-params">(reason)</span> =&gt;</span> &#123;<br>            console.log(<span class="hljs-string">&#x27;onRejected2()&#x27;</span>, reason)<br>        &#125;<br>    )<br><span class="hljs-regexp">//</span> onResolved1() <span class="hljs-number">1</span><br>// onResolved2() <span class="hljs-literal">undefined</span><br><span class="hljs-regexp">//</span> <span class="hljs-built_in">Promise</span> &#123;&lt;fulfilled&gt;: <span class="hljs-literal">undefined</span>&#125;<br><span class="hljs-regexp">//</span> 对应输出如上所示<br></code></pre></td></tr></table></figure><p>​</p><h3 id="promise-如何串联多个操作任务？"><a href="#promise-如何串联多个操作任务？" class="headerlink" title="promise 如何串联多个操作任务？"></a>promise 如何串联多个操作任务？</h3><ol><li><code>promise</code> 的 <code>then()</code> 返回一个新的 <code>promise</code>，可以并成 <code>then()</code> 的链式调用</li><li>通过 <code>then</code> 的链式调用串联多个同步&#x2F;异步任务</li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">let p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        resolve(<span class="hljs-string">&#x27;OK&#x27;</span>)<br>    &#125;, <span class="hljs-number">1000</span>)<br>&#125;)<br><br>p.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    console.log(<span class="hljs-string">&#x27;value&#x27;</span>) <span class="hljs-regexp">//</span> OK<br>        resolve(<span class="hljs-string">&#x27;success&#x27;</span>)<br>    &#125;)<br>&#125;)<br>    .<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> &#123;<br>        console.log(value) <span class="hljs-regexp">//</span> success<br>    &#125;)<br>    .<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> &#123;<br>        console.log(value) <span class="hljs-regexp">//</span> <span class="hljs-literal">undefined</span><br>    &#125;)<br><span class="hljs-regexp">//</span> OK success <span class="hljs-literal">undefined</span><br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;执行任务1(异步)&#x27;</span>)<br>        resolve(<span class="hljs-number">1</span>)<br>    &#125;, <span class="hljs-number">1000</span>)<br>&#125;)<br>    .then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;任务1的结果&#x27;</span>, value)<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;执行任务2(同步)&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> <span class="hljs-comment">// 同步任务直接return返回结果</span><br>    &#125;)<br>    .then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;任务2的结果&#x27;</span>, value)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">// 异步任务需要包裹在Promise对象中</span><br>            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;执行任务3(异步)&#x27;</span>)<br>                resolve(<span class="hljs-number">3</span>)<br>            &#125;, <span class="hljs-number">1000</span>)<br>        &#125;)<br>    &#125;)<br>    .then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;任务3的结果&#x27;</span>, value)<br>    &#125;)<br><span class="hljs-comment">// 执行任务1(异步)</span><br><span class="hljs-comment">// 任务1的结果 1</span><br><span class="hljs-comment">// 执行任务2(同步)</span><br><span class="hljs-comment">// 任务2的结果 2</span><br><span class="hljs-comment">// 执行任务3(异步)</span><br><span class="hljs-comment">// 任务3的结果 3</span><br><br></code></pre></td></tr></table></figure><h3 id="Promise-异常穿透-传透"><a href="#Promise-异常穿透-传透" class="headerlink" title="Promise 异常穿透(传透)"></a>Promise 异常穿透(传透)</h3><ol><li>当使用 <code>promise</code> 的 <code>then</code> 链式调用时，可以在最后指定失败的回调</li><li>前面任何操作出了异常，都会传到最后失败的回调中处理</li></ol><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//resolve(1)</span><br>    reject(<span class="hljs-number">1</span>)<br>&#125;)<br>    .then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;onResolved1()&#x27;</span>, value)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>    &#125;)<br>    .then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;onResolved2()&#x27;</span>, value)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br>    &#125;)<br>    .then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;onResolved3()&#x27;</span>, value)<br>    &#125;)<br>    .<span class="hljs-keyword">catch</span>(<span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;onRejected1()&#x27;</span>, reason)<br>    &#125;)<br><span class="hljs-comment">// onRejected1() 1</span><br></code></pre></td></tr></table></figure><p>相当于这种写法：多写了很多<code>reason =&gt; &#123;throw reason&#125;</code></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    //resolve(<span class="hljs-number">1</span>)<br>    reject(<span class="hljs-number">1</span>)<br>&#125;)<br>    .<span class="hljs-keyword">then</span>(<br>        <span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> &#123;<br>            console.log(<span class="hljs-string">&#x27;onResolved1()&#x27;</span>, value)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>        &#125;,<br>        <span class="hljs-function"><span class="hljs-params">(reason)</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">throw</span> reason<br>        &#125; <span class="hljs-regexp">//</span> 抛出失败的结果reason<br>    )<br>    .<span class="hljs-keyword">then</span>(<br>        <span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> &#123;<br>            console.log(<span class="hljs-string">&#x27;onResolved2()&#x27;</span>, value)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br>        &#125;,<br>        <span class="hljs-function"><span class="hljs-params">(reason)</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">throw</span> reason<br>        &#125; <span class="hljs-regexp">//</span> 抛出失败的结果reason<br>    )<br>    .<span class="hljs-keyword">then</span>(<br>        <span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> &#123;<br>            console.log(<span class="hljs-string">&#x27;onResolved3()&#x27;</span>, value)<br>        &#125;,<br>        <span class="hljs-function"><span class="hljs-params">(reason)</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">throw</span> reason<br>        &#125; <span class="hljs-regexp">//</span> 抛出失败的结果reason<br>    )<br>    .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">(reason)</span> =&gt;</span> &#123;<br>        console.log(<span class="hljs-string">&#x27;onRejected1()&#x27;</span>, reason)<br>    &#125;)<br><span class="hljs-regexp">//</span> onRejected1() <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>所以失败的结果是一层一层处理下来的，最后传递到 <code>catch</code> 中。</p><p>注：将 <code>reason =&gt; &#123;throw reason&#125;</code> 替换为 <code>reason =&gt; Promise.reject(reason)</code> 也是一样的</p><h3 id="中断-promise-链"><a href="#中断-promise-链" class="headerlink" title="中断 promise 链"></a>中断 promise 链</h3><p>当使用 <code>promise</code> 的 <code>then</code> 链式调用时，在中间中断，不再调用后面的回调函数</p><p>办法：在回调函数中返回一个 <code>pending</code> 状态的 <code>promise</code> 对象</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//resolve(1)</span><br>    reject(<span class="hljs-number">1</span>)<br>&#125;)<br>    .then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;onResolved1()&#x27;</span>, value)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>    &#125;)<br>    .then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;onResolved2()&#x27;</span>, value)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br>    &#125;)<br>    .then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;onResolved3()&#x27;</span>, value)<br>    &#125;)<br>    .<span class="hljs-keyword">catch</span>(<span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;onRejected1()&#x27;</span>, reason)<br>    &#125;)<br>    .then(<br>        <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;onResolved4()&#x27;</span>, value)<br>        &#125;,<br>        (reason) =&gt; &#123;<br>            <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;onRejected2()&#x27;</span>, reason)<br>        &#125;<br>    )<br><span class="hljs-comment">// onRejected1() 1</span><br><span class="hljs-comment">// onResolved4() undefined</span><br></code></pre></td></tr></table></figure><p>为了在 <code>catch</code> 中就中断执行，可以这样写：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//resolve(1)</span><br>    reject(<span class="hljs-number">1</span>)<br>&#125;)<br>    .then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;onResolved1()&#x27;</span>, value)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>    &#125;)<br>    .then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;onResolved2()&#x27;</span>, value)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br>    &#125;)<br>    .then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;onResolved3()&#x27;</span>, value)<br>    &#125;)<br>    .<span class="hljs-keyword">catch</span>(<span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;onRejected1()&#x27;</span>, reason)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Promise(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;) <span class="hljs-comment">// 返回一个pending的promise</span><br>    &#125;)<br>    .then(<br>        <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;onResolved4()&#x27;</span>, value)<br>        &#125;,<br>        (reason) =&gt; &#123;<br>            <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;onRejected2()&#x27;</span>, reason)<br>        &#125;<br>    )<br><span class="hljs-comment">// onRejected1() 1</span><br></code></pre></td></tr></table></figure><p>在 <code>catch</code> 中返回一个新的 <code>promise</code>，且这个 <code>promise</code> 没有结果。</p><p>由于，返回的新的 <code>promise</code> 结果决定了后面 <code>then</code> 中的结果，所以后面的 <code>then</code> 中也没有结果。</p><p>这就实现了中断 <code>promise链</code>的效果。</p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 基本指令</title>
    <link href="/2022/09/17/vue/Vue%E6%8C%87%E4%BB%A4/"/>
    <url>/2022/09/17/vue/Vue%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-基本指令"><a href="#Vue-基本指令" class="headerlink" title="Vue 基本指令"></a>Vue 基本指令</h1><h2 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h2><p><code>v-text</code>，该指令的用法同原生 JS 中的 <code>innerText</code>，更新绑定元素内部的文本内容</p><pre><code class="hljs">    &lt;div id=&quot;div&quot;&gt;        &lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt;        &lt;!--不会有闪烁问题--&gt;&lt;!-- 和下面的一样 --&gt;        &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt;    &lt;/div&gt;</code></pre><p>与插值语法的区别：<code>v-text</code>会替换掉节点中的内容，<code>&#123;&#123;xx&#125;&#125;</code>则不会。</p><span id="more"></span><h2 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h2><p><code>v-html</code>，该指令用法同原生 JS 的 <code>innerHTML</code>，可以解析内部的 HTML 标签</p><h2 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h2><p><code>v-cloak</code>，该指令 CSS 一起使用，用于隐藏还没有开始编译的<code>&#123;&#123;&#125;&#125;</code>(插值表达式)直到编译完成，解决其闪烁问题<br>使用<code>css</code>配合<code>v-cloak</code>可以解决网速慢时页面展示出<code>&#123;&#123;xxx&#125;&#125;</code>的问题。</p><p>本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉<code>v-cloak</code>属性。</p><h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><p><code>v-show</code>，该指令用于显示和隐藏 DOM 元素，<strong>根据表达式之真假值</strong>，切换元素的 <code>display</code> 属性值</p><ul><li><code>v-show</code> 值为<code>true</code>时显示</li><li>当条件变化时该指令触发过渡效果，切换频率较高的场景</li><li>不展示的DOM元素未被移除，仅仅是使用样式隐藏掉</li><li><code>v-show</code> 指令不支持在<code>&lt;template&gt;&lt; /template&gt;</code>标签上写，也不支持 <code>v-else</code>，一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好，如果在运行时条件很少改变，则使用 <code>v-if</code> 较好</li></ul><h2 id="v-if，v-else-与-v-else-if"><a href="#v-if，v-else-与-v-else-if" class="headerlink" title="v-if，v-else 与 v-else-if"></a>v-if，v-else 与 v-else-if</h2><p><code>v-if</code>，该指令用于是否渲染 DOM 元素，传入一个布尔值，通过该布尔值的条件改变实现对于 DOM 元素的删除和重建，该指令不同于 <code>v-show</code>，而是会完全销毁这个 DOM 元素<br>**注意:**当条件变化时该指令触发过渡效果</p><p><code>v-else</code>， 该指令用于 不需要任何表达式 ，但是在该指令的前一个兄弟元素必须有 <code>v-if</code> 或者 <code>v-else-if</code> 指令，该指令的用处是为 <code>v-if</code> 或者 <code>v-else-if</code> 添加 <code>else</code> 的选项</p><pre><code class="hljs">    &lt;div v-if=&quot;Math.random() &gt; 0.5&quot;&gt;Now you see me&lt;/div&gt;    &lt;div v-else&gt;Now you don&#39;t&lt;/div&gt;</code></pre><p><code>v-else-if</code>，该指令用于用于 <code>v-if</code> 的 <code>else if</code> 选项，前一个兄弟元素必须要 <code>v-if</code> 指令，并且该指令可以链式调用，也就是说可以调用多次 <code>v-else-if</code> 指令</p><pre><code class="hljs">    &lt;div v-if=&quot;type === &#39;A&#39;&quot;&gt;A&lt;/div&gt;    &lt;div v-else-if=&quot;type === &#39;B&#39;&quot;&gt;B&lt;/div&gt;    &lt;div v-else-if=&quot;type === &#39;C&#39;&quot;&gt;C&lt;/div&gt;    &lt;div v-else&gt;Not A/B/C&lt;/div&gt;</code></pre><h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><p><code>v-for</code>该指令可以基于源数据多次渲染元素或模板块，用于循环遍历某个数组或对象，如果只用一个变量代表得到是数组或对象的 <code>value</code> 值</p><p>**注意:在内部必须使用固定的 <code>item in/of items</code>**形式的特殊语法(下面的 <code>in</code> 都可以用 <code>of</code> 代替，并且更符合实际)</p><pre><code class="hljs">    &lt;ul id=&quot;example-1&quot;&gt;        &lt;li v-for=&quot;item in items&quot;&gt;            &#123;&#123; item.message &#125;&#125;            &lt;!--Foo Bar--&gt;        &lt;/li&gt;    &lt;/ul&gt;    &lt;script&gt;        var example1 = new Vue(&#123;            el: &#39;#example-1&#39;，            data: &#123;                items: [&#123; message: &#39;Foo&#39; &#125;， &#123; message: &#39;Bar&#39; &#125;]，            &#125;，        &#125;)    &lt;/script&gt;</code></pre><p><strong>遍历数组</strong>时其实还支持第二个变量，代表的是遍历数组的索引值</p><pre><code class="hljs">    &lt;ul id=&quot;example-2&quot;&gt;        &lt;li v-for=&quot;(item， index) in items&quot;&gt;            &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;            &lt;!--              Parent-0-Foo              Parent-1-Bar          --&gt;        &lt;/li&gt;    &lt;/ul&gt;    &lt;script&gt;        var example2 = new Vue(&#123;            el: &#39;#example-2&#39;，            data: &#123;                parentMessage: &#39;Parent&#39;，                items: [&#123; message: &#39;Foo&#39; &#125;， &#123; message: &#39;Bar&#39; &#125;]，            &#125;，        &#125;)    &lt;/script&gt;</code></pre><ul><li><p><code>遍历对象</code>时还可以接受第二三两个变量，分别代表了键名和索引值</p><pre><code class="hljs">  &lt;ul id=&quot;v-for-object&quot; class=&quot;demo&quot;&gt;      &lt;div v-for=&quot;(value， key， index) in object&quot;&gt;          &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;          &lt;!--         0. firstName: John         1. lastName: Doe         2. age: 30        --&gt;      &lt;/div&gt;  &lt;/ul&gt;  &lt;script&gt;      new Vue(&#123;          el: &#39;#v-for-object&#39;，          data: &#123;              object: &#123;                  firstName: &#39;John&#39;，                  lastName: &#39;Doe&#39;，                  age: 30，              &#125;，          &#125;，      &#125;)  &lt;/script&gt;</code></pre></li></ul><p>**注意:**当 <code>v-for</code> 和 <code>v-if</code> 处于同一节点时，<code>v-for</code> 的优先级比 <code>v-if</code> 更高，这意味着 <code>v-if</code> 将分别重复运行于每个 <code>v-for</code> 循环中，当想为仅有的一些项渲染节点时，这种优先级的机制会十分有用</p><pre><code class="hljs">    &lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt;&#123;&#123; todo &#125;&#125;&lt;/li&gt;    &lt;!--        官方并不建议v-for和v-if指令一起使用，如果要使用这种方式，就进行条件渲染    --&gt;    &lt;!--        如果想有条件才继续v-for指令，则可以将v-if置于外层元素(或&lt;template&gt;)上    --&gt;    &lt;ul v-if=&quot;todos.length&quot;&gt;        &lt;li v-for=&quot;todo in todos&quot;&gt;&#123;&#123; todo &#125;&#125;&lt;/li&gt;    &lt;/ul&gt;    &lt;p v-else&gt;No todos left!&lt;/p&gt;    &lt;!--        条件渲染        v-if如果想只写一个而同时切换多个元素，可以在最外成包裹一层&lt;template&gt;&lt;/template&gt;，        在这个标签上面使用v-if，在渲染的时候并不会将&lt;template&gt;标签渲染出来    --&gt;</code></pre><h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2><p><code>v-bind</code>，该指令用于动态绑定一个或多个特性，该方法绑定的特性与普通的属性效果一致，只是其内部会被解析为 JS 表达式，而不是普通特性一样会是一个字符串<br><strong>修辞符</strong></p><ul><li><code>.prop</code>  被用于绑定 DOM 属性(<code>property</code>)</li><li><code>.camel</code>  将短横线命名法特性名转换为驼峰命名法</li><li><code>.sync</code>  会扩展成一个更新父组件绑定值的 <code>v-on</code> 侦听器</li></ul><p><strong>注意</strong></p><ul><li><p>该指令有其简写写法，通过冒号<code>:</code>来代替 <code>v-bind</code>:</p></li><li><p>该指令可以动态对绑定的参数进行改变，参数用<code>[]</code>括起来</p><pre><code class="hljs">  &lt;!-- 绑定一个属性 --&gt;  &lt;img v-bind:src=&quot;imageSrc&quot;&gt;    &lt;!-- 动态特性名 (2.6.0+) --&gt;  &lt;button v-bind:[key]=&quot;value&quot;&gt;&lt;/button&gt;    &lt;!-- 缩写 --&gt;  &lt;img :src=&quot;imageSrc&quot;&gt;    &lt;!-- 动态特性名缩写 (2.6.0+) --&gt;  &lt;button :[key]=&quot;value&quot;&gt;&lt;/button&gt;    &lt;!-- 内联字符串拼接 --&gt;  &lt;img :src=&quot;&#39;/path/to/images/&#39; + fileName&quot;&gt;    &lt;!-- class 绑定 --&gt;  &lt;div :class=&quot;&#123; red: isRed &#125;&quot;&gt;&lt;/div&gt;&lt;!--对象通过布尔值确定是否传入class中--&gt;  &lt;div :class=&quot;[classA， classB]&quot;&gt;&lt;/div&gt;&lt;!--数组会直接将类名传入到class中--&gt;  &lt;div :class=&quot;[classA， &#123; classB: isB， classC: isC &#125;]&quot;&gt;&lt;!--对象和数组可以混用--&gt;    &lt;!-- style 绑定 --&gt;  &lt;div :style=&quot;&#123; fontSize: size + &#39;px&#39; &#125;&quot;&gt;&lt;/div&gt;&lt;!--通过对象写入每个属性--&gt;  &lt;div :style=&quot;[styleObjectA， styleObjectB]&quot;&gt;&lt;/div&gt;&lt;!--数组的成员中实际是一个个对象--&gt;    &lt;!-- 绑定一个有属性的对象 --&gt;  &lt;div v-bind=&quot;&#123; id: someProp， &#39;other-attr&#39;: otherProp &#125;&quot;&gt;&lt;/div&gt;    &lt;!-- 通过 prop 修饰符绑定 DOM 属性 --&gt;  &lt;div v-bind:text-content.prop=&quot;text&quot;&gt;&lt;/div&gt;    &lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;  &lt;my-component :prop=&quot;someThing&quot;&gt;&lt;/my-component&gt;    &lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt;  &lt;child-component v-bind=&quot;$props&quot;&gt;&lt;/child-component&gt;    &lt;!-- XLink --&gt;  &lt;svg&gt;&lt;a :xlink:special=&quot;foo&quot;&gt;&lt;/a&gt;&lt;/svg&gt;</code></pre></li></ul><h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><p><code>v-on</code>，该指令用于绑定监听事件，表达式可以是一个方法的名字或一个内联语句(也就是说在传入事件的时候可以选择加()可以选择不加()，推荐在传入参数的时候添加，在不传参的时候写事件名)</p><p>**参数:**该指令的参数为原生 JS 中的事件名，只不过没有 <code>on</code></p><p><strong>修饰符</strong></p><ul><li><p><code>.stop</code>  调用 <code>event.stopPropagation()</code>，会阻止本元素上的事件进行冒泡传播 </p></li><li><p><code>.prevent</code>  调用 <code>event.preventDefault()</code>，不能和<code>.passive</code> 一起使用 </p></li><li><p><code>.capture</code>  添加事件侦听器时使用 <code>capture</code> 模式，父元素会执行在子元素上进行的同名事件 </p></li><li><p><code>.self</code>  只当事件是从侦听器绑定的元素本身触发时才触发回调，只会真正自己触发的事件才会进行，和<code>.stop</code> 是有区别的，这个只会阻止自己的冒泡，但不会阻止该元素的父元素事件的冒泡进行 </p></li><li><p><code>.&#123;keyCode | keyAlias&#125;</code>  只当事件是从特定键触发时才触发回调，可以是表示键盘字符的数字或者表示特效事件的按键修饰符 </p></li><li><p><code>.native</code>  监听组件根元素的原生事件，一个 Vue 实例内部通过只能 v-on 只能绑定自己内部的方法，不能绑定原生 DOM 事件的方法，通过该修饰符就可以使用原生 JS 的事件方法了 </p></li><li><p><code>.once</code>  只触发一次回调 </p></li><li><p><code>.left</code>  只当点击鼠标左键时触发 </p></li><li><p><code>.right</code>  只当点击鼠标右键时触发 </p></li><li><p><code>.middle</code>  只当点击鼠标中键时触发 </p></li><li><p><code>.passive</code>  不用查找是否阻止默认事件的请求直接进行操作。<br>  如在滚动页面时的 <code>onscroll</code> 事件，每次触发事件时浏览器都会查看是否有阻止默认滚动事件的操作，但是如果本来就没有进行这个操作，在滚动的时候就会出现卡的的情况，因为在触发滚动条滚动时总会先查找请求，这个修饰符就是告诉浏览器不用进行查找直接进行滚动操作。因为作用的冲突，所以不能和<code>.prevent</code> 一起使用</p></li></ul><p><strong>注意:</strong></p><ul><li><p>该指令有简写形式，通过<code>@</code>来代替 <code>v-on</code>:</p></li><li><p>该指令可以动态对绑定的参数进行改变，参数用中括号<code>[]</code>括起来</p><pre><code class="hljs">  &lt;!-- 方法处理器 --&gt;  &lt;button v-on:click=&quot;doThis&quot;&gt;&lt;/button&gt;    &lt;!-- 动态事件 (2.6.0+) --&gt;  &lt;button v-on:[event]=&quot;doThis&quot;&gt;&lt;/button&gt;    &lt;!-- 内联语句 --&gt;  &lt;button v-on:click=&quot;doThat(&#39;hello&#39;， $event)&quot;&gt;&lt;/button&gt;    &lt;!-- 缩写 --&gt;  &lt;button @click=&quot;doThis&quot;&gt;&lt;/button&gt;    &lt;!-- 动态事件缩写 (2.6.0+) --&gt;  &lt;button @[event]=&quot;doThis&quot;&gt;&lt;/button&gt;    &lt;!-- 停止冒泡 --&gt;  &lt;button @click.stop=&quot;doThis&quot;&gt;&lt;/button&gt;    &lt;!-- 阻止默认行为 --&gt;  &lt;button @click.prevent=&quot;doThis&quot;&gt;&lt;/button&gt;    &lt;!-- 阻止默认行为，没有表达式 --&gt;  &lt;form @submit.prevent&gt;&lt;/form&gt;    &lt;!--  串联修饰符 --&gt;  &lt;button @click.stop.prevent=&quot;doThis&quot;&gt;&lt;/button&gt;    &lt;!-- 键修饰符，键别名 --&gt;  &lt;input @keyup.enter=&quot;onEnter&quot;&gt;    &lt;!-- 键修饰符，键代码 --&gt;  &lt;input @keyup.13=&quot;onEnter&quot;&gt;    &lt;!-- 点击回调只会触发一次 --&gt;  &lt;button v-on:click.once=&quot;doThis&quot;&gt;&lt;/button&gt;    &lt;!-- 对象语法 (2.4.0+) --&gt;  &lt;button v-on=&quot;&#123; mousedown: doThis， mouseup: doThat &#125;&quot;&gt;&lt;/button&gt;    &lt;!-- 组件中的自定义事件 --&gt;  &lt;my-component @my-event=&quot;handleThis&quot;&gt;&lt;/my-component&gt;    &lt;!-- 内联语句 --&gt;  &lt;my-component @my-event=&quot;handleThis(123， $event)&quot;&gt;&lt;/my-component&gt;    &lt;!-- 组件中的原生事件 --&gt;  &lt;my-component @click.native=&quot;onClick&quot;&gt;&lt;/my-component&gt;</code></pre></li></ul><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p><code>v-model</code>，该指令用于表单内的标签进行双向的数据绑定 </p><p>**注意:**v-model 只能绑定给 <code>input</code>，<code>textarea</code>，<code>select</code> 等表单元素和自定义的组件中，除此之外不能在其他标签上绑定<br><strong>与<code>v-bind</code>的区别</strong>：</p><ul><li><code>v-bind</code>是单向绑定，而<code>v-model</code>是双向绑定；</li><li><code>v-bind</code>只能将<code>vue</code>中的数据同步到页面，而<code>v-model</code>不只能将<code>vue</code>中的数据同步到页面，还可以将用户数据的数据赋值给<code>vue</code>中的属性</li></ul><p><strong>修辞符</strong>: </p><ul><li><code>.lazy</code>  取代 input 监听 change 事件，默认在用户写入值时是使用的 <code>input</code> 事件，也就是当值输入完成后才会触发事件，而 change 是一些有输入法的语言在值还没有输入时就时刻监听改变 </li><li><code>.number</code> 输入字符串转为有效的数字 </li><li><code>.trim</code>  输入首尾空格过滤</li></ul><p><strong>用法</strong>: </p><ul><li><p><strong>如果是对 <code>input</code> 文本框和 <code>textarea</code> 绑定的</strong>，绑定的值会根据输入的内容，就是将内部的变量的值改为 value 中的值 </p></li><li><p>**如果是对复选框绑定的 **</p><ul><li><p><strong>如果绑定的变量不是数组</strong>，会根据复选框是否被选中而改变为 false 或 true，即使原来不是布尔值也会被强制转换为布尔值，这是因为双向的数据绑定，如果是有多个复选框，那么则会一起被选中或不选中 </p></li><li><p><strong>如果变量是数组</strong>，则会将 value 属性中的值(没有写 value 属性会传入 null)传入该数组作为其中的一个成员，Vue 会根据数组内部的值来判断是否选中该复选框(内部其实就是这样运作的)，如果 value 值一样会有多个复选框被选中，再次点击就会将该值删去然后取消复选框的选中</p>  <div id="example">      <input          type="checkbox"          id="jack"          value="Jack"          v-model="checkedNames"      />      <label for="jack">Jack</label>      <input          type="checkbox"          id="john"          value="John"          v-model="checkedNames"      />      <label for="john">John</label>      <input          type="checkbox"          id="mike"          value="Mike"          v-model="checkedNames"      />      <label for="mike">Mike</label>      <br />      <span>Checked names: </span>  </div>  <!--也可以在被选中和没被选择直接设置不同的值--><p>  <input  type="checkbox"  v-model="toggle"  true-value="yes"  false-value="no"  /></p>  <!--      当选中时 vm.toggle === 'yes' 当没有选中时 vm.toggle === 'no'      注意:点击了才会改变值，如果没有点击过而变量本身有值的话就不会是fasle-value的值  --></li></ul></li><li><p><strong>如果是对单选按钮进行绑定的</strong>，变量值会随着选中单选框的 <code>value</code> 值而变化，如果变量的值刚开始就是一个单选框的 <code>value</code> 值，那么就会自动选中这个单选框<br>  **注意: **</p><ul><li><p>单选框和复选框即使不写相同的 <code>name</code> 而只绑定了相同的 <code>modle</code> 也会认做是一类单选框的，但是最好还是将 <code>name</code> 写上 </p></li><li><p>单选框和复选框都可以通过 <code>v-bind:value</code> 绑定的 <code>value</code> 值来设置值自身的 <code>value</code> 值</p></li></ul></li><li><p>如果是对选择框 <code>select</code> 进行绑定的 ，绑定的变量的值会随着选中的 option 选项内部的内容而发生变化，如果 <code>option</code> 没有写 <code>value</code> 属性，该变量会变成<code>&lt;option&gt;&lt;/option&gt;</code>内部的值，如果有 <code>value</code> 属性，变量会变成 <code>value</code> 值而不是 <code>option</code> 的内容</p><pre><code class="hljs">  &lt;div id=&quot;example&quot;&gt;      &lt;select v-model=&quot;selected&quot;&gt;          &lt;option disabled value=&quot;&quot;&gt;请选择&lt;/option&gt;          &lt;option&gt;A&lt;/option&gt;          &lt;option&gt;B&lt;/option&gt;          &lt;option&gt;C&lt;/option&gt;      &lt;/select&gt;      &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;  &lt;/div&gt;  &lt;script&gt;      new Vue(&#123;          el: &#39;#example&#39;，          data: &#123;              selected: &#39;&#39;，          &#125;，      &#125;)  &lt;/script&gt;</code></pre></li></ul><p><strong>注意:</strong><br>在 s 多选时要绑定一个数组，将上方的 <code>selected:[]</code>，这样在选入的时候就能将每个选择的选项的值加到变量中去，还可以是一个对象，但是要通过 <code>v-bind:value</code> 绑定</p><h2 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h2><p>该指令不接受任何表达式，使用了该指令的元素 Vue 在编译时跳过这个元素和它的子元素的编译过程，可以用来显示原始的模板<code>&#123;&#123;&#125;&#125;</code>标签，跳过大量没有指令的节点会加快编译</p><h2 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h2><p>该指令不需要表达式，<code>只渲染元素和组件一次</code>。随后的重新渲染，元素&#x2F;组件及其所有的子节点将被视为静态内容并跳过。<br>以后数据的改变不会引起v-once所在结构的更新，这可以用于优化更新性能</p><ul><li>跳过其所在节点的编译过程。</li><li>可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 生命周期</title>
    <link href="/2022/09/17/vue/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2022/09/17/vue/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-生命周期"><a href="#Vue-生命周期" class="headerlink" title="Vue 生命周期"></a>Vue 生命周期</h1><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>又名：生命周期回调函数、生命周期函数、生命周期钩子。</p><p>是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。</p><p>生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。</p><p>生命周期函数中的this指向是vm 或 组件实例对象。</p><span id="more"></span><p><img src="/images/vue/vue_Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F_%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="vue生命周期"></p><h2 id="Vue-实例创建阶段"><a href="#Vue-实例创建阶段" class="headerlink" title="Vue 实例创建阶段"></a>Vue 实例创建阶段</h2><ul><li><p><code>var vm=new Vue()</code>，创建出一个 Vue 实例对象 </p></li><li><p><code>beforeCreat</code>，当 Vue 实例被完全创建出来之前，就会执行该函数，这是表示刚初始化了一个空的 Vue 对象，还未进行数据代理</p><p>  **注意:**在 beforeCreat 生命周期函数执行的时候，data 和 methods 等中的数据还没有初始化，所以在这里面调用这些 data 或 methods 等中的属性和方法会报错 </p></li><li><p><code>created</code>，在该函数中，<strong>data 和 methods 等数据已经被初始化好了</strong>，如果要调用 methods 中的方法或者 data 中的数据，最早只能在 created 中进行操作</p><p>  **注:**如果要发 Ajax 请求尽量在这个阶段发送 </p></li><li><p><strong>在这两个生命周期函数之间（create，beforeMount）进行 Vue 的编译模板</strong>，把 Vue 代码中的那些指令进行执行，最终在内存中生成一个编译好的最终模板字符串(虚拟 DOM)，然后把这个字符串渲染为内存中的 DOM，但是此时只是在内存中渲染 DOM，还没有将其挂载到页面中去 </p></li><li><p><code>beforeMount</code>，在该函数中模板已经在内存中了，但是还没有把模板渲染到页面中，也就是说<code>&#123;&#123;&#125;&#125;</code>中的内容还没有被解析，页面中的元素还没有真正被替换，只是写了一些模板字符串 将内存中的 DOM 挂载到页面中去 </p></li><li><p><code>mounted</code>，表示内存中的 DOM 已经挂载到页面中了，用户已经可以看到渲染好的页面了 </p><p>  注意: mounted 是实例创建期间执行的最后一个生命周期函数，当执行完 mounted 就表示实例已经完全被创建好了 如果要通过某些插件操作页面上的 DOM 节点，最早要在 mounted 中进行</p></li></ul><h2 id="Vue-实例运行阶段"><a href="#Vue-实例运行阶段" class="headerlink" title="Vue 实例运行阶段"></a>Vue 实例运行阶段</h2><p><strong>下面两个生命周期必须要数据发生改变时才会进行，会根据 data 数据的改变触发 0 次或多次</strong></p><ul><li><p><code>beforeUpdate</code>，这个函数表明 Vue 实例在运行时数据已经被更新，而页面还没有被更新的时间节点，当执行该函数时，页面中显示的数据还是没有更新前的数据，而 data 中的数据是最新的，页面还没有和数据实现同步 </p></li><li><p>**在这两个函数之间(beforeUpdate， updated)**，会根据 data 中的最新数据，重新渲染出一份最新的内存 DOM 树(虚拟DOM)，当最新的内存 DOM 树被更新之后，会把最新的内存 DOM 树重新渲染到真实的页面中去，完成数据从 data 到页面视图的更新 </p></li><li><p><code>updated</code>，当这个函数执行时证明 data 中的数据已经和页面中的数据保存同步更新了</p></li></ul><h2 id="Vue-实例销毁阶段"><a href="#Vue-实例销毁阶段" class="headerlink" title="Vue 实例销毁阶段"></a>Vue 实例销毁阶段</h2><ul><li><code>beforeDestroy</code>， 当执行该函数时，Vue 实例就已经从运行阶段进入到了销毁阶段，实例上的所以属性如 data，methods 等都还是处于可用状态，还没有真正的执行销毁 </li><li></li><li><code>destroyed</code>，当执行到该函数时，Vue 实例已经被完全销毁，此时所有实例中的属性都不可用了</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li><p>常用的生命周期钩子：</p><ol><li><code>mounted</code>: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。</li><li><code>beforeDestroy</code>: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。</li></ol></li><li><p>关于销毁Vue实例</p><ol><li>销毁后借助Vue开发者工具看不到任何信息。</li><li>销毁后自定义事件会失效，但原生DOM事件依然有效。</li><li>一般不会在<code>beforeDestroy</code>操作数据，因为即便操作数据，也不会再触发更新流程了。</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue实例对象</title>
    <link href="/2022/07/29/vue/Vue%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/07/29/vue/Vue%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue实例对象"><a href="#Vue实例对象" class="headerlink" title="Vue实例对象"></a>Vue实例对象</h1><h2 id="创建并绑定-Vue-对象"><a href="#创建并绑定-Vue-对象" class="headerlink" title="创建并绑定 Vue 对象"></a>创建并绑定 Vue 对象</h2><p>Vue 也是一个构造函数,通过 <code>new Vue()</code>可以创建一个 Vue 对象,通过 Vue 对象进行对 DOM 元素以及内部的子孙元素的操作</p><pre><code class="hljs">    new Vue(&#123;        el: &#39;#div&#39;,        /*        在Vue中通过el属性来绑定一个DOM元素,从而让该DOM元素以及内部都绑定Vue的相关操作,一般是通过ID进行查找,因为这样才能够精确绑定        */        data: &#123;            //data属性中包含着在el中使用的使用的变量或属性            msg: 123,        &#125;,        //也可以使用函数形式的        data() &#123;            return &#123;                msg: 123,            &#125;        &#125;,        //methods属性包含着需要使用的方法        methods: &#123;            show() &#123;                console.log(this.msg)            &#125;,        &#125;,    &#125;)</code></pre><p><strong>注:在实例内部使用定义的属性或方法时不能直接使用,必须通过 <code>this</code> 来指定需要用的属性</strong></p><span id="more"></span><h2 id="vue-实例中的参数与选项"><a href="#vue-实例中的参数与选项" class="headerlink" title="vue 实例中的参数与选项"></a>vue 实例中的参数与选项</h2><ul><li><p><code>el:&quot;#id&quot;</code>, &#x2F;&#x2F;DOM 成员（1&#x2F;3）<br>  提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。</p></li><li><p><code>template:&quot;&lt;tag&gt;&lt;/tag&gt;&quot;</code>, &#x2F;&#x2F;DOM 成员（2&#x2F;3）<br>  一个字符串模板作为 Vue 实例的标识使用。模板将会 替换 挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发 </p></li><li><p><code>slot render: (h)=&gt;&#123;h(App)&#125;</code>, &#x2F;&#x2F;DOM 成员（3&#x2F;3）<br>  字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。 </p><pre><code class="hljs">  // 原理   render: (h) =&gt; &#123;       return &lt;APP&gt;&lt;/APP&gt;  &#125; // 可以代替components和template</code></pre></li><li><p><code>data</code> &#x2F;&#x2F;数据成员（1&#x2F;6） </p><pre><code class="hljs">  data():&#123; return&#123; &#125; &#125;</code></pre><p>  Vue 实例的数据对象。Vue 将会递归将 <code>data</code> 的属性转换为 <code>getter/setter</code>，从而让 <code>data</code> 的属性能够响应数据变化</p></li><li><p><code>methods</code> &#x2F;&#x2F;数据成员（2&#x2F;6） </p><pre><code class="hljs">  methods:&#123; func()&#123; &#125; &#125; </code></pre><p>  <code>methods</code> 将被混入到 Vue 实例中，可以直接通过 <code>VM</code> 实例访问这些方法，或者在指令表达式中使用 方法中的 <code>this</code> 自动绑定为 Vue 实例</p></li><li><p><code>watch</code> &#x2F;&#x2F;数据成员（3&#x2F;6） </p><pre><code class="hljs">  watch: &#123;       key: value,      $route(newValue, oldValue) &#123;//监控路由&#125;   &#125;</code></pre><p>  Vue的监视属性，整个为一个对象，键是需要观察的表达式，值是对应回调函数 </p></li><li><p><code>computed</code> &#x2F;&#x2F;数据成员（4&#x2F;6） </p><pre><code class="hljs">  computed: &#123;      getTotalCount() &#123;          const totalCount = 0          return totalCount      &#125;,  &#125;</code></pre><p>  vue 的计算属性，将被混入到 Vue 实例中。所有 <code>getter</code> 和 <code>setter</code> 的 <code>this</code> 上下文自动地绑定为 Vue 实例 </p></li><li><p><code>props</code> &#x2F;&#x2F;数据成员（5&#x2F;6） </p><pre><code class="hljs">  props:[&#39;counts&#39;,&#39;ids&#39;]</code></pre><p>  用于父子组件的 <code>eventbus</code> 传值，是数组或对象，<code>props</code> 的成员是子组件接收的来自父组件的数据 </p></li><li><p><code>propsData</code> &#x2F;&#x2F;数据成员（6&#x2F;6）<br>  创建实例时传递 <code>props</code>。主要作用是方便测试。基本不使用。</p></li><li><p><code>filters</code> &#x2F;&#x2F;资源（1&#x2F;3） </p><pre><code class="hljs">  filters(      &#39;filterName&#39;,      (input,      function () &#123;          return newvalue      &#125;)  )</code></pre><p>  包含 Vue 实例可用过滤器的哈希表。 </p></li><li><p><code>directives</code> &#x2F;&#x2F;资源（2&#x2F;3）<br>  包含 Vue 实例可用指令的哈希表。 </p></li><li><p><code>components</code> &#x2F;&#x2F;资源（3&#x2F;3）<br>  （即该组件的子实例）这里是包含 Vue 实例可用组件的哈希表。 </p></li><li><p><code>name</code> &#x2F;&#x2F;杂项（1&#x2F;6）<br>  允许组件模板递归地调用自身。注意，组件在全局用 <code>Vue.component()</code> 注册时，全局 ID 自动作为组件的 <code>name</code>。</p></li><li><p><code>parent</code> &#x2F;&#x2F;杂项（2&#x2F;6）<br>  指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 <code>this.$parent</code> 访问父实例，子实例被推入父实例的 <code>$children</code> 数组中。 </p></li><li><p><code>mixins</code> &#x2F;&#x2F;杂项（3&#x2F;6）<br>  <code>mixins</code> 选项接受一个混合对象的数组。Mixin 钩子按照传入顺序依次调用,并在调用组件自身的钩子之前被调用。 </p></li><li><p><code>extends</code> &#x2F;&#x2F;杂项（4&#x2F;6）<br>  允许声明扩展另一个组件。这主要是为了便于扩展单文件组件。这和 <code>mixins</code> 类似，区别在于，组件自身的选项会比要扩展的源组件具有更高的优先级。 </p></li><li><p><code>delimiters</code> &#x2F;&#x2F;杂项（5&#x2F;6）<br>  改变纯文本插入分隔符。 </p></li><li><p><code>functional</code> &#x2F;&#x2F;杂项（6&#x2F;6）<br>  使组件无状态（没有 <code>data</code> ）和无实例（没有 <code>this</code> 上下</p></li></ul><h2 id="常用指令实例"><a href="#常用指令实例" class="headerlink" title="常用指令实例"></a>常用指令实例</h2><pre><code class="hljs">    &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;en&quot;&gt;        &lt;head&gt;            &lt;meta charset=&quot;UTF-8&quot; /&gt;            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;            &lt;title&gt;startVue&lt;/title&gt;        &lt;/head&gt;        &lt;body&gt;            &lt;div id=&quot;app&quot;&gt;                &lt;!-- &#123;&#123;&#125;&#125;双大括号表达式，里面是js代码 --&gt;                &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;                &lt;!-- 相当于innerText --&gt;                &lt;p v-text=&quot;str&quot;&gt;&lt;/p&gt;                &lt;!-- 相当于innerHTML --&gt;                &lt;p v-html=&quot;str&quot;&gt;&lt;/p&gt;                &lt;!-- 强制绑定事件, 一般用于用于响应式地更新HTML attribute, 简写方式:                从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数                &lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;                这里的 attributeName 会被作为一个 JavaScript 表达式进行动态求值,求得的值将会作为最终的参数来使用。                例如，如果你的 Vue 实例有一个 data 属性 attributeName，其值为 &quot;href&quot;                那么这个绑定将等价于 v-bind:href--&gt;                &lt;a v-bind:href=&quot;url&quot;&gt;Baidu&lt;/a&gt;                &lt;!-- 绑定事件监听,监听 DOM 事件, 简写方式@ --&gt;                &lt;button v-on:click=&quot;test&quot;&gt;Submit&lt;/button&gt;                &lt;!-- 双向绑定事件,动态实时更新里面的内容 --&gt;                &lt;div&gt;                    &lt;input type=&quot;text&quot; v-model=&quot;input&quot; placeholder=&quot;Please input&quot; /&gt;                    &lt;p&gt;&#123;&#123; input &#125;&#125;&lt;/p&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/body&gt;        &lt;script text=&quot;javascript&quot; src=&quot;./vue.js&quot;&gt;&lt;/script&gt;        &lt;script text=&quot;javascript&quot;&gt;            const app = new Vue(&#123;                //要挂载的位置                //在Vue中通过el属性来绑定一个DOM元素,从而让该DOM元素以及内部都绑定Vue的相关操作                //一般是通过ID进行查找,因为这样才能够精确绑定                el: &#39;#app&#39;, // data属性中包含着在el中使用的使用的变量或属性                data: &#123;                    msg: &#39;xhw&#39;,                    str: &#39;&lt;a href=&quot;#&quot;&gt;XHW&lt;/a&gt;&#39;,                    url: &#39;https://www.baidu.com&#39;,                    input: &#39;&#39;,                &#125;, // methods属性包含着需要使用的方法                /**                 * 也可以写成(以组件形式里必须写成这个)                 * data() &#123;                 *     return &#123;                 *                 * &#125;                 * &#125;,                 */ methods: &#123;                    test() &#123;                        alert(&#39;!!!&#39;)                    &#125;,                &#125;,            &#125;)        &lt;/script&gt;    &lt;/html&gt;</code></pre><h2 id="vm-mount"><a href="#vm-mount" class="headerlink" title="vm.$mount"></a><code>vm.$mount</code></h2><p>如果 Vue 实例在实例化时没有收到 <code>el</code> 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 <code>vm.$mount()</code> 手动地挂载一个未挂载的实例</p><p>**注意:**这个方法返回实例自身,因而可以链式调用其它实例方法</p><pre><code class="hljs">    var MyComponent = Vue.extend(&#123; template: &#39;&lt;div&gt;Hello!&lt;/div&gt;&#39; &#125;) // 创建并挂载到 #app (会替换 #app)    new MyComponent().$mount(&#39;#app&#39;) // 同上    new MyComponent(&#123; el: &#39;#app&#39; &#125;) // 或者，在文档之外渲染并且随后挂载 var    component = new MyComponent().$mount()    document.getElementById(&#39;app&#39;).appendChild(component.$el)</code></pre>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串的扩展</title>
    <link href="/2022/07/26/ES6/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <url>/2022/07/26/ES6/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h1><h2 id="字符的-Unicode-表示法"><a href="#字符的-Unicode-表示法" class="headerlink" title="字符的 Unicode 表示法"></a>字符的 Unicode 表示法</h2><p>JavaScript 允许采用<code>\uxxxx</code>形式表示一个字符，其中<code>xxxx</code>表示字符的 Unicode 码点。</p><pre><code class="hljs">    &#39;\u0061&#39;    // &quot;a&quot;</code></pre><p>但是，这种表示法只限于码点在<code>\u0000~\uFFFF</code>之间的字符。超出这个范围的字符，必须用两个双字节的形式表示</p><span id="more"></span><p>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符</p><pre><code class="hljs">    &#39;\u&#123;20BB7&#125;&#39;    // &quot;𠮷&quot;    &#39;\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;&#39;    // &quot;ABC&quot;    let hello = 123    hello // 123    &#39;\u&#123;1F680&#125;&#39; === &#39;\uD83D\uDE80&#39;    // true</code></pre><p>上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。</p><p>有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符</p><pre><code class="hljs">    &#39;z&#39; === &#39;z&#39; // true    &#39;\172&#39; === &#39;z&#39; // true    &#39;\x7A&#39; === &#39;z&#39; // true    &#39;\u007A&#39; === &#39;z&#39; // true    &#39;\u&#123;7A&#125;&#39; === &#39;z&#39; // true</code></pre><h2 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt()"></a>codePointAt()</h2><p>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符(Unicode 码点大于<code>0xFFFF</code>的字符)，JavaScript 会认为它们是两个字符</p><pre><code class="hljs">    var s = &#39;𠮷&#39;    s.length // 2    s.charAt(0) // &#39;&#39;    s.charAt(1) // &#39;&#39;    s.charCodeAt(0) // 55362    s.charCodeAt(1) // 57271</code></pre><p>上面代码中，汉字“𠮷”(注意，这个字不是“吉祥”的“吉”)的码点是<code>0x20BB7</code>，UTF-16 编码为<code>0xD842 0xDFB7</code>(十进制为<code>55362 57271</code>)，需要4个字节储存。对于这种4个字节的字符，JavaScript 不能正确处理，字符串长度会误判为2，而且<code>charAt</code>方法无法读取整个字符，<code>charCodeAt</code>方法只能分别返回前两个字节和后两个字节的值</p><p>ES6 提供了<code>codePointAt</code>方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。</p><pre><code class="hljs">    let s = &#39;𠮷a&#39;    s.codePointAt(0) // 134071    s.codePointAt(1) // 57271    s.codePointAt(2) // 97</code></pre><p><code>codePointAt</code>方法的参数，是字符在字符串中的位置(从 0 开始)。上面代码中，JavaScript 将“<code>𠮷 a</code>”视为三个字符，<code>codePointAt</code> 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 <code>134071</code>(即十六进制的<code>20BB7</code>)。在第二个字符(即“𠮷”的后两个字节)和第三个字符“a”上，<code>codePointAt</code>方法的结果与<code>charCodeAt</code>方法相同。 </p><p>总之，<code>codePointAt</code>方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt方法相同。 </p><p><code>codePointAt</code>方法返回的是码点的十进制值，如果想要十六进制的值，可以使用<code>toString</code>方法转换一下。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">let s = <span class="hljs-string">&#x27;𠮷a&#x27;</span><br><br>s<span class="hljs-selector-class">.codePointAt</span>(<span class="hljs-number">0</span>)<span class="hljs-selector-class">.toString</span>(<span class="hljs-number">16</span>) <span class="hljs-comment">// &quot;20bb7&quot;</span><br>s<span class="hljs-selector-class">.codePointAt</span>(<span class="hljs-number">2</span>)<span class="hljs-selector-class">.toString</span>(<span class="hljs-number">16</span>) <span class="hljs-comment">// &quot;61&quot;</span><br></code></pre></td></tr></table></figure><p>您可能注意到了，<code>codePointAt</code>方法的参数，仍然是不正确的。比如，上面代码中，字符a在字符串s的正确位置序号应该是 1，但是必须向<code>codePointAt</code>方法传入 2。解决这个问题的一个办法是使用<code>for...of</code>循环，因为它会正确识别 32 位的 UTF-16 字符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;𠮷a&#x27;</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> ch <span class="hljs-keyword">of</span> s) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ch.<span class="hljs-title function_">codePointAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>))<br>&#125;<br><span class="hljs-comment">// 20bb7</span><br><span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure><h2 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h2><p>ES5 提供<code>String.fromCharCode</code>方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字符(Unicode 编号大于<code>0xFFFF</code>)。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">String.<span class="hljs-built_in">fromCharCode</span>(<span class="hljs-number">0x20bb7</span>)<br><span class="hljs-comment">// &quot;ஷ&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>String.fromCharCode</code>不能识别大于<code>0xFFFF</code>的码点，所以<code>0x20BB7</code>就发生了溢出，最高位2被舍弃了，最后返回码点<code>U+0BB7</code>对应的字符，而不是码点<code>U+20BB7</code>对应的字符。 </p><p>ES6 提供了<code>String.fromCodePoint</code>方法，可以识别大于<code>0xFFFF</code>的字符，弥补了<code>String.fromCharCode</code>方法的不足。在作用上，正好与<code>codePointAt</code>方法相反。</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-title class_">String</span>.<span class="hljs-property">fromCodePoint</span>(<span class="hljs-number">0x20bb7</span>)<br><span class="hljs-comment">// &quot;𠮷&quot;</span><br><span class="hljs-title class_">String</span>.<span class="hljs-property">fromCodePoint</span>(<span class="hljs-number">0x78</span>, <span class="hljs-number">0x1f680</span>, <span class="hljs-number">0x79</span>) <span class="hljs-operator">==</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;x<span class="hljs-char escape_">\uD83D</span><span class="hljs-char escape_">\uDE80</span>y&quot;</span><br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，如果<code>String.fromCodePoint</code>方法有多个参数，则它们会被合并成一个字符串返回。 </p><p>注意，<code>fromCodePoint</code>方法定义在<code>String</code>对象上，而<code>codePointAt</code>方法定义在字符串的实例对象上</p><h2 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h2><p>ES6 为字符串添加了遍历器接口，使得字符串可以被<code>for...of</code>循环遍历。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">for</span> (let codePoint of <span class="hljs-string">&#x27;foo&#x27;</span>) &#123;<br>    console.log(codePoint)<br>&#125;<br><span class="hljs-regexp">//</span> <span class="hljs-string">&quot;f&quot;</span><br><span class="hljs-regexp">//</span> <span class="hljs-string">&quot;o&quot;</span><br><span class="hljs-regexp">//</span> <span class="hljs-string">&quot;o&quot;</span><br></code></pre></td></tr></table></figure><p>除了遍历字符串，这个遍历器最大的优点是可以识别大于<code>0xFFFF</code>的码点，传统的<code>for</code>循环无法识别这样的码点</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let <span class="hljs-built_in">text</span> = String.<span class="hljs-built_in">fromCodePoint</span>(<span class="hljs-number">0x20bb7</span>)<br><br><span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">text</span>.<span class="hljs-built_in">length</span>; i++) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">text</span>[i])<br>&#125;<br><span class="hljs-comment">// &quot; &quot;</span><br><span class="hljs-comment">// &quot; &quot;</span><br><br><span class="hljs-keyword">for</span> (let i <span class="hljs-keyword">of</span> <span class="hljs-built_in">text</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(i)<br>&#125;<br><span class="hljs-comment">// &quot;𠮷&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，字符串<code>text</code>只有一个字符，但是<code>for</code>循环会认为它包含两个字符(都不可打印)，而<code>for...of</code>循环会正确识别出这一个字符</p><h2 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(), startsWith(), endsWith()"></a>includes(), startsWith(), endsWith()</h2><p>传统上，JavaScript 只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。<br>ES6 又提供了三种新方法。 </p><ul><li><p><code>includes()</code>: 返回布尔值，表示是否找到了参数字符串。 </p></li><li><p><code>startsWith()</code>: 返回布尔值，表示参数字符串是否在原字符串的头部。 </p></li><li><p><code>endsWith()</code>: 返回布尔值，表示参数字符串是否在原字符串的尾部</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">let s = <span class="hljs-string">&#x27;Hello world!&#x27;</span><br><br>s<span class="hljs-selector-class">.startsWith</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>) <span class="hljs-comment">// true</span><br>s<span class="hljs-selector-class">.endsWith</span>(<span class="hljs-string">&#x27;!&#x27;</span>) <span class="hljs-comment">// true</span><br>s<span class="hljs-selector-class">.includes</span>(<span class="hljs-string">&#x27;o&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ul><p>这三个方法都支持第二个参数，表示开始搜索的位置</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">let s = <span class="hljs-string">&#x27;Hello world!&#x27;</span><br><br>s<span class="hljs-selector-class">.startsWith</span>(<span class="hljs-string">&#x27;world&#x27;</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// true</span><br>s<span class="hljs-selector-class">.endsWith</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// true</span><br>s<span class="hljs-selector-class">.includes</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码表示，使用第二个参数n时，<code>endsWith</code>的行为与其他两个方法有所不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束</p><h2 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h2><p><code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;x&#x27;</span>.repeat(<span class="hljs-number">3</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;xxx&quot;</span><br><span class="hljs-string">&#x27;hello&#x27;</span>.repeat(<span class="hljs-number">2</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;hellohello&quot;</span><br><span class="hljs-string">&#x27;na&#x27;</span>.repeat(<span class="hljs-number">0</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>参数如果是小数，会被取整。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">&quot;na&quot;</span><span class="hljs-string">.repeat</span><span class="hljs-params">(2.9)</span> <span class="hljs-string">//</span> <span class="hljs-string">&quot;nana&quot;</span><br></code></pre></td></tr></table></figure><p>如果<code>repeat</code>的参数是负数或者<code>Infinity</code>，会报错</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-string">&#x27;na&#x27;</span>.repeat(<span class="hljs-keyword">Infinity</span>)<br>// RangeError<br><span class="hljs-string">&#x27;na&#x27;</span>.repeat(<span class="hljs-number">-1</span>)<br>// RangeError<br></code></pre></td></tr></table></figure><p>但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，<code>repeat</code>视同为 0</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">&quot;na&quot;</span><span class="hljs-string">.repeat</span><span class="hljs-params">(-0.9)</span> <span class="hljs-string">//</span> <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>参数NaN等同于 0。 </p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-string">&quot;na&quot;</span>.<span class="hljs-keyword">repeat</span>(<span class="hljs-symbol">NaN</span>) <span class="hljs-comment">// &quot;&quot;</span><br></code></pre></td></tr></table></figure><p>如果<code>repeat</code>的参数是字符串，则会先转换成数字。 </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;na&quot;</span>.repeat(<span class="hljs-string">&quot;na&quot;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-string">&quot;na&quot;</span>.repeat(<span class="hljs-string">&quot;3&quot;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;nanana&quot;</span><br></code></pre></td></tr></table></figure><h2 id="padStart-，padEnd"><a href="#padStart-，padEnd" class="headerlink" title="padStart()，padEnd()"></a>padStart()，padEnd()</h2><p>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。<br><code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;x&quot;</span>.padStart(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;ab&quot;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;ababx&#x27;</span><br><span class="hljs-string">&quot;x&quot;</span>.padStart(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;ab&quot;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;abax&#x27;</span><br><br><span class="hljs-string">&quot;x&quot;</span>.padEnd(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;ab&quot;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;xabab&#x27;</span><br><span class="hljs-string">&quot;x&quot;</span>.padEnd(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;ab&quot;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;xaba&#x27;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>padStart</code>和<code>padEnd</code>一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。</p><p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;xxx&#x27;</span>.padStart(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;xxx&#x27;</span><br><span class="hljs-string">&#x27;xxx&#x27;</span>.padEnd(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;xxx&#x27;</span><br></code></pre></td></tr></table></figure><p>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#x27;abc&#x27;.padStart<span class="hljs-punctuation">(</span><span class="hljs-number">10</span><span class="hljs-punctuation">,</span> &#x27;<span class="hljs-number">0123456789</span>&#x27;<span class="hljs-punctuation">)</span><br><span class="hljs-comment">// &#x27;0123456abc&#x27;</span><br></code></pre></td></tr></table></figure><p>如果省略第二个参数，默认使用空格补全长度</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;x&#x27;</span>.padStart(<span class="hljs-number">4</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;   x&#x27;</span><br><span class="hljs-string">&#x27;x&#x27;</span>.padEnd(<span class="hljs-number">4</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;x   &#x27;</span><br></code></pre></td></tr></table></figure><p><code>padStart</code>的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;1&#x27;</span>.padStart(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;0000000001&quot;</span><br><span class="hljs-string">&#x27;12&#x27;</span>.padStart(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;0000000012&quot;</span><br><span class="hljs-string">&#x27;123456&#x27;</span>.padStart(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;0000123456&quot;</span><br></code></pre></td></tr></table></figure><p>另一个用途是提示字符串格式。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;12&#x27;</span>.padStart(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;YYYY-MM-DD&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;YYYY-MM-12&quot;</span><br><span class="hljs-string">&#x27;09-12&#x27;</span>.padStart(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;YYYY-MM-DD&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;YYYY-09-12&quot;</span><br></code></pre></td></tr></table></figure><h2 id="matchAll"><a href="#matchAll" class="headerlink" title="matchAll()"></a>matchAll()</h2><p><code>matchAll</code>方法返回一个正则表达式在当前字符串的所有匹配</p><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>传统的 JavaScript 语言，输出模板通常是这样写的(下面使用了 jQuery 的方法)。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$(<span class="hljs-string">&#x27;#result&#x27;</span>)<span class="hljs-selector-class">.append</span>(<br>    <span class="hljs-string">&#x27;There are &lt;b&gt;&#x27;</span> +<br>        basket<span class="hljs-selector-class">.count</span> +<br>        <span class="hljs-string">&#x27;&lt;/b&gt; &#x27;</span> +<br>        <span class="hljs-string">&#x27;items in your basket, &#x27;</span> +<br>        <span class="hljs-string">&#x27;&lt;em&gt;&#x27;</span> +<br>        basket<span class="hljs-selector-class">.onSale</span> +<br>        <span class="hljs-string">&#x27;&lt;/em&gt; are on sale!&#x27;</span><br>)<br></code></pre></td></tr></table></figure><p>上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim">$(<span class="hljs-string">&#x27;#result&#x27;</span>).<span class="hljs-keyword">append</span>(`<br>    There are <span class="hljs-symbol">&lt;b&gt;</span>$&#123;basket.<span class="hljs-built_in">count</span>&#125;&lt;/<span class="hljs-keyword">b</span>&gt; <span class="hljs-built_in">items</span><br>    in your basket, <span class="hljs-symbol">&lt;em&gt;</span>$&#123;basket.onSale&#125;&lt;/<span class="hljs-keyword">em</span>&gt;<br>    are <span class="hljs-keyword">on</span> sale!<br>`)<br></code></pre></td></tr></table></figure><p>模板字符串(template string)是增强版的字符串，用反引号(&#96;&#96;&#96;)标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade">  <span class="hljs-comment">// 普通字符串</span><br>  ;<span class="hljs-string">`In JavaScript &#x27;\n&#x27; is a line-feed.`</span> <span class="hljs-comment">// 多行字符串</span><br>  <span class="hljs-string">`In JavaScript this is not legal.`</span><br><br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`string text line 1 string text line 2`</span>)<br><br>  <span class="hljs-comment">// 字符串中嵌入变量</span><br>  let name = <span class="hljs-string">&#x27;Bob&#x27;</span>,<br>      <span class="hljs-built_in">time</span> = <span class="hljs-string">&#x27;today&#x27;</span><br>  ;<span class="hljs-string">`Hello <span class="hljs-subst">$&#123;name&#125;</span>, how are you <span class="hljs-subst">$&#123;<span class="hljs-built_in">time</span>&#125;</span>?`</span> <br><span class="hljs-comment">// Hello Bob, how are you today?</span><br></code></pre></td></tr></table></figure><p>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">let greeting = `\`Yo\` World!`<br></code></pre></td></tr></table></figure><p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">$(<span class="hljs-string">&quot;#list&quot;</span>).html(`<br><span class="hljs-variable">&lt;ul&gt;</span><br>  <span class="hljs-variable">&lt;li&gt;</span>first<span class="hljs-variable">&lt;/li&gt;</span><br>  <span class="hljs-variable">&lt;li&gt;</span>second<span class="hljs-variable">&lt;/li&gt;</span><br><span class="hljs-variable">&lt;/ul&gt;</span><br>`)<br></code></pre></td></tr></table></figure><p>上面代码中，所有模板字符串的空格和换行，都是被保留的，比如<code>&lt;ul&gt;</code>标签前面会有一个换行。如果您不想要这个换行，可以使用<code>trim</code>方法消除它</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">$(<span class="hljs-string">&quot;#list&quot;</span>).html(<br>  `<br><span class="hljs-variable">&lt;ul&gt;</span><br>  <span class="hljs-variable">&lt;li&gt;</span>first<span class="hljs-variable">&lt;/li&gt;</span><br>  <span class="hljs-variable">&lt;li&gt;</span>second<span class="hljs-variable">&lt;/li&gt;</span><br><span class="hljs-variable">&lt;/ul&gt;</span><br>`.trim()<br>)<br></code></pre></td></tr></table></figure><p>模板字符串中嵌入变量，需要将变量名写在<code>$&#123;&#125;</code>之中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">authorize</span>(<span class="hljs-params">user, action</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!user.<span class="hljs-title function_">hasPrivilege</span>(action)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<br>            <span class="hljs-comment">// 传统写法为</span><br>            <span class="hljs-comment">// &#x27;User &#x27;</span><br>            <span class="hljs-comment">// + user.name</span><br>            <span class="hljs-comment">// + &#x27; is not authorized to do &#x27;</span><br>            <span class="hljs-comment">// + action</span><br>            <span class="hljs-comment">// + &#x27;.&#x27;</span><br>            <span class="hljs-string">`User <span class="hljs-subst">$&#123;user.name&#125;</span> is not authorized to do <span class="hljs-subst">$&#123;action&#125;</span>.`</span><br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gml">let <span class="hljs-variable language_">x</span> = <span class="hljs-number">1</span><br>let <span class="hljs-variable language_">y</span> = <span class="hljs-number">2</span><br><br>;`$&#123;<span class="hljs-variable language_">x</span>&#125; + $&#123;<span class="hljs-variable language_">y</span>&#125; = $&#123;<span class="hljs-variable language_">x</span> + <span class="hljs-variable language_">y</span>&#125;` <span class="hljs-comment">// &quot;1 + 2 = 3&quot;</span><br>`$&#123;<span class="hljs-variable language_">x</span>&#125; + $&#123;<span class="hljs-variable language_">y</span> * <span class="hljs-number">2</span>&#125; = $&#123;<span class="hljs-variable language_">x</span> + <span class="hljs-variable language_">y</span> * <span class="hljs-number">2</span>&#125;`<br><span class="hljs-comment">// &quot;1 + 4 = 5&quot;</span><br><br>let obj = &#123; <span class="hljs-variable language_">x</span>: <span class="hljs-number">1</span>, <span class="hljs-variable language_">y</span>: <span class="hljs-number">2</span> &#125;<br>;`$&#123;obj.<span class="hljs-variable language_">x</span> + obj.<span class="hljs-variable language_">y</span>&#125;`<br><span class="hljs-comment">// &quot;3&quot;</span><br></code></pre></td></tr></table></figure><p>模板字符串之中还能调用函数。</p><pre><code class="hljs">    function fn() &#123;        return &#39;Hello World&#39;    &#125;    ;`foo $&#123;fn()&#125; bar`    // foo Hello World bar</code></pre><p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的<code>toString</code>方法</p><p>如果模板字符串中的变量没有声明，将报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 变量place没有声明</span><br><span class="hljs-keyword">let</span> msg = <span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;place&#125;</span>`</span><br><span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><p>由于模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-string">`Hello <span class="hljs-subst">$&#123;<span class="hljs-string">&quot;World&quot;</span>&#125;</span>`</span><br><span class="hljs-comment">// &quot;Hello World&quot;</span><br></code></pre></td></tr></table></figure><h2 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h2><p>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能(tagged template)。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">alert`<span class="hljs-number">123</span>`<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-function"><span class="hljs-title">alert</span><span class="hljs-params">(<span class="hljs-number">123</span>)</span></span><br></code></pre></td></tr></table></figure><p>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。 </p><p>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-number">10</span><br><br>tag<span class="hljs-string">`Hello <span class="hljs-subst">$&#123;a + b&#125;</span> world <span class="hljs-subst">$&#123;a * b&#125;</span>`</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-title function_">tag</span>([<span class="hljs-string">&#x27;Hello &#x27;</span>, <span class="hljs-string">&#x27; world &#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>], <span class="hljs-number">15</span>, <span class="hljs-number">50</span>)<br></code></pre></td></tr></table></figure><p>上面代码中，模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。</p><p>函数<code>tag</code>依次会接收到多个参数。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">tag</span><span class="hljs-params">(stringArr, value1, value2)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 等同于</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">tag</span><span class="hljs-params">(stringArr, <span class="hljs-rest_arg">...values</span>)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>tag</code>函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。 </p><p><code>tag</code>函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此<code>tag</code>会接受到<code>value1</code>和<code>value2</code>两个参数。</p><p><code>tag</code>函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。 </p><p><code>tag</code>函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此<code>tag</code>会接受到<code>value1</code>和<code>value2</code>两个参数。 </p><p>tag函数所有参数的实际值如下。 </p><ul><li>第一个参数: [‘Hello ‘, ‘ world ‘, ‘’] </li><li>第二个参数: 15 </li><li>第三个参数: 50</li></ul><p>也就是说，tag函数实际上以下面的形式调用。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">tag</span><span class="hljs-params">([<span class="hljs-string">&quot;Hello &quot;</span>, <span class="hljs-string">&quot; world &quot;</span>, <span class="hljs-string">&quot;&quot;</span>], <span class="hljs-number">15</span>, <span class="hljs-number">50</span>)</span></span><br></code></pre></td></tr></table></figure><p>我们可以按照需要编写<code>tag</code>函数的代码。下面是<code>tag</code>函数的一种写法，以及运行结果。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let a = <span class="hljs-number">5</span><br>let b = <span class="hljs-number">10</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">tag</span>(<span class="hljs-params">s, v1, v2</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(s[<span class="hljs-number">0</span>])<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(s[<span class="hljs-number">1</span>])<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(s[<span class="hljs-number">2</span>])<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(v1)<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(v2)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;OK&#x27;</span><br>&#125;<br><br>tag<span class="hljs-string">`Hello <span class="hljs-subst">$&#123;a + b&#125;</span> world <span class="hljs-subst">$&#123;a * b&#125;</span>`</span><br><span class="hljs-comment">// &quot;Hello &quot;</span><br><span class="hljs-comment">// &quot; world &quot;</span><br><span class="hljs-comment">// &quot;&quot;</span><br><span class="hljs-comment">// 15</span><br><span class="hljs-comment">// 50</span><br><span class="hljs-comment">// &quot;OK&quot;</span><br></code></pre></td></tr></table></figure><p>“标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> message = <span class="hljs-title class_">SaferHTML</span><span class="hljs-string">`&lt;p&gt;<span class="hljs-subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SaferHTML</span>(<span class="hljs-params">templateData</span>) &#123;<br>    <span class="hljs-keyword">let</span> s = templateData[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">let</span> arg = <span class="hljs-title class_">String</span>(<span class="hljs-variable language_">arguments</span>[i])<br><br>        <span class="hljs-comment">// Escape special characters in the substitution.</span><br>        s += arg<br>            .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&amp;/g</span>, <span class="hljs-string">&#x27;&amp;amp;&#x27;</span>)<br>            .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&lt;/g</span>, <span class="hljs-string">&#x27;&amp;lt;&#x27;</span>)<br>            .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&gt;/g</span>, <span class="hljs-string">&#x27;&amp;gt;&#x27;</span>)<br><br>        <span class="hljs-comment">// Don&#x27;t escape special characters in the template.</span><br>        s += templateData[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，<code>sender</code>变量往往是用户提供的，经过<code>SaferHTML</code>函数处理，里面的特殊字符都会被转义。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">let sender = &#x27;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;abc&quot;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>&#x27; // 恶意代码</span><br><span class="language-xml">let message = SaferHTML`<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;sender&#125;</span><span class="language-xml"> has sent you a message.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>`</span><br><span class="language-xml"></span><br><span class="language-xml">message</span><br><span class="language-xml">// <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>script<span class="hljs-symbol">&amp;gt;</span>alert(&quot;abc&quot;)<span class="hljs-symbol">&amp;lt;</span>/script<span class="hljs-symbol">&amp;gt;</span> has sent you a message.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="String-raw"><a href="#String-raw" class="headerlink" title="String.raw()"></a>String.raw()</h2><p>ES6 还为原生的 String 对象，提供了一个<code>raw</code>方法。</p><p><code>String.raw</code>方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义(即斜杠前面再加一个斜杠)的字符串，对应于替换变量后的模板字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">String</span>.<span class="hljs-property">raw</span><span class="hljs-string">`Hi\n<span class="hljs-subst">$&#123;<span class="hljs-number">2</span> + <span class="hljs-number">3</span>&#125;</span>!`</span><br><span class="hljs-comment">// 返回 &quot;Hi\\n5!&quot;</span><br><br><span class="hljs-title class_">String</span>.<span class="hljs-property">raw</span><span class="hljs-string">`Hi\u000A!`</span><br><span class="hljs-comment">// 返回 &quot;Hi\\u000A!&quot;</span><br></code></pre></td></tr></table></figure><p>如果原字符串的斜杠已经转义，那么<code>String.raw</code>会进行再次转义。</p><pre><code class="hljs">    String.raw`Hi\\n`    // 返回 &quot;Hi\\\\n&quot;</code></pre><p><code>String.raw</code>方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。 </p><p><code>String.raw</code>方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有<code>raw</code>属性的对象，且<code>raw</code>属性的值应该是一个数组。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">String<span class="hljs-selector-class">.raw</span>(&#123; raw: <span class="hljs-string">&#x27;test&#x27;</span> &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-comment">// &#x27;t0e1s2t&#x27;</span><br><br><span class="hljs-comment">// 等同于</span><br>String<span class="hljs-selector-class">.raw</span>(&#123; raw: <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>]</span> &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>作为函数，<code>String.raw</code>的代码实现基本如下</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">String.raw = <span class="hljs-keyword">function</span> <span class="hljs-params">(strings, <span class="hljs-rest_arg">...values</span>)</span> &#123;<br>    let output = <span class="hljs-string">&#x27;&#x27;</span><br>    let index<br>    <span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; values.length; index++) &#123;<br>        output += strings.raw[index] + values[index]<br>    &#125;<br><br>    output += strings.raw[index]<br>    <span class="hljs-keyword">return</span> output<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模板字符串的限制"><a href="#模板字符串的限制" class="headerlink" title="模板字符串的限制"></a>模板字符串的限制</h2><p>前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。</p><p>举例来说，标签模板里面可以嵌入 LaTEX 语言。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">function</span> latex(strings) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">let</span> document <span class="hljs-operator">=</span> latex`<br>    \<span class="hljs-keyword">newcommand</span>&#123;\<span class="hljs-keyword">fun</span>&#125;&#123;\<span class="hljs-keyword">textbf</span>&#123;Fun<span class="hljs-operator">!</span>&#125;&#125;  <span class="hljs-comment">// 正常工作</span><br>    \<span class="hljs-keyword">newcommand</span>&#123;\unicode&#125;&#123;\<span class="hljs-keyword">textbf</span>&#123;Unicode<span class="hljs-operator">!</span>&#125;&#125; <span class="hljs-comment">// 报错</span><br>    \<span class="hljs-keyword">newcommand</span>&#123;\xerxes&#125;&#123;\<span class="hljs-keyword">textbf</span>&#123;King<span class="hljs-operator">!</span>&#125;&#125; <span class="hljs-comment">// 报错</span><br><br>    Breve over the h goes \<span class="hljs-keyword">u</span>&#123;h&#125;ere <span class="hljs-comment">// 报错</span><br>    `<br></code></pre></td></tr></table></figure><p>上面代码中，变量<code>document</code>内嵌的模板字符串，对于 LaTEX 语言来说完全是合法的，但是 JavaScript 引擎会报错。原因就在于字符串的转义。 </p><p>模板字符串会将<code>\u00FF</code>和<code>\u&#123;42&#125;</code>当作 Unicode 字符进行转义，所以解析<code>\unicode</code>时报错；而<code>\x56</code>会被当作十六进制字符串转义，所以<code>\xerxes</code>会报错。<br>也就是说，<code>\u</code>和<code>\x</code>在 LaTEX 里面有特殊含义，但是 JavaScript 将它们转义了。 </p><p>为了解决这个问题，ES2018 放松了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回<code>undefined</code>，而不是报错，并且从<code>raw</code>属性上面可以得到原始字符串。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">tag</span>(<span class="hljs-params">strs</span>) &#123;<br>    strs[<span class="hljs-number">0</span>] === <span class="hljs-literal">undefined</span><br>    strs.raw[<span class="hljs-number">0</span>] === <span class="hljs-string">&#x27;\\unicode and \\u&#123;55&#125;&#x27;</span><br>&#125;<br>tag<span class="hljs-string">`\unicode and \u&#123;55&#125;`</span><br></code></pre></td></tr></table></figure><p>上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript 引擎将第一个字符设置为<code>undefined</code>，但是raw属性依然可以得到原始字符串，因此<code>tag</code>函数还是可以对原字符串进行处理。 </p><p>注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">let</span> <span class="hljs-keyword">bad</span> = `<span class="hljs-keyword">bad</span> <span class="hljs-built_in">escape</span> sequence: \unicode` // 报错<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Module 的加载实现</title>
    <link href="/2022/07/23/ES6/Moudle%20%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/07/23/ES6/Moudle%20%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Module-的加载实现"><a href="#Module-的加载实现" class="headerlink" title="Module 的加载实现"></a>Module 的加载实现</h1><p>本章介绍如何在浏览器和 Node 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题(比如循环加载)</p><h2 id="浏览器加载"><a href="#浏览器加载" class="headerlink" title="浏览器加载"></a>浏览器加载</h2><h3 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h3><p>在 HTML 网页中，浏览器通过<code>&lt;script&gt;</code>标签加载 JavaScript 脚本。</p><span id="more"></span><pre><code class="hljs">    &lt;!-- 页面内嵌的脚本 --&gt;    &lt;script type=&quot;application/javascript&quot;&gt;        // module code    &lt;/script&gt;    &lt;!-- 外部脚本 --&gt;    &lt;script type=&quot;application/javascript&quot; src=&quot;path/to/myModule.js&quot;&gt;&lt;/script&gt;</code></pre><p>上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此<code>type=&quot;application/javascript&quot;</code>可以省略</p><p>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间</p><p>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本<code>异步加载</code>，下面就是两种异步加载的语法。</p><pre><code class="hljs">    &lt;script src=&quot;path/to/myModule.js&quot; defer&gt;&lt;/script&gt;    &lt;script src=&quot;path/to/myModule.js&quot; async&gt;&lt;/script&gt;</code></pre><p>上面代码中，<code>&lt;script&gt;</code>标签打开<code>defer</code>或<code>async</code>属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令</p><p>注：<br><code>defer</code>与<code>async</code>的区别是: <code>defer</code>要等到整个页面在内存中正常渲染结束(DOM 结构完全生成，以及其他脚本执行完成)，才会执行；<code>async</code>一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，<code>defer</code>是“渲染完再执行”，<code>async</code>是“下载完就执行”。另外，如果有多个<code>defer</code>脚本，会按照它们在页面出现的顺序加载，而多个<code>async</code>脚本是不能保证加载顺序的</p><h3 id="加载规则"><a href="#加载规则" class="headerlink" title="加载规则"></a>加载规则</h3><p>浏览器加载 ES6 模块，也使用<code>&lt;script&gt;</code>标签，但是要加入<code>type=&quot;module&quot;</code>属性</p><pre><code class="hljs">    &lt;script type=&quot;module&quot; src=&quot;./foo.js&quot;&gt;&lt;/script&gt;</code></pre><p>上面代码在网页中插入一个模块<code>foo.js</code>，由于<code>type</code>属性设为<code>module</code>，所以浏览器知道这是一个 ES6 模块</p><p>浏览器对于带有<code>type=&quot;module&quot;</code>的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的<code>defer</code>属性</p><pre><code class="hljs">    &lt;script type=&quot;module&quot; src=&quot;./foo.js&quot;&gt;&lt;/script&gt;    &lt;!-- 等同于 --&gt;    &lt;script type=&quot;module&quot; src=&quot;./foo.js&quot; defer&gt;&lt;/script&gt;</code></pre><p>如果网页有多个<code>&lt;script type=&quot;module&quot;&gt;</code>，它们会按照在页面出现的顺序依次执行</p><p><code>&lt;script&gt;</code>标签的<code>async</code>属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染</p><pre><code class="hljs">    &lt;script type=&quot;module&quot; src=&quot;./foo.js&quot; async&gt;&lt;/script&gt;</code></pre><p>一旦使用了<code>async</code>属性，<code>&lt;script type=&quot;module&quot;&gt;</code>就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块</p><p>ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致</p><pre><code class="hljs">    &lt;script type=&quot;module&quot;&gt;        import utils from &#39;./utils.js&#39;        // other code    &lt;/script&gt;</code></pre><p>对于外部的模块脚本(上例是<code>foo.js</code>)，有几点需要注意</p><ul><li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。 </li><li>模块脚本自动采用严格模式，不管有没有声明<code>use strict</code>。 </li><li>模块之中，可以使用<code>import</code>命令加载其他模块(<code>.js</code>后缀不可省略，需要提供绝对 URL 或相对 URL)，也可以使用<code>export</code>命令输出对外接口。 </li><li>模块之中，顶层的<code>this</code>关键字返回<code>undefined</code>，而不是指向<code>window</code>。也就是说，在模块顶层使用<code>this</code>关键字，是无意义的。 </li><li>同一个模块如果加载多次，将只执行一次。</li></ul><hr><p>下面是一个示例模块。</p><pre><code class="hljs">    import utils from &#39;https://example.com/js/utils.js&#39;    const x = 1    console.log(x === window.x) //false    console.log(this === undefined) // true</code></pre><p>利用顶层的<code>this</code>等于<code>undefined</code>这个语法点，可以侦测当前代码是否在 ES6 模块之中</p><pre><code class="hljs">    const isNotModuleScript = this !== undefined</code></pre><h2 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h2><p>讨论 Node 加载 ES6 模块之前，必须了解 ES6 模块与 CommonJS 模块完全不同。</p><p>它们有两个重大差异。</p><ul><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li><li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li></ul><p>第二个差异是因为 CommonJS 加载的是一个对象(即<code>module.exports</code>属性)，该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p><p>下面重点解释第一个差异。</p><p>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件<code>lib.js</code>的例子</p><pre><code class="hljs">    // lib.js    var counter = 3    function incCounter() &#123;        counter++    &#125;    module.exports = &#123;        counter: counter,        incCounter: incCounter,    &#125;</code></pre><p>上面代码输出内部变量<code>counter</code>和改写这个变量的内部方法<code>incCounter</code>。然后，在<code>main.js</code>里面加载这个模块</p><pre><code class="hljs">    // main.js    var mod = require(&quot;./lib&quot;)        console.log(mod.counter) // 3    mod.incCounter()    console.log(mod.counter) // 3</code></pre><p>上面代码说明，<code>lib.js</code>模块加载以后，它的内部变化就影响不到输出的<code>mod.counter</code>了。这是因为<code>mod.counter</code>是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值</p><pre><code class="hljs">    // lib.js    var counter = 3    function incCounter() &#123;        counter++    &#125;    module.exports = &#123;        get counter() &#123;            return counter        &#125;,        incCounter: incCounter,    &#125;</code></pre><p>上面代码中，输出的<code>counter</code>属性实际上是一个取值器函数。现在再执行<code>main.js</code>，就可以正确读取内部变量<code>counter</code>的变动了</p><pre><code class="hljs">    $ node main.js    3    4</code></pre><p>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。<br>换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块</p><pre><code class="hljs">    // lib.js    export let counter = 3    export function incCounter() &#123;        counter++    &#125;    // main.js    import &#123; counter, incCounter &#125; from &#39;./lib&#39;    console.log(counter) // 3    incCounter()    console.log(counter) // 4</code></pre><p>上面代码说明，ES6 模块输入的变量<code>counter</code>是活的，完全反应其所在模块<code>lib.js</code>内部的变化。</p><hr><p>例：<code>m1.js</code>的变量<code>foo</code>，在刚加载时等于bar，过了 500 毫秒，又变为等于baz</p><pre><code class="hljs">    // m1.js    export var foo = &#39;bar&#39;    setTimeout(() =&gt; (foo = &#39;baz&#39;), 500)    // m2.js    import &#123; foo &#125; from &#39;./m1.js&#39;    console.log(foo)    setTimeout(() =&gt; console.log(foo), 500)</code></pre><p>上面代码中，<code>m1.js</code>的变量<code>foo</code>，在刚加载时等于<code>bar</code>，过了 500 毫秒，又变为等于<code>baz</code></p><p>让我们看看，<code>m2.js</code>能否正确读取这个变化</p><pre><code class="hljs">    $ babel-node m2.js        bar    baz</code></pre><p>上面代码表明，ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块</p><p>由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错</p><pre><code class="hljs">    // lib.js    export let obj = &#123;&#125;    // main.js    import &#123; obj &#125; from &#39;./lib&#39;    obj.prop = 123 // OK    obj = &#123;&#125; // TypeError</code></pre><p>上面代码中，<code>main.js</code>从<code>lib.js</code>输入变量<code>obj</code>，可以对<code>obj</code>添加属性，但是重新赋值就会报错。因为变量<code>obj</code>指向的地址是只读的，不能重新赋值，这就好比<code>main.js</code>创造了一个名为<code>obj</code>的<code>const</code>变量。 </p><p>最后，<code>export</code>通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例</p><pre><code class="hljs">    // mod.js    function C() &#123;        this.sum = 0        this.add = function () &#123;            this.sum += 1        &#125;        this.show = function () &#123;            console.log(this.sum)        &#125;    &#125;    export let c = new C()</code></pre><p>上面的脚本<code>mod.js</code>，输出的是一个<code>C</code>的实例。不同的脚本加载这个模块，得到的都是同一个实例。</p><pre><code class="hljs">    // x.js    import &#123; c &#125; from &#39;./mod&#39;    c.add()    // y.js    import &#123; c &#125; from &#39;./mod&#39;    c.show()    // main.js    import &#39;./x&#39;    import &#39;./y&#39;</code></pre><p>现在执行<code>main.js</code>，输出的是1。</p><pre><code class="hljs">    $ babel-node main.js    1</code></pre><p>这就证明了<code>x.js</code>和<code>y.js</code>加载的都是<code>C</code>的同一个实例</p><h2 id="Node-加载"><a href="#Node-加载" class="headerlink" title="Node 加载"></a>Node 加载</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Node 对 ES6 模块的处理比较麻烦，因为它有自己的 CommonJS 模块格式，与 ES6 模块格式是不兼容的。目前的解决方案是，将两者分开，ES6 模块和 CommonJS 采用各自的加载方案。 </p><p>Node 要求 ES6 模块采用<code>.mjs</code>后缀文件名。也就是说，只要脚本文件里面使用<code>import</code>或者<code>export</code>命令，那么就必须采用<code>.mjs</code>后缀名。<code>require</code>命令不能加载<code>.mjs</code>文件，会报错，只有<code>import</code>命令才可以加载<code>.mjs</code>文件。反过来，<code>.mjs</code>文件里面也不能使用<code>require</code>命令，必须使用<code>import</code></p><p>为了与浏览器的<code>import</code>加载规则相同，Node 的<code>.mjs</code>文件支持 URL 路径</p><pre><code class="hljs">    import &quot;./foo?query=1&quot; // 加载 ./foo 传入参数 ?query=1</code></pre><p>上面代码中，脚本路径带有参数<code>?query=1</code>，Node 会按 URL 规则解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有<code>:</code>、<code>%</code>、<code>#</code>、<code>?</code>等特殊字符，最好对这些字符进行转义。 </p><p>目前，Node 的<code>import</code>命令只支持加载本地模块(<code>file:</code>协议)，不支持加载远程模块。 如果模块名不含路径，那么<code>import</code>命令会去<code>node_modules</code>目录寻找这个模块</p><pre><code class="hljs">    import &#39;baz&#39;    import &#39;abc/123&#39;</code></pre><p>如果模块名包含路径，那么<code>import</code>命令会按照路径去寻找这个名字的脚本文件</p><pre><code class="hljs">    import &#39;file:///etc/config/app.json&#39;    import &#39;./foo&#39;    import &#39;./foo?search&#39;    import &#39;../bar&#39;    import &#39;/baz&#39;</code></pre><p>如果脚本文件省略了后缀名，比如<code>import &#39;./foo&#39;</code>，Node 会依次尝试四个后缀名: <code>./foo.mjs</code>、<code>./foo.js</code>、<code>./foo.json</code>、<code>./foo.node</code>。如果这些脚本文件都不存在，Node 就会去加载<code>./foo/package.json</code>的<code>main</code>字段指定的脚本。<br>如果<code>./foo/package.json</code>不存在或者没有main字段，那么就会依次加载<code>./foo/index.mjs</code>、<code>./foo/index.js</code>、<code>./foo/index.json</code>、<code>./foo/index.node</code>。如果以上四个文件还是都不存在，就会抛出错误。 </p><p>最后，Node 的<code>import</code>命令是异步加载，这一点与浏览器的处理方法相同</p><h3 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h3><p>ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。 </p><p>首先，就是<code>this</code>关键字。ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>；CommonJS 模块的顶层<code>this</code>指向当前模块，这是两者的一个重大差异。</p><p>其次，以下这些顶层变量在 ES6 模块之中都是不存在的</p><ul><li><code>arguments</code> </li><li><code>require</code></li><li><code>module</code></li><li><code>exports</code></li><li><code>__filename</code></li><li><code>__dirname</code></li></ul><p>如果您一定要使用这些变量，有一个变通方法，就是写一个 CommonJS 模块输出这些变量，然后再用 ES6 模块加载这个 CommonJS 模块。但是这样一来，该 ES6 模块就不能直接用于浏览器环境了，所以不推荐这样做</p><pre><code class="hljs">    // expose.js    module.exports = &#123; __dirname &#125;    // use.mjs    import expose from &#39;./expose.js&#39;    const &#123; __dirname &#125; = expose</code></pre><p>上面代码中，<code>expose.js</code>是一个 CommonJS 模块，输出变量<code>__dirname</code>，该变量在 ES6 模块之中不存在。ES6 模块加载<code>expose.js</code>，就可以得到<code>__dirname</code></p><h3 id="ES6-模块加载-CommonJS-模块"><a href="#ES6-模块加载-CommonJS-模块" class="headerlink" title="ES6 模块加载 CommonJS 模块"></a>ES6 模块加载 CommonJS 模块</h3><p>CommonJS 模块的输出都定义在<code>module.exports</code>这个属性上面。Node 的<code>import</code>命令加载 CommonJS 模块，Node 会自动将<code>module.exports</code>属性，当作模块的默认输出，即等同于<code>export default xxx</code>。</p><p>下面是一个 CommonJS 模块。</p><pre><code class="hljs">    // a.js    module.exports = &#123;        foo: &#39;hello&#39;,        bar: &#39;world&#39;,    &#125;    // 等同于    export default &#123;        foo: &#39;hello&#39;,        bar: &#39;world&#39;,    &#125;</code></pre><p><code>import</code>命令加载上面的模块，<code>module.exports</code>会被视为默认输出，<code>即import</code>命令实际上输入的是这样一个对象<code>&#123; default: module.exports &#125;</code>。</p><p>所以，一共有三种写法，可以拿到 CommonJS 模块的<code>module.exports</code></p><pre><code class="hljs">    // 写法一    import baz from &#39;./a&#39;    // baz = &#123;foo: &#39;hello&#39;, bar: &#39;world&#39;&#125;;    // 写法二    import &#123; default as baz &#125; from &#39;./a&#39;    // baz = &#123;foo: &#39;hello&#39;, bar: &#39;world&#39;&#125;;    // 写法三    import * as baz from &#39;./a&#39;    // baz = &#123;    //   get default() &#123;return module.exports;&#125;,    //   get foo() &#123;return this.default.foo&#125;.bind(baz),    //   get bar() &#123;return this.default.bar&#125;.bind(baz)    // &#125;</code></pre><h2 id="上面代码的第三种写法，可以通过baz-default拿到module-exports。foo属性和bar属性就是可以通过这种方法拿到了module-exports"><a href="#上面代码的第三种写法，可以通过baz-default拿到module-exports。foo属性和bar属性就是可以通过这种方法拿到了module-exports" class="headerlink" title="上面代码的第三种写法，可以通过baz.default拿到module.exports。foo属性和bar属性就是可以通过这种方法拿到了module.exports"></a>上面代码的第三种写法，可以通过<code>baz.default</code>拿到<code>module.exports</code>。<code>foo</code>属性和<code>bar</code>属性就是可以通过这种方法拿到了<code>module.exports</code></h2><p>下面是一些例子</p><pre><code class="hljs">    // b.js    module.exports = null    // es.js    import foo from &#39;./b&#39;    // foo = null    import * as bar from &#39;./b&#39;    // bar = &#123; default:null &#125;</code></pre><p>上面代码中，<code>es.js</code>采用第二种写法时，要通过<code>bar.default</code>这样的写法，才能拿到<code>module.exports</code>。</p><pre><code class="hljs">    // c.js    module.exports = function two() &#123;        return 2    &#125;    // es.js    import foo from &#39;./c&#39;    foo() // 2    import * as bar from &#39;./c&#39;    bar.default() // 2    bar() // throws, bar is not a function</code></pre><p>上面代码中，<code>bar</code>本身是一个对象，不能当作函数调用，只能通过<code>bar.default</code>调用。</p><p>CommonJS 模块的输出缓存机制，在 ES6 加载方式下依然有效</p><pre><code class="hljs">    // foo.js    module.exports = 123    setTimeout((_) =&gt; (module.exports = null))</code></pre><p>上面代码中，对于加载<code>foo.js</code>的脚本，<code>module.exports</code>将一直是<code>123</code>，而不会变成<code>null</code>。 </p><p>由于 ES6 模块是编译时确定输出接口，CommonJS 模块是运行时确定输出接口，所以采用<code>import</code>命令加载 CommonJS 模块时，不允许采用下面的写法。</p><pre><code class="hljs">    // 不正确    import &#123; readFile &#125; from &quot;fs&quot;</code></pre><p>上面的写法不正确，因为<code>fs</code>是 CommonJS 格式，只有在运行时才能确定<code>readFile</code>接口，而<code>import</code>命令要求编译时就确定这个接口。解决方法就是改为整体输入</p><pre><code class="hljs">    // 正确的写法一    import * as express from &#39;express&#39;    const app = express.default()    // 正确的写法二    import express from &#39;express&#39;    const app = express()</code></pre><h3 id="CommonJS-模块加载-ES6-模块"><a href="#CommonJS-模块加载-ES6-模块" class="headerlink" title="CommonJS 模块加载 ES6 模块"></a>CommonJS 模块加载 ES6 模块</h3><p>CommonJS 模块加载 ES6 模块，不能使用<code>require</code>命令，而要使用<code>import()</code>函数。ES6 模块的所有输出接口，会成为输入对象的属性</p><pre><code class="hljs">    // es.mjs    let foo = &#123; bar: &#39;my-default&#39; &#125;    export default foo    // cjs.js    const es_namespace = await import(&#39;./es.mjs&#39;)    // es_namespace = &#123;    //     get default() &#123;&#125;,    // &#125;    console.log(es_namespace.default)    // &#123; bar:&#39;my-default&#39; &#125;</code></pre><p>上面代码中，<code>default</code>接口变成了<code>es_namespace.default</code>属性</p><hr><p>下面是另一个例子</p><pre><code class="hljs">    // es.js    export let foo = &#123; bar: &#39;my-default&#39; &#125;    export &#123; foo as bar &#125;    export function f() &#123;&#125;    export class c &#123;&#125;    // cjs.js    const es_namespace = await import(&#39;./es&#39;)    // es_namespace = &#123;    //     get foo() &#123;    //         return foo    //     &#125;,    //     get bar() &#123;    //         return foo    //     &#125;,    //     get f() &#123;    //         return f    //     &#125;,    //     get c() &#123;    //         return c    //     &#125;,    // &#125;</code></pre><h2 id="循环加载"><a href="#循环加载" class="headerlink" title="循环加载"></a>循环加载</h2><p>“循环加载”(circular dependency)指的是，<code>a</code>脚本的执行依赖<code>b</code>脚本，而<code>b</code>脚本的执行又依赖<code>a</code>脚本</p><pre><code class="hljs">    // a.js    var b = require(&#39;b&#39;)    // b.js    var a = require(&#39;a&#39;)</code></pre><p>通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。 </p><p>但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现<code>a</code>依赖<code>b</code>，<code>b</code>依赖<code>c</code>，<code>c</code>又依赖<code>a</code>这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。 </p><p>对于 JavaScript 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样</p><h3 id="CommonJS-模块的加载原理"><a href="#CommonJS-模块的加载原理" class="headerlink" title="CommonJS 模块的加载原理"></a>CommonJS 模块的加载原理</h3><p>介绍 ES6 如何处理“循环加载”之前，先介绍目前最流行的 CommonJS 模块格式的加载原理。 </p><p>CommonJS 的一个模块，就是一个脚本文件。<code>require</code>命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。</p><pre><code class="hljs">    &#123;        id: &#39;...&#39;,        exports: &#123;&#125;,        loaded: true,    &#125;</code></pre><p>上面代码就是 Node 内部加载模块后生成的一个对象。该对象的<code>id</code>属性是模块名，<code>exports</code>属性是模块输出的各个接口，<code>loaded</code>属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。 </p><p>以后需要用到这个模块的时候，就会到<code>exports</code>属性上面取值。即使再次执行<code>require</code>命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存</p><h3 id="CommonJS-模块的循环加载"><a href="#CommonJS-模块的循环加载" class="headerlink" title="CommonJS 模块的循环加载"></a>CommonJS 模块的循环加载</h3><p>CommonJS 模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。 </p><p>让我们来看，Node <a href="https://nodejs.org/api/modules.html#modules_cycles">官方文档</a> 里面的例子。脚本文件a.js代码如下</p><pre><code class="hljs">    exports.done = false    var b = require(&#39;./b.js&#39;)    console.log(&#39;在 a.js 之中,b.done = %j&#39;, b.done)    exports.done = true    console.log(&#39;a.js 执行完毕&#39;)</code></pre><p>上面代码之中，<code>a.js</code>脚本先输出一个<code>done</code>变量，然后加载另一个脚本文件<code>b.js</code>。注意，此时<code>a.js</code>代码就停在这里，等待<code>b.js</code>执行完毕，再往下执行。</p><p>再看<code>b.js</code>的代码</p><pre><code class="hljs">    exports.done = false    var a = require(&#39;./a.js&#39;)    console.log(&#39;在 b.js 之中，a.done = %j&#39;, a.done)    exports.done = true    console.log(&#39;b.js 执行完毕&#39;)</code></pre><p>上面代码之中，<code>b.js</code>执行到第二行，就会去加载<code>a.js</code>，这时，就发生了“循环加载”。系统会去<code>a.js</code>模块对应对象的<code>exports</code>属性取值，可是因为<code>a.js</code>还没有执行完，从<code>exports</code>属性只能取回已经执行的部分，而不是最后的值。</p><p><code>a.js</code>已经执行的部分，只有一行。</p><pre><code class="hljs">    exports.done = false</code></pre><p>因此，对于<code>b.js</code>来说，它从<code>a.js</code>只输入一个变量<code>done</code>，值为<code>false</code>。 </p><p>然后，<code>b.js</code>接着往下执行，等到全部执行完毕，再把执行权交还给<code>a.js</code>。于是，<code>a.js</code>接着往下执行，直到执行完毕。我们写一个脚本<code>main.js</code>，验证这个过程。</p><pre><code class="hljs">    var a = require(&#39;./a.js&#39;)    var b = require(&#39;./b.js&#39;)    console.log(&#39;在 main.js 之中, a.done=%j, b.done=%j&#39;, a.done, b.done)</code></pre><p>执行<code>main.js</code>，运行结果如下</p><pre><code class="hljs">    $ node main.js        在 b.js 之中，a.done = false    b.js 执行完毕    在 a.js 之中，b.done = true    a.js 执行完毕    在 main.js 之中, a.done=true, b.done=true</code></pre><p>上面的代码证明了两件事。一是，在<code>b.js</code>之中，<code>a.js</code>没有执行完毕，只执行了第一行。二是，<code>main.js</code>执行到第二行时，不会再次执行<code>b.js</code>，而是输出缓存的<code>b.js</code>的执行结果，即它的第四行。</p><pre><code class="hljs">    exports.done = true</code></pre><p>总之，CommonJS 输入的是被输出值的拷贝，不是引用。 </p><p>另外，由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心</p><pre><code class="hljs">    var a = require(&#39;a&#39;) // 安全的写法    var foo = require(&#39;a&#39;).foo // 危险的写法    exports.good = function (arg) &#123;        return a.foo(&#39;good&#39;, arg) // 使用的是 a.foo 的最新值    &#125;    exports.bad = function (arg) &#123;        return foo(&#39;bad&#39;, arg) // 使用的是一个部分加载时的值    &#125;</code></pre><p>上面代码中，如果发生循环加载，<code>require(&#39;a&#39;).foo</code>的值很可能后面会被改写，改用<code>require(&#39;a&#39;)</code>会更保险一点</p><h3 id="ES6-模块的循环加载"><a href="#ES6-模块的循环加载" class="headerlink" title="ES6 模块的循环加载"></a>ES6 模块的循环加载</h3><p>ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用import从一个模块加载变量(即<code>import foo from &#39;foo&#39;</code>)，那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。 </p><p>请看下面这个例子。</p><pre><code class="hljs">    // a.mjs    import &#123; bar &#125; from &#39;./b&#39;    console.log(&#39;a.mjs&#39;)    console.log(bar)    export let foo = &#39;foo&#39;    // b.mjs    import &#123; foo &#125; from &#39;./a&#39;    console.log(&#39;b.mjs&#39;)    console.log(foo)    export let bar = &#39;bar&#39;</code></pre><p>上面代码中，<code>a.mjs</code>加载<code>b.mjs</code>，<code>b.mjs</code>又加载<code>a.mjs</code>，构成循环加载。执行<code>a.mjs</code>，结果如下。</p><pre><code class="hljs">    $ node --experimental-modules a.mjs    b.mjs    ReferenceError: foo is not defined</code></pre><p>上面代码中，执行<code>a.mjs</code>以后会报错，<code>foo</code>变量未定义，这是为什么？ </p><p>让我们一行行来看，ES6 循环加载是怎么处理的。首先，执行<code>a.mjs</code>以后，引擎发现它加载了<code>b.mjs</code>，因此会优先执行<code>b.mjs</code>，然后再执行<code>a.mjs</code>。接着，执行<code>b.mjs</code>的时候，已知它从<code>a.mjs</code>输入了<code>foo</code>接口，这时不会去执行<code>a.mjs</code>，而是认为这个接口已经存在了，继续往下执行。执行到第三行<code>console.log(foo)</code>的时候，才发现这个接口根本没定义，因此报错。 </p><p>解决这个问题的方法，就是让<code>b.mjs</code>运行的时候，<code>foo</code>已经有定义了。这可以通过将<code>foo</code>写成函数来解决。</p><pre><code class="hljs">    // a.mjs    import &#123; bar &#125; from &#39;./b&#39;    console.log(&#39;a.mjs&#39;)    console.log(bar())    function foo() &#123;        return &#39;foo&#39;    &#125;    export &#123; foo &#125;    // b.mjs    import &#123; foo &#125; from &#39;./a&#39;    console.log(&#39;b.mjs&#39;)    console.log(foo())    function bar() &#123;        return &#39;bar&#39;    &#125;    export &#123; bar &#125;</code></pre><p>这时再执行<code>a.mjs</code>就可以得到预期结果</p><pre><code class="hljs">    $ node --experimental-modules a.mjs    b.mjs    foo    a.mjs    bar</code></pre><p>这是因为函数具有提升作用，在执行<code>import &#123;bar&#125; from &#39;./b&#39;</code>时，函数<code>foo</code>就已经有定义了，所以<code>b.mjs</code>加载的时候不会报错。这也意味着，如果把函数<code>foo</code>改写成函数表达式，也会报错</p><pre><code class="hljs">    // a.mjs    import &#123; bar &#125; from &#39;./b&#39;    console.log(&#39;a.mjs&#39;)    console.log(bar())    const foo = () =&gt; &#39;foo&#39;    export &#123; foo &#125;</code></pre><p>上面代码的第四行，改成了函数表达式，就不具有提升作用，执行就会报错。</p><p>我们再来看 ES6 模块加载器SystemJS给出的一个例子</p><pre><code class="hljs">    // even.js    import &#123; odd &#125; from &#39;./odd&#39;    export var counter = 0    export function even(n) &#123;        counter++        return n === 0 || odd(n - 1)    &#125;    // odd.js    import &#123; even &#125; from &#39;./even&#39;    export function odd(n) &#123;        return n !== 0 &amp;&amp; even(n - 1)    &#125;</code></pre><p>上面代码中，<code>even.js</code>里面的函数<code>even</code>有一个参数<code>n</code>，只要不等于 0，就会减去 1，传入加载的<code>odd()</code>。<code>odd.js</code>也会做类似操作。</p><p>运行上面这段代码，结果如下</p><pre><code class="hljs">    $ babel-node    &gt; import * as m from &#39;./even.js&#39;;    &gt; m.even(10);    true    &gt; m.counter    6    &gt; m.even(20)    true    &gt; m.counter    17</code></pre><p>上面代码中，参数<code>n</code>从 10 变为 0 的过程中，<code>even()</code>一共会执行 6 次，所以变量<code>counter</code>等于 6。第二次调用<code>even()</code>时，参数<code>n</code>从 20 变为 0，<code>even()</code>一共会执行 11 次，加上前面的 6 次，所以变量<code>counter</code>等于 17。 </p><p>这个例子要是改写成 CommonJS，就根本无法执行，会报错</p><pre><code class="hljs">    // even.js    var odd = require(&#39;./odd&#39;)    var counter = 0    exports.counter = counter    exports.even = function (n) &#123;        counter++        return n == 0 || odd(n - 1)    &#125;    // odd.js    var even = require(&#39;./even&#39;).even    module.exports = function (n) &#123;        return n != 0 &amp;&amp; even(n - 1)    &#125;</code></pre><p>上面代码中，<code>even.js</code>加载<code>odd.js</code>，而<code>odd.js</code>又去加载<code>even.js</code>，形成“循环加载”。这时，执行引擎就会输出<code>even.js</code>已经执行的部分(不存在任何结果)，所以在<code>odd.js</code>之中，变量<code>even</code>等于<code>undefined</code>，等到后面调用<code>even(n - 1)</code>就会报错</p><pre><code class="hljs">    $ node    &gt; var m = require(&#39;./even&#39;);    &gt; m.even(10)    TypeError: even is not a function</code></pre><h2 id="ES6-模块的转码"><a href="#ES6-模块的转码" class="headerlink" title="ES6 模块的转码"></a>ES6 模块的转码</h2><p>浏览器目前还不支持 ES6 模块，为了现在就能使用，可以将转为 ES5 的写法。除了 Babel 可以用来转码之外，还有以下两个方法，也可以用来转码</p><h3 id="ES6-module-transpiler"><a href="#ES6-module-transpiler" class="headerlink" title="ES6 module transpiler"></a>ES6 module transpiler</h3><p><a href="https://github.com/esnext/es6-module-transpiler">ES6 module transpiler</a>是 square 公司开源的一个转码器，可以将 ES6 模块转为 CommonJS 模块或 AMD 模块的写法，从而在浏览器中使用</p><p>首先，安装这个转码器。 </p><pre><code class="hljs">    npm install -g es6-module-transpiler</code></pre><p>然后，使用<code>compile-modules convert</code>命令，将 ES6 模块文件转码。</p><pre><code class="hljs">    compile-modules convert file1.js file2.js</code></pre><p><code>-o</code>参数可以指定转码后的文件名。 </p><pre><code class="hljs">    compile-modules convert -o out.js file1.js</code></pre><h3 id="SystemJS"><a href="#SystemJS" class="headerlink" title="SystemJS"></a>SystemJS</h3><p>另一种解决方法是使用 <a href="https://github.com/systemjs/systemjs">SystemJS</a> 。它是一个垫片库(polyfill)，可以在浏览器内加载 ES6 模块、AMD 模块和 CommonJS 模块，将其转为 ES5 格式。它在后台调用的是 Google 的 Traceur 转码器。 </p><p>使用时，先在网页内载入system.js文件</p><pre><code class="hljs">    &lt;script src=&quot;system.js&quot;&gt;&lt;/script&gt;</code></pre><p>然后，使用<code>System.import</code>方法加载模块文件。 </p><pre><code class="hljs">    &lt;script&gt;        System.import(&quot;./app.js&quot;)    &lt;/script&gt;</code></pre><p>上面代码中的<code>./app</code>，指的是当前目录下的 <code>app.js</code> 文件。它可以是 ES6 模块文件，<code>System.import</code>会自动将其转码。 </p><p>需要注意的是，<code>System.import</code>使用异步加载，返回一个 Promise 对象，可以针对这个对象编程。</p><p>下面是一个模块文件。</p><pre><code class="hljs">    // app/es6-file.js:    export class q &#123;        constructor() &#123;            this.es6 = &#39;hello&#39;        &#125;    &#125;</code></pre><p>然后，在网页内加载这个模块文件</p><pre><code class="hljs">    &lt;script&gt;        System.import(&#39;app/es6-file&#39;).then(function (m) &#123;            console.log(new m.q().es6) // hello        &#125;)    &lt;/script&gt;</code></pre><p>上面代码中，<code>System.import方</code>法返回的是一个 Promise 对象，所以可以用<code>then</code>方法指定回调函数。</p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Module 模块化</title>
    <link href="/2022/07/21/ES6/%E6%A8%A1%E5%9D%97%E5%8C%96%20module/"/>
    <url>/2022/07/21/ES6/%E6%A8%A1%E5%9D%97%E5%8C%96%20module/</url>
    
    <content type="html"><![CDATA[<h1 id="模块化-module"><a href="#模块化-module" class="headerlink" title="模块化 module"></a>模块化 module</h1><h2 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h2><p>历史上，JavaScript 一直没有模块(<code>module</code>)体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p><p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案</p><span id="more"></span><pre><code class="hljs">    // CommonJS模块    let &#123; stat, exists, readFile &#125; = require(&#39;fs&#39;)    // 等同于    let _fs = require(&#39;fs&#39;)    let stat = _fs.stat    let exists = _fs.exists    let readfile = _fs.readfile</code></pre><p>上面代码的实质是整体加载<code>fs</code>模块(即加载<code>fs</code>的所有方法)，生成一个对象(<code>_fs</code>)，然后再从这个对象上面读取 3 个方法。这种加载称为“<strong>运行时加载</strong>”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”</p><p>ES6 模块不是对象，而是通过<code>export</code>命令显式指定输出的代码，再通过<code>import</code>命令输入</p><pre><code class="hljs">    // ES6模块    import &#123; stat, exists, readFile &#125; from &quot;fs&quot;</code></pre><p>上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“<strong>编译时加载</strong>”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象</p><p>由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏(<code>macro</code>)和类型检验(<code>type system</code>)这些只能靠静态分析实现的功能。<br>除了静态加载带来的各种好处，ES6 模块还有以下好处。 </p><ul><li>不再需要UMD模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。 </li><li>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者<code>navigator</code>对象的属性。 </li><li>不再需要对象作为命名空间(比如<code>Math</code>对象)，未来这些功能可以通过模块提供。</li></ul><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>ES6 的模块自动采用严格模式，不管您有没有在模块头部加上<code>&quot;use strict&quot;</code>。</p><p>严格模式主要有以下限制。 </p><ul><li>变量必须声明后再使用 </li><li>函数的参数不能有同名属性，否则报错 </li><li>不能使用<code>with</code>语句 不能对只读属性赋值，否则报错 </li><li>不能使用前缀 0 表示八进制数，否则报错 </li><li>不能删除不可删除的属性，否则报错 </li><li>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code> </li><li><code>eval</code>不会在它的外层作用域引入变量 </li><li><code>eval</code>和<code>arguments</code>不能被重新赋值 </li><li><code>arguments</code>不会自动反映函数参数的变化 </li><li>不能使用<code>arguments.callee</code> </li><li>不能使用<code>arguments.caller </code></li><li>禁止<code>this</code>指向全局对象 </li><li>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈 </li><li>增加了保留字(比如<code>protected</code>、<code>static</code>和<code>interface</code>)</li></ul><p>上面这些限制，模块都必须遵守。<br>其中，尤其需要注意<code>this</code>的限制。ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>，即不应该在顶层代码使用<code>this</code></p><h2 id="export-命令"><a href="#export-命令" class="headerlink" title="export 命令"></a>export 命令</h2><p>模块功能主要由两个命令构成: <code>export</code>和<code>import</code>。</p><ul><li><code>export</code>命令用于规定模块的对外接口</li><li><code>import</code>命令用于输入其他模块提供的功能。</li></ul><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。<br>如果您希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。</p><h3 id="分别暴露"><a href="#分别暴露" class="headerlink" title="分别暴露"></a>分别暴露</h3><p>下面是一个 JS 文件，里面使用<code>export</code>命令输出变量，在每个需要暴露的变量前加上<code>export</code>关键字</p><pre><code class="hljs">    // profile.js    export var firstName = &#39;Michael&#39;    export var lastName = &#39;Jackson&#39;    export function fun() &#123;        console.log(&quot;fun&quot;);    &#125;</code></pre><p>上面代码是<code>profile.js</code>文件，保存了用户信息。ES6 将其视为一个模块，里面用<code>export</code>命令对外部输出了三个变量</p><h3 id="统一暴露"><a href="#统一暴露" class="headerlink" title="统一暴露"></a>统一暴露</h3><p>在<code>export</code>命令后面，使用大括号指定所要输出的一组变量。它与前一种写法(直接放置在<code>var</code>语句前)是等价的</p><pre><code class="hljs">    // profile.js    var firstName = &#39;Michael&#39;    var lastName = &#39;Jackson&#39;    function fun() &#123;        console.log(&quot;fun&quot;);    &#125;    export &#123; firstName, lastName, fun &#125;</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li><p>通常情况下，<code>export</code>输出的变量就是本来的名字，但是可以使用<code>as</code>关键字重命名</p><pre><code class="hljs">  function v1() &#123;&#125;  function v2() &#123;&#125;  export &#123;       v1 as streamV1,       v2 as streamV2,       v2 as streamLatestVersion   &#125;</code></pre><p>  上面代码使用<code>as</code>关键字，重命名了函数<code>v1</code>和<code>v2</code>的对外接口。重命名后，<code>v2</code>可以用不同的名字输出两次</p></li><li><p><code>export</code>语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值</p><pre><code class="hljs">  export var foo = &#39;bar&#39;  setTimeout(() =&gt; (foo = &#39;baz&#39;), 500)</code></pre><p>  上面代码输出变量<code>foo</code>，值为<code>bar</code>，500 毫秒之后变成<code>baz</code></p></li></ul><h2 id="import-命令"><a href="#import-命令" class="headerlink" title="import 命令"></a>import 命令</h2><p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块</p><h3 id="解构赋值形式"><a href="#解构赋值形式" class="headerlink" title="解构赋值形式"></a>解构赋值形式</h3><p><code>import</code>命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块(profile.js)对外接口的名称相同。类似于解构赋值的形式</p><pre><code class="hljs">    import &#123; firstName, lastName, fun &#125; from &quot;./profile.js&quot;</code></pre><p>如果想为输入的变量重新取一个名字，<code>import</code>命令要使用<code>as</code>关键字，将输入的变量重命名</p><pre><code class="hljs">    import &#123; lastName as surname &#125; from &quot;./profile.js&quot;</code></pre><h3 id="整体加载形式"><a href="#整体加载形式" class="headerlink" title="整体加载形式"></a>整体加载形式</h3><p>除了指定加载某个输出值，还可以使用整体加载，即用星号(<code>*</code>)指定一个对象，所有输出值都加载在这个对象上面</p><pre><code class="hljs">    import * as info from &#39;./profile.js&#39;</code></pre><p>注意，模块整体加载所在的那个对象，应该是可以静态分析的，所以不允许运行时改变。<br>下面的写法都是不允许</p><pre><code class="hljs">    import * as info from &#39;./profile.js&#39;    info.firstName = &#39;a&#39;    // Cannot assign to read only property &#39;firstName&#39; of object &#39;[object Module]&#39;</code></pre><h2 id="export-default-命令"><a href="#export-default-命令" class="headerlink" title="export default 命令"></a>export default 命令</h2><p>从前面的例子可以看出，使用<code>import</code>命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。 </p><p>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到<code>export default</code>命令，为模块指定默认输出</p><pre><code class="hljs">    // export-default.js    export default function () &#123;        console.log(&#39;foo&#39;)    &#125;</code></pre><p>其他模块加载该模块时，<code>import</code>命令可以为该匿名函数指定任意名字</p><pre><code class="hljs">    // import-default.js    import customName from &#39;./export-default&#39;    customName() // &#39;foo&#39;</code></pre><p>上面代码的<code>import</code>命令，可以用任意名称指向<code>export-default.js</code>输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时<code>import</code>命令后面，不使用大括号</p><p><code>export default</code>命令用在非匿名函数前，也是可以的</p><pre><code class="hljs">    // export-default.js    export default function foo() &#123;        console.log(&#39;foo&#39;)    &#125;    // 或者写成    function foo() &#123;        console.log(&#39;foo&#39;)    &#125;    export default foo</code></pre><p>上面代码中，<code>foo</code>函数的函数名<code>foo</code>，在模块外部是无效的。加载的时候，视同匿名函数加载</p><hr><p>下面比较一下默认输出和正常输出</p><pre><code class="hljs">    // 第一组    export default function crc32() &#123;        // 输出        // ...    &#125;    import crc32 from &#39;crc32&#39; // 输入    // 第二组    export function crc32() &#123;        // 输出        // ...    &#125;    import &#123; crc32 &#125; from &#39;crc32&#39; // 输入</code></pre><p>上面代码的两组写法，第一组是使用<code>export default</code>时，对应的<code>import</code>语句不需要使用大括号；第二组是不使用<code>export default</code>时，对应的<code>import</code>语句需要使用大括号。 </p><p><code>export default</code>命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export default</code>命令只能使用一次。所以，<code>import</code> 命令后面才不用加大括号，因为只可能唯一对应<code>export default</code>命令。 </p><p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许您为它取任意名字</p><p>所以，下面的写法是有效的</p><pre><code class="hljs">    // modules.js    function add(x, y) &#123;        return x * y    &#125;    export &#123; add as default &#125;    // 等同于    // export default add    // app.js    import &#123; default as foo &#125; from &#39;modules&#39;    // 等同于    // import foo from &#39;modules&#39;</code></pre><p>正是因为<code>export default</code>命令其实只是输出一个叫做<code>default</code>的变量，所以它后面不能跟变量声明语句</p><pre><code class="hljs">    // 正确    export var a = 1    // 正确    var a = 1    export default a    // 错误    export default var a = 1</code></pre><hr><p>例：<br>有了<code>export default</code>命令，输入模块时就非常直观了，以输入 lodash 模块为例</p><pre><code class="hljs">    import _ from &quot;lodash&quot;</code></pre><p>如果想在一条import语句中，同时输入默认方法和其他接口，可以写成下面这样</p><pre><code class="hljs">    import _, &#123; each, each as forEach &#125; from &quot;lodash&quot;</code></pre><p>对应上面代码的<code>export</code>语句如下。</p><pre><code class="hljs">    export default function (obj) &#123;&#125;    export function each(obj, iterator, context) &#123;&#125;    export &#123; each as forEach &#125;</code></pre><p>上面代码的最后一行的意思是，暴露出<code>forEach</code>接口，默认指向<code>each</code>接口，即<code>forEach</code>和<code>each</code>指向同一个方法</p><p><code>export default</code>也可以用来输出类</p><pre><code class="hljs">    // MyClass.js    export default class &#123;&#125;    // main.js    import MyClass from &#39;MyClass&#39;    let o = new MyClass()</code></pre><h2 id="export-与-import-的复合写法"><a href="#export-与-import-的复合写法" class="headerlink" title="export 与 import 的复合写法"></a>export 与 import 的复合写法</h2><p>如果在一个模块之中，先输入后输出同一个模块，<code>import</code>语句可以与<code>export</code>语句写在一起</p><pre><code class="hljs">    export &#123; foo, bar &#125; from &#39;my_module&#39;    // 可以简单理解为    import &#123; foo, bar &#125; from &#39;my_module&#39;    export &#123; foo, bar &#125;</code></pre><p>上面代码中，<code>export</code>和<code>import</code>语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，<code>foo</code>和<code>bar</code>实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用<code>foo</code>和<code>bar</code></p><p>上面代码中，<code>export</code>和<code>import</code>语句可以结合在一起，写成一行。<br>但需要注意的是，写成一行以后，<code>foo</code>和<code>bar</code>实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用<code>foo</code>和<code>bar</code></p><p>模块的接口改名和整体输出，也可以采用这种写法</p><pre><code class="hljs">    // 接口改名    export &#123; foo as myFoo &#125; from &quot;my_module&quot;        // 整体输出    export * from &quot;my_module&quot;</code></pre><p>默认接口的写法如下</p><pre><code class="hljs">    export &#123; default &#125; from &quot;foo&quot;</code></pre><p>具名接口改为默认接口的写法如下</p><pre><code class="hljs">    export &#123; es6 as default &#125; from &#39;./someModule&#39;    // 等同于    import &#123; es6 &#125; from &#39;./someModule&#39;    export default es6</code></pre><p>默认接口也可以改名为具名接口</p><pre><code class="hljs">    export &#123; default as es6 &#125; from &#39;./someModule&#39;</code></pre><p>下面三种import语句，没有对应的复合写法。</p><pre><code class="hljs">    import * as someIdentifier from &#39;someModule&#39;    import someIdentifier from &#39;someModule&#39;    import someIdentifier, &#123; namedIdentifier &#125; from &#39;someModule&#39;</code></pre><h2 id="模块的继承"><a href="#模块的继承" class="headerlink" title="模块的继承"></a>模块的继承</h2><p>模块之间也可以继承。</p><p>假设有一个<code>circleplus</code>模块，继承了<code>circle</code>模块</p><pre><code class="hljs">    // circleplus.js    export * from &#39;circle&#39;    export var e = 2.71828182846    export default function (x) &#123;        return Math.exp(x)    &#125;</code></pre><p>上面代码中的<code>export *</code>，表示再输出<code>circle</code>模块的所有属性和方法。注意，<code>export *</code>命令会忽略<code>circle</code>模块的<code>default</code>方法。然后，上面代码又输出了自定义的<code>e</code>变量和默认方法</p><p>这时，也可以将circle的属性或方法，改名后再输出</p><pre><code class="hljs">    // circleplus.js    export &#123; area as circleArea &#125; from &#39;circle&#39;</code></pre><p>上面代码表示，只输出<code>circle</code>模块的<code>area</code>方法，且将其改名为<code>circleArea</code></p><p>加载上面模块的写法如下</p><pre><code class="hljs">    // main.js    import * as math from &#39;circleplus&#39;    import exp from &#39;circleplus&#39;    console.log(exp(math.e))</code></pre><p>上面代码中的<code>import exp</code>表示，将<code>circleplus</code>模块的默认方法加载为<code>exp</code>方法</p><h2 id="跨模块常量"><a href="#跨模块常量" class="headerlink" title="跨模块常量"></a>跨模块常量</h2><p>由于<code>const</code>声明的常量只在当前代码块有效，如果想设置跨模块的常量(即跨多个文件)，或者说一个值要被多个模块共享，可以采用下面的写法</p><pre><code class="hljs">    // constants.js 模块    export const A = 1    export const B = 3    export const C = 4    // test1.js 模块    import * as constants from &#39;./constants&#39;    console.log(constants.A) // 1    console.log(constants.B) // 3    // test2.js 模块    import &#123; A, B &#125; from &#39;./constants&#39;    console.log(A) // 1    console.log(B) // 3</code></pre><p>如果要使用的常量非常多，可以建一个专门的<code>constants</code>目录，将各种常量写在不同的文件里面，保存在该目录下</p><pre><code class="hljs">    // constants/db.js    export const db = &#123;        url: &#39;https://my.couchdbserver.local:5984&#39;,        admin_username: &#39;admin&#39;,        admin_password: &#39;admin password&#39;,    &#125;    // constants/user.js    export const users = [&#39;root&#39;, &#39;admin&#39;, &#39;staff&#39;, &#39;ceo&#39;, &#39;chief&#39;, &#39;moderator&#39;]</code></pre><p>然后，将这些文件输出的常量，合并在<code>index.js</code>里面</p><pre><code class="hljs">    // constants/index.js    export &#123; db &#125; from &#39;./db&#39;    export &#123; users &#125; from &#39;./users&#39;</code></pre><p>使用的时候，直接加载<code>index.js</code>就可以了。</p><pre><code class="hljs">    // script.js    import &#123; db, users &#125; from &quot;./constants/index&quot;</code></pre><h2 id="import"><a href="#import" class="headerlink" title="import()"></a>import()</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>前面介绍过，<code>import</code>命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行(<code>import</code>命令叫做“连接” binding 其实更合适)。所以，下面的代码会报错</p><pre><code class="hljs">    // 报错    if (x === 2) &#123;        import MyModual from &#39;./myModual&#39;    &#125;</code></pre><p>上面代码中，引擎处理<code>import</code>语句是在编译时，这时不会去分析或执行if语句，所以<code>import</code>语句放在<code>if</code>代码块之中毫无意义，因此会报句法错误，而不是执行时错误。<br>也就是说，<code>import</code>和<code>export</code>命令只能在模块的顶层，不能在代码块之中(比如，在if代码块之中，或在函数之中)。<br>这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。<br>如果<code>import</code>命令要取代 Node 的<code>require</code>方法，这就形成了一个障碍。因为<code>require</code>是运行时加载模块，<code>import</code>命令无法取代<code>require</code>的动态加载功能。</p><pre><code class="hljs">    const path = &#39;./&#39; + fileName    const myModual = require(path)</code></pre><p>上面的语句就是动态加载，<code>require</code>到底加载哪一个模块，只有运行时才知道。<code>import</code>命令做不到这一点</p><p>因此，有一个提案，建议引入<code>import()</code>函数，完成动态加载</p><pre><code class="hljs">    import(specifier)</code></pre><p>上面代码中，<code>import</code>函数的参数<code>specifier</code>，指定所要加载的模块的位置。<code>import</code>命令能够接受什么参数，<code>import()</code>函数就能接受什么参数，两者区别主要是后者为动态加载</p><hr><p><code>import()</code>返回一个 Promise 对象。下面是一个例子。</p><pre><code class="hljs">    const main = document.querySelector(&#39;main&#39;)    import(`./section-modules/$&#123;someVariable&#125;.js`)        .then((module) =&gt; &#123;            module.loadPageInto(main)        &#125;)        .catch((err) =&gt; &#123;            main.textContent = err.message        &#125;)</code></pre><p><code>import()</code>函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，<code>import()</code>函数与所加载的模块没有静态连接关系，这点也是与<code>import</code>语句不相同。<code>import()</code>类似于 Node 的<code>require</code>方法，<strong>区别主要是前者是异步加载，后者是同步加载</strong></p><h3 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h3><p>下面是<code>import()</code>的一些适用场合</p><h4 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h4><p><code>import()</code>可以在需要的时候，再加载某个模块</p><pre><code class="hljs">    button.addEventListener(&#39;click&#39;, (event) =&gt; &#123;        import(&#39;./dialogBox.js&#39;)            .then((dialogBox) =&gt; &#123;                dialogBox.open()            &#125;)            .catch((error) =&gt; &#123;                /* Error handling */            &#125;)    &#125;)</code></pre><p>上面代码中，<code>import()</code>方法放在<code>click</code>事件的监听函数之中，只有用户点击了按钮，才会加载这个模块</p><h4 id="条件加载"><a href="#条件加载" class="headerlink" title="条件加载"></a>条件加载</h4><p><code>import()</code>可以放在<code>if</code>代码块，根据不同的情况，加载不同的模块</p><pre><code class="hljs">    if (condition) &#123;        import(&#39;moduleA&#39;).then()    &#125; else &#123;        import(&#39;moduleB&#39;).then()    &#125;</code></pre><p>上面代码中，如果满足条件，就加载模块 A，否则加载模块 B</p><h4 id="动态的模块路径"><a href="#动态的模块路径" class="headerlink" title="动态的模块路径"></a>动态的模块路径</h4><p><code>import()</code>允许模块路径动态生成</p><pre><code class="hljs">    import(f()).then()</code></pre><p>上面代码中，根据函数<code>f</code>的返回结果，加载不同的模块</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p><code>import()</code>加载模块成功以后，这个模块会作为一个对象，当作<code>then</code>方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口</p><pre><code class="hljs">    import(&#39;./myModule.js&#39;).then((&#123; export1, export2 &#125;) =&gt; &#123;        // ...·    &#125;)</code></pre><p>上面代码中，<code>export1</code>和<code>export2</code>都是<code>myModule.js</code>的输出接口，可以解构获得。</p><p>如果模块有<code>default</code>输出接口，可以用参数直接获得</p><pre><code class="hljs">    import(&#39;./myModule.js&#39;).then((myModule) =&gt; &#123;        console.log(myModule.default)    &#125;)    //上面的代码也可以使用具名输入的形式    import(&#39;./myModule.js&#39;).then((&#123; default: theDefault &#125;) =&gt; &#123;        console.log(theDefault)    &#125;)</code></pre><p>如果想同时加载多个模块，可以采用下面的写法</p><pre><code class="hljs">    Promise.all([        import(&#39;./module1.js&#39;),         import(&#39;./module2.js&#39;),         import(&#39;./module3.js&#39;)])    .then(([module1, module2, module3]) =&gt; &#123;    &#125;)</code></pre><p><code>import()</code>也可以用在 async 函数之中。</p><pre><code class="hljs">    async function main() &#123;        const myModule = await import(&#39;./myModule.js&#39;)        const &#123; export1, export2 &#125; = await import(&#39;./myModule.js&#39;)        const [module1, module2, module3] = await Promise.all([            import(&#39;./module1.js&#39;),            import(&#39;./module2.js&#39;),            import(&#39;./module3.js&#39;),        ])    &#125;    main()</code></pre>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对象的扩展</title>
    <link href="/2022/07/19/ES6/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <url>/2022/07/19/ES6/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h1 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h1><h2 id="属性的简介表示"><a href="#属性的简介表示" class="headerlink" title="属性的简介表示"></a>属性的简介表示</h2><p>ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p><pre><code class="hljs">    const foo = &quot;bar&quot;    const baz = &#123; foo &#125;    baz // &#123;foo: &quot;bar&quot;&#125;    // 等同于    // const baz = &#123; foo: foo &#125;</code></pre><span id="more"></span><p>上面代码表明，ES6 允许在对象之中，直接写变量。这时，<strong>属性名为变量名, 属性值为变量的值</strong>。下面是另一个例子</p><pre><code class="hljs">    function f(x, y) &#123;        return &#123; x, y &#125;;    &#125;    // 等同于    function f(x, y) &#123;        return &#123; x: x,  y: y &#125;;    &#125;    f(1, 2); // Object &#123;x: 1, y: 2&#125;</code></pre><p>除了属性简写，方法也可以简写，利用方法名加括号替代属性名加函数形式</p><pre><code class="hljs">    const o = &#123;        method() &#123;            return &quot;Hello!&quot;        &#125;,    &#125;    // 等同于    const o = &#123;        method: function () &#123;            return &quot;Hello!&quot;        &#125;,    &#125;</code></pre><h2 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h2><p>JavaScript 定义对象的属性，有两种方法</p><pre><code class="hljs">    // 方法一    obj.foo = true        // 方法二    obj[&quot;a&quot; + &quot;bc&quot;] = 123 //&#123;abc: 123&#125;</code></pre><p>方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内</p><p>如果使用字面量方式定义对象(使用大括号)，在  ES5 中只能使用方法一(标识符)定义属性。<br>ES6 允许字面量定义对象时，用方法二(表达式)作为对象的属性名，即把表达式放在方括号内。</p><pre><code class="hljs">    let lastWord = &#39;last word&#39;    const a = &#123;        &#39;first word&#39;: &#39;hello&#39;,        [lastWord]: &#39;world&#39;,    &#125;    a[&#39;first word&#39;] // &quot;hello&quot;    a[lastWord] // &quot;world&quot;    a[&#39;last word&#39;] // &quot;world&quot;</code></pre><p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串<code>[object Object]</code>，这一点要特别小心。</p><pre><code class="hljs">    const keyA = &#123; a: 1 &#125;;    const keyB = &#123; b: 2 &#125;;    const myObject = &#123;      [keyA]: &quot;valueA&quot;,      [keyB]: &quot;valueB&quot;,    &#125;;    myObject; // Object &#123;[object Object]: &quot;valueB&quot;&#125;</code></pre><p>上面代码中，<code>[keyA]</code>和<code>[keyB]</code>得到的都是<code>[object Object]</code>，所以<code>[keyB]</code>会把<code>[keyA]</code>覆盖掉，而<code>myObject</code>最后只有一个<code>[object Object]</code>属性</p><h2 id="方法的-name-属性"><a href="#方法的-name-属性" class="headerlink" title="方法的 name 属性"></a>方法的 name 属性</h2><p>函数的<code>name</code>属性，返回函数名。对象方法也是函数，因此也有<code>name</code>属性</p><pre><code class="hljs">    const person = &#123;        sayName() &#123;            console.log(&#39;hello!&#39;)        &#125;,    &#125;    person.sayName.name // &quot;sayName&quot;</code></pre><p>如果对象的方法使用了取值函数(getter)和存值函数(setter)，则name属性不是在该方法上面，而是该方法的属性的描述对象的<code>get</code>和<code>set</code>属性上面，返回值是方法名前加上<code>get</code>和<code>set</code></p><pre><code class="hljs">    const obj = &#123;        get foo() &#123;&#125;,        set foo(x) &#123;&#125;,    &#125;    obj.foo.name    // TypeError: Cannot read property &#39;name&#39; of undefined    const descriptor = Object.getOwnPropertyDescriptor(obj, &#39;foo&#39;)    descriptor.get.name // &quot;get foo&quot;    descriptor.set.name // &quot;set foo&quot;</code></pre><p>有两种特殊情况: <code>bind</code>方法创造的函数，<code>name</code>属性返回<code>bound</code>加上原函数的名字；<code>Function</code>构造函数创造的函数，<code>name</code>属性返回<code>anonymous</code>。</p><pre><code class="hljs">    new Function().name // &quot;anonymous&quot;    var doSomething = function () &#123;        // ...    &#125;    doSomething.bind().name // &quot;bound doSomething&quot;</code></pre><p>如果对象的方法是一个 Symbol 值，那么<code>name</code>属性返回的是这个 Symbol 值的描述。</p><pre><code class="hljs">    const key1 = Symbol(&#39;description&#39;)    const key2 = Symbol()    let obj = &#123;        [key1]() &#123;&#125;,        [key2]() &#123;&#125;,    &#125;    obj[key1].name // &quot;[description]&quot;    obj[key2].name // &quot;&quot;</code></pre><h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h2><p>ES5 比较两个值是否相等，只有两个运算符: 相等运算符(<code>==</code>)和严格相等运算符(<code>===</code>)。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。<br>JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p><p>ES6 提出“Same-value equality”(同值相等)算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符(<code>===</code>)的行为基本一致。<br>不同之处只有两个: 一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身。</p><pre><code class="hljs">    Object.is(&#39;foo&#39;, &#39;foo&#39;)  // true    Object.is(&#123;&#125;, &#123;&#125;)   // false    +0 === -0 //true    NaN === NaN // false    Object.is(+0, -0) // false    Object.is(NaN, NaN) // true</code></pre><p>ES5 可以通过下面的代码，部署<code>Object.is</code>。</p><pre><code class="hljs">    Object.defineProperty(Object, &#39;is&#39;, &#123;        value: function (x, y) &#123;            if (x === y) &#123;                // 针对+0 不等于 -0的情况                return x !== 0 || 1 / x === 1 / y            &#125;            // 针对NaN的情况            return x !== x &amp;&amp; y !== y        &#125;,        configurable: true,        enumerable: false,        writable: true,    &#125;)</code></pre><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p><code>Object.assign</code>方法用于对象的合并，将源对象(source)的所有可枚举属性，复制到目标对象(target)。<code>Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象</p><pre><code class="hljs">    const target = &#123; a: 1 &#125;    const source1 = &#123; b: 2 &#125;    const source2 = &#123; c: 3 &#125;    Object.assign(target, source1, source2)    target // &#123;a:1, b:2, c:3&#125;</code></pre><p>如果只有一个参数，<code>Object.assign</code>会直接返回该参数。</p><pre><code class="hljs">    const obj = &#123; a: 1 &#125;    Object.assign(obj) === obj // true</code></pre><p>如果该参数不是对象，则会先转成对象，然后返回。 </p><pre><code class="hljs">    typeof Object.assign(2) // &quot;object&quot;</code></pre><p>由于<code>undefined</code>和<code>null</code>无法转成对象，所以如果它们作为参数，就会报错。 </p><pre><code class="hljs">    Object.assign(undefined) // 报错    Object.assign(null) // 报错</code></pre><p>如果非对象参数出现在源对象的位置(即非首参数)，那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果<code>undefined</code>和<code>null</code>不在首参数，就不会报错。 </p><pre><code class="hljs">    let obj = &#123; a: 1 &#125;;    Object.assign(obj, undefined) === obj; // true    Object.assign(obj, null) === obj; // true</code></pre><p>其他类型的值(即数值、字符串和布尔值)不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。 </p><pre><code class="hljs">    const v1 = &quot;abc&quot;    const v2 = true    const v3 = 10        const obj = Object.assign(&#123;&#125;, v1, v2, v3)    console.log(obj) // &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125;</code></pre><p>上面代码中，v1、v2、v3分别是字符串、布尔值和数值，结果只有字符串合入目标对象(以字符数组的形式)，数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。 </p><pre><code class="hljs">    Object(true) // &#123;[[PrimitiveValue]]: true&#125;    Object(10) //  &#123;[[PrimitiveValue]]: 10&#125;    Object(&quot;abc&quot;) // &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;&#125;</code></pre><p>上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性<code>[[PrimitiveValue]]</code>上面，这个属性是不会被<code>Object.assign</code>拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。 </p><p><code>Object.assign</code>拷贝的属性是有限制的，只拷贝源对象的自身属性(不拷贝继承属性)，也不拷贝不可枚举的属性(<code>enumerable: false</code>)。 </p><pre><code class="hljs">    Object.assign(        &#123; b: &#39;c&#39; &#125;,        Object.defineProperty(&#123;&#125;, &#39;invisible&#39;, &#123;            enumerable: false,            value: &#39;hello&#39;,        &#125;)    )    // &#123; b: &#39;c&#39; &#125;</code></pre><p>上面代码中，<code>Object.assign</code>要拷贝的对象只有一个不可枚举属性<code>invisible</code>，这个属性并没有被拷贝进去。 属性名为 Symbol 值的属性，也会被<code>Object.assign</code>拷贝。 </p><pre><code class="hljs">    Object.assign(&#123; a: &quot;b&quot; &#125;, &#123; [Symbol(&quot;c&quot;)]: &quot;d&quot; &#125;)    // &#123; a: &#39;b&#39;, Symbol(c): &#39;d&#39; &#125;</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p><code>Object.assign</code>方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p><pre><code class="hljs">    const obj1 = &#123; a: &#123; b: 1 &#125; &#125;    const obj2 = Object.assign(&#123;&#125;, obj1)    obj1.a.b = 2    obj2.a.b // 2</code></pre><p>上面代码中，源对象<code>obj1</code>的<code>a</code>属性的值是一个对象，<code>Object.assign</code>拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p><h4 id="同名属性的替换"><a href="#同名属性的替换" class="headerlink" title="同名属性的替换"></a>同名属性的替换</h4><p>对于这种嵌套的对象，一旦遇到同名属性，<code>Object.assign</code>的处理方法是替换，而不是添加</p><pre><code class="hljs">    const target = &#123; a: &#123; b: &#39;c&#39;, d: &#39;e&#39; &#125; &#125;    const source = &#123; a: &#123; b: &#39;hello&#39; &#125; &#125;    Object.assign(target, source)    // &#123; a: &#123; b: &#39;hello&#39; &#125; &#125;</code></pre><p>上面代码中，<code>target</code>对象的<code>a</code>属性被<code>source</code>对象的<code>a</code>属性整个替换掉了，而不会得到<code>&#123; a: &#123; b: &#39;hello&#39;, d: &#39;e&#39; &#125; &#125;</code>的结果。这通常不是开发者想要的，需要特别小心。<br>一些函数库提供<code>Object.assign</code>的定制版本(比如 Lodash 的<code>_.defaultsDeep</code>方法)，可以得到深拷贝的合并。</p><h4 id="数组的处理"><a href="#数组的处理" class="headerlink" title="数组的处理"></a>数组的处理</h4><p><code>Object.assign</code>可以用来处理数组，但是会把数组视为对象。</p><pre><code class="hljs">    Object.assign([1, 2, 3], [4, 5]);    // [4, 5, 3]</code></pre><p>上面代码中，<code>Object.assign</code>把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性<code>4</code>覆盖了目标数组的 0 号属性<code>1</code>。</p><h4 id="取值函数的处理"><a href="#取值函数的处理" class="headerlink" title="取值函数的处理"></a>取值函数的处理</h4><p><code>Object.assign</code>只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。</p><pre><code class="hljs">    const source = &#123;        get foo() &#123;            return 1        &#125;,    &#125;    const target = &#123;&#125;    Object.assign(target, source)    // &#123; foo: 1 &#125;</code></pre><p>上面代码中，<code>source</code>对象的<code>foo</code>属性是一个取值函数，<code>Object.assign</code>不会复制这个取值函数，只会拿到值以后，将这个值复制过去。</p><h3 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h3><h4 id="为对象添加属性"><a href="#为对象添加属性" class="headerlink" title="为对象添加属性"></a>为对象添加属性</h4><pre><code class="hljs">    class Point &#123;        constructor(x, y) &#123;            Object.assign(this, &#123; x, y &#125;)        &#125;    &#125;    // 等价于    class Point2 &#123;        constructor(x, y) &#123;            this.x = x            this.y = y        &#125;    &#125;</code></pre><p>上面方法通过<code>Object.assign</code>方法，将x属性和y属性添加到Point类的对象实例。</p><h4 id="为对象添加方法"><a href="#为对象添加方法" class="headerlink" title="为对象添加方法"></a>为对象添加方法</h4><pre><code class="hljs">    Object.assign(SomeClass.prototype, &#123;        someMethod(arg1, arg2) &#123;&#125;,        anotherMethod() &#123;&#125;,    &#125;)    // 等同于下面的写法    SomeClass.prototype.someMethod = function (arg1, arg2) &#123;&#125;    SomeClass.prototype.anotherMethod = function () &#123;&#125;</code></pre><p>上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用<code>Object.assign</code>方法添加到<code>SomeClass.prototype</code>之中。</p><h4 id="克隆对象"><a href="#克隆对象" class="headerlink" title="克隆对象"></a>克隆对象</h4><pre><code class="hljs">    function clone(origin) &#123;        return Object.assign(&#123;&#125;, origin)    &#125;</code></pre><p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。</p><p>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</p><pre><code class="hljs">    function clone(origin) &#123;        let originProto = Object.getPrototypeOf(origin)        return Object.assign(Object.create(originProto), origin)    &#125;</code></pre><h4 id="合并多个对象"><a href="#合并多个对象" class="headerlink" title="合并多个对象"></a>合并多个对象</h4><p>将多个对象合并到某个对象。</p><pre><code class="hljs">    const merge = (target, ...sources) =&gt; Object.assign(target, ...sources)</code></pre><p>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。</p><pre><code class="hljs">    const merge = (...sources) =&gt; Object.assign(&#123;&#125;, ...sources)</code></pre><h4 id="为属性指定默认值"><a href="#为属性指定默认值" class="headerlink" title="为属性指定默认值"></a>为属性指定默认值</h4><pre><code class="hljs">    const DEFAULTS = &#123;        logLevel: 0,        outputFormat: &#39;html&#39;,    &#125;    function processContent(options) &#123;        options = Object.assign(&#123;&#125;, DEFAULTS, options)        console.log(options)        // ...    &#125;</code></pre><p>上面代码中，<code>DEFAULTS</code>对象是默认值，<code>options</code>对象是用户提供的参数。<code>Object.assign</code>方法将<code>DEFAULTS</code>和<code>options</code>合并成一个新对象，如果两者有同名属性，则<code>option</code>的属性值会覆盖<code>DEFAULTS</code>的属性值。</p><p>注意，由于存在浅拷贝的问题，<code>DEFAULTS</code>对象和<code>options</code>对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，<code>DEFAULTS</code>对象的该属性很可能不起作用。 </p><pre><code class="hljs">    const DEFAULTS = &#123;        url: &#123;            host: &#39;example.com&#39;,            port: 7070,        &#125;,    &#125;    processContent(&#123; url: &#123; port: 8000 &#125; &#125;)    // &#123;    //   url: &#123;port: 8000&#125;    // &#125;</code></pre><p>上面代码的原意是将<code>url.port</code>改成 8000，<code>url.host</code>不变。实际结果却是<code>options.url</code>覆盖掉<code>DEFAULTS.url</code>，所以<code>url.host</code>就不存在了</p><h2 id="属性的可枚举性和遍历"><a href="#属性的可枚举性和遍历" class="headerlink" title="属性的可枚举性和遍历"></a>属性的可枚举性和遍历</h2><h3 id="可枚举性"><a href="#可枚举性" class="headerlink" title="可枚举性"></a>可枚举性</h3><p>对象的每个属性都有一个描述对象(Descriptor)，用来控制该属性的行为。<code>Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。</p><pre><code class="hljs">    let obj = &#123; foo: 123 &#125;    Object.getOwnPropertyDescriptor(obj, &#39;foo&#39;)    //  &#123;    //    value: 123,    //    writable: true,    //    enumerable: true,    //    configurable: true    //  &#125;</code></pre><p>描述对象的<code>enumerable</code>属性，称为”可枚举性“，如果该属性为<code>false</code>，就表示某些操作会忽略当前属性</p><p>目前，有四个操作会忽略<code>enumerable</code>为<code>false</code>的属性。</p><ul><li><code>for...in</code>循环: 只遍历对象自身的和继承的可枚举的属性。 </li><li><code>Object.keys()</code>: 返回对象自身的所有可枚举的属性的键名。 </li><li><code>JSON.stringify()</code>: 只串行化对象自身的可枚举的属性。 </li><li><code>Object.assign()</code>: 忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</li></ul><p>这四个操作之中，前三个是 ES5 就有的，最后一个<code>Object.assign()</code>是 ES6 新增的。<br>其中，只有<code>for...in</code>会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。<br>实际上，引入“可枚举”(<code>enumerable</code>)这个概念的最初目的，就是让某些属性可以规避掉<code>for...in</code>操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的<code>toString</code>方法，以及数组的<code>length</code>属性，就通过“可枚举性”，从而避免被<code>for...in</code>遍历到。</p><pre><code class="hljs">    Object.getOwnPropertyDescriptor(Object.prototype, &#39;toString&#39;).enumerable    // false    Object.getOwnPropertyDescriptor([], &#39;length&#39;).enumerable    // false</code></pre><p>另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的</p><pre><code class="hljs">    Object.getOwnPropertyDescriptor(        class &#123; foo() &#123;&#125; &#125;.prototype, &#39;foo&#39;    ).enumerable    // false</code></pre><p>总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用<code>for...in</code>循环，而用<code>Object.keys()</code>代替</p><h3 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h3><p>ES6 一共有 5 种方法可以遍历对象的属性。</p><h4 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h4><p><code>for...in</code>循环遍历对象自身的和继承的可枚举属性(不含 Symbol 属性)。</p><h4 id="Object-keys-obj"><a href="#Object-keys-obj" class="headerlink" title="Object.keys(obj)"></a>Object.keys(obj)</h4><p><code>Object.keys</code>返回一个数组，包括对象自身的(不含继承的)所有可枚举属性(不含 Symbol 属性)的键名。</p><h4 id="Object-getOwnPropertyNames-obj"><a href="#Object-getOwnPropertyNames-obj" class="headerlink" title="Object.getOwnPropertyNames(obj)"></a>Object.getOwnPropertyNames(obj)</h4><p><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性(不含 Symbol 属性，但是包括不可枚举属性)的键名。</p><h4 id="Object-getOwnPropertySymbols-obj"><a href="#Object-getOwnPropertySymbols-obj" class="headerlink" title="Object.getOwnPropertySymbols(obj)"></a>Object.getOwnPropertySymbols(obj)</h4><p><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p><h4 id="Reflect-ownKeys-obj"><a href="#Reflect-ownKeys-obj" class="headerlink" title="Reflect.ownKeys(obj)"></a>Reflect.ownKeys(obj)</h4><p><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p><p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p><ul><li><p>首先遍历所有数值键，按照数值升序排列。 </p></li><li><p>其次遍历所有字符串键，按照加入时间升序排列。 </p></li><li><p>最后遍历所有 Symbol 键，按照加入时间升序排列。</p><pre><code class="hljs">  Reflect.ownKeys(&#123; [Symbol()]: 0, b: 0, 10: 0, 2: 0, a: 0 &#125;)  // [&#39;2&#39;, &#39;10&#39;, &#39;b&#39;, &#39;a&#39;, Symbol()]</code></pre></li></ul><p>上面代码中，<code>Reflect.ownKeys</code>方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性<code>2</code>和<code>10</code>，其次是字符串属性<code>b</code>和<code>a</code>，最后是 <code>Symbol</code> 属性</p><h2 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h2><p>前面说过，<code>Object.getOwnPropertyDescriptor</code>方法会返回某个对象属性的描述对象(descriptor)。ES2017 引入了<code>Object.getOwnPropertyDescriptors</code>方法，返回指定对象所有自身属性(非继承属性)的描述对象</p><pre><code class="hljs">    const obj = &#123;        foo: 123,        get bar() &#123;            return &#39;abc&#39;        &#125;,    &#125;    Object.getOwnPropertyDescriptors(obj)    // &#123; foo:    //    &#123; value: 123,    //      writable: true,    //      enumerable: true,    //      configurable: true &#125;,    //   bar:    //    &#123; get: [Function: get bar],    //      set: undefined,    //      enumerable: true,    //      configurable: true &#125; &#125;</code></pre><p>上面代码中，<code>Object.getOwnPropertyDescriptors</code>方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象</p><p>该方法的实现非常容易。</p><pre><code class="hljs">    function getOwnPropertyDescriptors(obj) &#123;        const result = &#123;&#125;        for (let key of Reflect.ownKeys(obj)) &#123;            result[key] = Object.getOwnPropertyDescriptor(obj, key)        &#125;        return result    &#125;</code></pre><p>该方法的引入目的，主要是为了解决<code>Object.assign()</code>无法正确拷贝<code>get</code>属性和<code>set</code>属性的问题</p><pre><code class="hljs">    const source = &#123;        set foo(value) &#123;            console.log(value)        &#125;,    &#125;    const target1 = &#123;&#125;    Object.assign(target1, source)    Object.getOwnPropertyDescriptor(target1, &#39;foo&#39;)    // &#123; value: undefined,    //   writable: true,    //   enumerable: true,    //   configurable: true &#125;</code></pre><p>上面代码中，<code>source</code>对象的<code>foo</code>属性的值是一个赋值函数，<code>Object.assign</code>方法将这个属性拷贝给<code>target1</code>对象，结果该属性的值变成了<code>undefined</code>。这是因为<code>Object.assign方</code>法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法</p><p>这时，<code>Object.getOwnPropertyDescriptors</code>方法配合<code>Object.defineProperties</code>方法，就可以实现正确拷贝</p><pre><code class="hljs">    const source = &#123;        set foo(value) &#123;            console.log(value)        &#125;,    &#125;    const target2 = &#123;&#125;    Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source))    Object.getOwnPropertyDescriptor(target2, &#39;foo&#39;)    // &#123; get: undefined,    //   set: [Function: set foo],    //   enumerable: true,    //   configurable: true &#125;</code></pre><p>上面代码中，两个对象合并的逻辑可以写成一个函数</p><pre><code class="hljs">    const shallowMerge = (target, source) =&gt;      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source))    </code></pre><p><code>Object.getOwnPropertyDescriptors</code>方法的另一个用处，是配合<code>Object.create</code>方法，将对象属性克隆到一个新对象。这属于浅拷贝</p><pre><code class="hljs">    const clone = Object.create(        Object.getPrototypeOf(obj),        Object.getOwnPropertyDescriptors(obj))    // 或者    const shallowClone = (obj) =&gt;        Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj))</code></pre><hr><p>另外，<code>Object.getOwnPropertyDescriptors</code>方法可以实现一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。</p><pre><code class="hljs">    const obj = &#123;        __proto__: prot,        foo: 123,    &#125;</code></pre><p>ES6 规定<code>__proto__</code>只有浏览器要部署，其他环境不用部署。如果去除<code>__proto__</code>，上面代码就要改成下面这样</p><pre><code class="hljs">    const obj = Object.create(prot)    obj.foo = 123    // 或者    const obj = Object.assign(Object.create(prot), &#123;        foo: 123,    &#125;)</code></pre><p>有了<code>Object.getOwnPropertyDescriptors</code>，我们就有了另一种写法</p><pre><code class="hljs">    const obj = Object.create(        prot,        Object.getOwnPropertyDescriptors(&#123;            foo: 123,        &#125;)    )</code></pre><p><code>Object.getOwnPropertyDescriptors</code>也可以用来实现 Mixin(混入)模式</p><pre><code class="hljs">    let mix = (object) =&gt; (&#123;        with: (...mixins) =&gt;            mixins.reduce(                (c, mixin) =&gt; Object.create(c, Object.getOwnPropertyDescriptors(mixin)),                object            ),    &#125;)    // multiple mixins example    let a = &#123; a: &#39;a&#39; &#125;    let b = &#123; b: &#39;b&#39; &#125;    let c = &#123; c: &#39;c&#39; &#125;    let d = mix(c).with(a, b)    d.c // &quot;c&quot;    d.b // &quot;b&quot;    d.a // &quot;a&quot;</code></pre><p>上面代码返回一个新的对象<code>d</code>，代表了对象<code>a</code>和<code>b</code>被混入了对象c的操作。 </p><p>出于完整性的考虑，<code>Object.getOwnPropertyDescriptors</code>进入标准以后，以后还会新增<code>Reflect.getOwnPropertyDescriptors</code>方法</p><h2 id="ES6-中的隐式原型"><a href="#ES6-中的隐式原型" class="headerlink" title="ES6 中的隐式原型"></a>ES6 中的隐式原型</h2><h3 id="proto-属性"><a href="#proto-属性" class="headerlink" title="__proto__属性"></a><code>__proto__</code>属性</h3><p><code>__proto__</code>属性(前后各两个下划线)，用来读取或设置当前对象的<code>prototype</code>对象。目前，所有浏览器(包括 IE11)都部署了这个属性</p><pre><code class="hljs">    // es5 的写法    const obj = &#123;        method: function () &#123;&#125;,    &#125;    obj.__proto__ = someOtherObj    // es6 的写法    var obj = Object.create(someOtherObj)    obj.method = function () &#123;&#125;</code></pre><p>该属性没有写入 ES6 的正文，而是写入了附录，原因是<code>__proto__</code>前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。</p><p>标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的<code>Object.setPrototypeOf()</code>(写操作)、<code>Object.getPrototypeOf()</code>(读操作)、<code>Object.create()</code>(生成操作)代替。 </p><p>实现上，<code>__proto__</code>调用的是<code>Object.prototype.__proto__</code>，具体实现如下。</p><pre><code class="hljs">    Object.defineProperty(Object.prototype, &#39;__proto__&#39;, &#123;        get() &#123;            let _thisObj = Object(this)            return Object.getPrototypeOf(_thisObj)        &#125;,        set(proto) &#123;            if (this === undefined || this === null) &#123;                throw new TypeError()            &#125;            if (!isObject(this)) &#123;                return undefined            &#125;            if (!isObject(proto)) &#123;                return undefined            &#125;            let status = Reflect.setPrototypeOf(this, proto)            if (!status) &#123;                throw new TypeError()            &#125;        &#125;,    &#125;)    function isObject(value) &#123;        return Object(value) === value    &#125;</code></pre><p>如果一个对象本身部署了<code>__proto__</code>属性，该属性的值就是对象的原型。</p><pre><code class="hljs">    Object.getPrototypeOf(&#123; __proto__: null &#125;)    // null</code></pre><h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p><code>Object.create()</code>方法创建一个新对象，使用现有的对象来提供新创建的对象的<code>__proto__</code></p><pre><code class="hljs">    Object.create(proto, [propertiesObject])</code></pre><p><code>Object.create()</code> ，可以理解为继承一个对象，添加的属性是在原型下</p><pre><code class="hljs">    let a = &#123; rep: &#39;apple&#39; &#125;    let b = Object.create(a)//等价于 b.__proto__ = a    console.log(b) // &#123;&#125;    console.log(b.__proto__) // &#123;rep: &quot;apple&quot;&#125;    console.log(b.rep) // &#123;rep: &quot;apple&quot;&#125;</code></pre><p>此时这个值不是<code>b</code>自身的，是它通过原型链<code>__proto__</code>来访问到<code>b</code>的值</p><h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p><code>Object.setPrototypeOf</code>方法的作用与<code>__proto__</code>相同，用来设置一个对象的<code>prototype</code>对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法</p><pre><code class="hljs">    // 格式    Object.setPrototypeOf(object, prototype)    // 用法    const o = Object.setPrototypeOf(&#123;&#125;, null)</code></pre><p>该方法等同于下面的函数。</p><pre><code class="hljs">    function setPrototypeOf(obj, proto) &#123;        obj.__proto__ = proto        return obj    &#125;</code></pre><p>下面是一个例子。</p><pre><code class="hljs">    let proto = &#123;&#125;    let obj = &#123; x: 10 &#125;    Object.setPrototypeOf(obj, proto)    proto.y = 20    proto.z = 40    obj.x // 10    obj.y // 20    obj.z // 40</code></pre><p>上面代码将<code>proto</code>对象设为<code>obj</code>对象的原型，所以从<code>obj</code>对象可以读取<code>proto</code>对象的属性。</p><p>如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果</p><pre><code class="hljs">    Object.setPrototypeOf(1, &#123;&#125;) === 1 // true    Object.setPrototypeOf(&#39;foo&#39;, &#123;&#125;) === &#39;foo&#39; // true    Object.setPrototypeOf(true, &#123;&#125;) === true // true</code></pre><p>由于<code>undefined</code>和<code>null</code>无法转为对象，所以如果第一个参数是<code>undefined</code>或<code>null</code>，就会报错</p><h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p>该方法与<code>Object.setPrototypeOf</code>方法配套，用于读取一个对象的原型对象</p><pre><code class="hljs">    Object.getPrototypeOf(obj)</code></pre><p>下面是一个例子。</p><pre><code class="hljs">    function Rectangle() &#123;&#125;    const rec = new Rectangle()    Object.getPrototypeOf(rec) === Rectangle.prototype    Object.getPrototypeOf(rec) === rec.__proto__  //不推荐这种写法    // true    Object.setPrototypeOf(rec, Object.prototype)    Object.getPrototypeOf(rec) === Rectangle.prototype // false    Object.getPrototypeOf(rec) === Object.prototype // true</code></pre><p>如果参数不是对象，会被自动转为对象。</p><pre><code class="hljs">    // 等同于 Object.getPrototypeOf(Number(1))    Object.getPrototypeOf(1)    // Number &#123;[[PrimitiveValue]]: 0&#125;    // 等同于 Object.getPrototypeOf(String(&#39;foo&#39;))    Object.getPrototypeOf(&#39;foo&#39;)    // String &#123;length: 0, [[PrimitiveValue]]: &quot;&quot;&#125;    // 等同于 Object.getPrototypeOf(Boolean(true))    Object.getPrototypeOf(true)    // Boolean &#123;[[PrimitiveValue]]: false&#125;    Object.getPrototypeOf(1) === Number.prototype // true    Object.getPrototypeOf(&#39;foo&#39;) === String.prototype // true    Object.getPrototypeOf(true) === Boolean.prototype // true</code></pre><p>如果参数是<code>undefined</code>或<code>null</code>，它们无法转为对象，所以会报错</p><h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p>我们知道，<code>this</code>关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字<code>super</code>，指向当前对象的原型对象。</p><pre><code class="hljs">    const proto = &#123;        foo: &#39;hello&#39;,    &#125;    const obj = &#123;        foo: &#39;world&#39;,        find() &#123;            return super.foo        &#125;,    &#125;    Object.setPrototypeOf(obj, proto)    obj.find() // &quot;hello&quot;</code></pre><p>上面代码中，对象<code>obj</code>的<code>find</code>方法之中，通过<code>super.foo</code>引用了原型对象<code>proto</code>的<code>foo</code>属性。</p><p>注意，<code>super</code>关键字表示原型对象时，<strong>只能用在对象的方法之中</strong>，用在其他地方都会报错</p><pre><code class="hljs">    // 报错    const obj = &#123;        foo: super.foo,    &#125;    // 报错    const obj = &#123;        foo: () =&gt; super.foo,    &#125;    // 报错    const obj = &#123;        foo: function () &#123;            return super.foo        &#125;,    &#125;</code></pre><p>上面三种<code>super</code>的用法都会报错，因为对于 JavaScript 引擎来说，这里的super都没有用在对象的方法之中。<br>第一种写法是<code>super</code>用在属性里面，第二种和第三种写法是<code>super</code>用在一个函数里面，然后赋值给<code>foo</code>属性。目前，只有对象方法的简写法（<code>foo()&#123;&#125;</code>）可以让 JavaScript 引擎确认，定义的是对象的方法。</p><p>JavaScript 引擎内部，<code>super.foo</code>等同于<code>Object.getPrototypeOf(this).foo</code>(属性)或<code>Object.getPrototypeOf(this).foo.call(this)</code>(方法)。</p><pre><code class="hljs">    const proto = &#123;        x: &#39;hello&#39;,        foo() &#123;            console.log(this.x)        &#125;,    &#125;    const obj = &#123;        x: &#39;world&#39;,        foo() &#123;            super.foo()        &#125;,    &#125;    Object.setPrototypeOf(obj, proto)    obj.foo() // &quot;world&quot;</code></pre><p>上面代码中，<code>super.foo</code>指向原型对象<code>proto</code>的<code>foo</code>方法，但是绑定的<code>this</code>却还是当前对象<code>obj</code>，因此输出的就是<code>world</code></p><h2 id="Object-keys-，Object-values-，Object-entries"><a href="#Object-keys-，Object-values-，Object-entries" class="headerlink" title="Object.keys()，Object.values()，Object.entries()"></a>Object.keys()，Object.values()，Object.entries()</h2><h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p>ES5 引入了<code>Object.keys</code>方法，返回一个数组，成员是参数对象自身的(不含继承的)所有可遍历(<code>enumerable</code>)属性的键名。</p><pre><code class="hljs">    var obj = &#123; foo: &#39;bar&#39;, baz: 42 &#125;    Object.keys(obj)    // [&quot;foo&quot;, &quot;baz&quot;]</code></pre><p>ES2017 引入了跟<code>Object.keys</code>配套的<code>Object.values</code>和<code>Object.entries</code>，作为遍历一个对象的补充手段，供<code>for...of</code>循环使用</p><pre><code class="hljs">    let &#123; keys, values, entries &#125; = Object    let obj = &#123; a: 1, b: 2, c: 3 &#125;    for (let key of keys(obj)) &#123;        console.log(key) // &#39;a&#39;, &#39;b&#39;, &#39;c&#39;    &#125;    for (let value of values(obj)) &#123;        console.log(value) // 1, 2, 3    &#125;    for (let [key, value] of entries(obj)) &#123;        console.log([key, value]) // [&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3]    &#125;</code></pre><h3 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h3><p><code>Object.values</code>方法返回一个数组，成员是参数对象自身的(不含继承的)所有可遍历(<code>enumerable</code>)属性的键值，属性的顺序与通过手动循环对象的属性值所给出的顺序相同。</p><pre><code class="hljs">    const obj = &#123; foo: &#39;bar&#39;, baz: 42 &#125;    Object.values(obj)  // [&quot;bar&quot;, 42]     var an_obj = &#123; 100: &#39;a&#39;, 2: &#39;b&#39;, 7: &#39;c&#39; &#125;    console.log(Object.values(an_obj)); // [&#39;b&#39;, &#39;c&#39;, &#39;a&#39;]</code></pre><p>注：</p><ol><li><p><code>Object.values</code>只返回对象自身的可遍历属性</p><pre><code class="hljs"> const obj = Object.create(&#123;&#125;, &#123; p: &#123; value: 42 &#125; &#125;) Object.values(obj) // []</code></pre><p> 上面代码中，<code>Object.create</code>方法的第二个参数添加的对象属性(属性<code>p</code>)，如果不显式声明，默认是不可遍历的，因为p的属性描述对象的<code>enumerable</code>默认是<code>false</code>，<code>Object.values</code>不会返回这个属性。只要把<code>enumerable</code>改成<code>true</code>，<code>Object.values</code>就会返回属性p的值<br> 即：</p><pre><code class="hljs"> const obj = Object.create(     &#123;&#125;,     &#123;         p: &#123;             value: 42,             enumerable: true,         &#125;,     &#125; ) Object.values(obj) // [42]</code></pre></li><li><p><code>Object.values</code>会过滤属性名为 Symbol 值的属性</p><pre><code class="hljs"> Object.values(&#123; [Symbol()]: 123, foo: &#39;abc&#39; &#125;) // [&#39;abc&#39;]</code></pre></li><li><p>如果<code>Object.values</code>方法的参数是一个字符串，会返回各个字符组成的一个数组</p><pre><code class="hljs"> Object.values(&#39;foo&#39;) // [&#39;f&#39;, &#39;o&#39;, &#39;o&#39;]</code></pre><p> 上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，Object.values返回每个属性的键值，就是各个字符组成的一个数组</p></li><li><p>如果参数不是对象，<code>Object.values</code>会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，<code>Object.values</code>会返回空数组</p></li><li><pre><code class="hljs"> Object.values(42) // [] Object.values(true) // []</code></pre></li></ol><h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries"></a>Object.entries</h3><p><code>Object.entries</code>方法返回一个数组，成员是参数对象自身的(不含继承的)所有可遍历(<code>enumerable</code>)属性的键值对数组,除了返回值不一样，该方法的行为与<code>Object.values</code>基本一致</p><pre><code class="hljs">    const obj = &#123; foo: &#39;bar&#39;, baz: 42 &#125;    Object.entries(obj)    // [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]</code></pre><p>如果原对象的属性名是一个 Symbol 值，该属性会被忽略，而<code>Reflect.ownEntries()</code>方法，返回对象自身的所有属性</p><pre><code class="hljs">    Object.entries(&#123; [Symbol()]: 123, foo: &#39;abc&#39; &#125;)    // [ [ &#39;foo&#39;, &#39;abc&#39; ] ]</code></pre><p>注：</p><ol><li><p><code>Object.entries</code>的基本用途是遍历对象的属性</p><pre><code class="hljs"> let obj = &#123; one: 1, two: 2 &#125; for (let [k, v] of Object.entries(obj)) &#123;     console.log(`$&#123;JSON.stringify(k)&#125;: $&#123;JSON.stringify(v)&#125;`) &#125; // &quot;one&quot;: 1 // &quot;two&quot;: 2</code></pre></li><li><p><code>Object.entries</code>方法的另一个用处是，将对象转为真正的Map结构</p><pre><code class="hljs"> const obj = &#123; foo: &#39;bar&#39;, baz: 42 &#125; const map = new Map(Object.entries(obj)) map // Map &#123; foo: &quot;bar&quot;, baz: 42 &#125;</code></pre></li></ol><h2 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符 ..."></a>对象的扩展运算符 <code>...</code></h2><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的(enumerable)、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面</p><pre><code class="hljs">    let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;    x // 1    y // 2    z // &#123; a: 3, b: 4 &#125;</code></pre><p>上面代码中，变量<code>z</code>是解构赋值所在的对象。它获取等号右边的所有尚未读取的键(<code>a</code>和<code>b</code>)，将它们连同值一起拷贝过来</p><p>注:</p><ol><li><p>由于解构赋值要求等号右边是一个对象，所以如果等号右边是<code>undefined</code>或<code>null</code>，就会报错，因为它们无法转为对象</p><pre><code class="hljs"> let &#123; x, y, ...z &#125; = null // 运行时错误 let &#123; x, y, ...z &#125; = undefined // 运行时错误</code></pre></li><li><p>解构赋值必须是最后一个参数，否则会报错</p><pre><code class="hljs"> let &#123; ...x, y, z &#125; = obj // 句法错误 let &#123; x, ...y, ...z &#125; = obj // 句法错误</code></pre></li><li><p>解构赋值的拷贝是<strong>浅拷贝</strong>，即如果一个键的值是复合类型的值(数组、对象、函数)、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本</p><pre><code class="hljs"> let obj = &#123; a: &#123; b: 1 &#125; &#125; let &#123; ...x &#125; = obj obj.a.b = 2 x.a.b // 2</code></pre></li><li><p>扩展运算符的解构赋值，不能复制继承自原型对象的属性。</p><pre><code class="hljs"> let o1 = &#123; a: 1 &#125; let o2 = &#123; b: 2 &#125; o2.__proto__ = o1 let &#123; ...o3 &#125; = o2 o3 // &#123; b: 2 &#125; o3.a // undefined</code></pre><p> 上面代码中，对象<code>o3</code>复制了<code>o2</code>，但是只复制了<code>o2</code>自身的属性，没有复制它的原型对象<code>o1</code>的属性<br> 例：<br> const o &#x3D; Object.create({ x: 1, y: 2 })<br> o.z &#x3D; 3<br><br> let { x, …newObj } &#x3D; o<br> let { y, z } &#x3D; newObj<br> x &#x2F;&#x2F; 1<br> y &#x2F;&#x2F; undefined<br> z &#x2F;&#x2F; 3<br> 上面代码中，变量<code>x</code>是单纯的解构赋值，所以可以读取对象o继承的属性；<br> 变量<code>y</code>和<code>z</code>是扩展运算符的解构赋值，只能读取对象<code>o</code>自身的属性，所以变量z可以赋值成功，变量y取不到值。</p><p> ES6 规定，变量声明语句之中，如果使用解构赋值，扩展运算符后面必须是一个变量名，而不能是一个解构赋值表达式，所以上面代码引入了中间变量<code>newObj</code>，如果写成下面这样会报错</p><pre><code class="hljs"> let &#123; x, ...&#123; y, z &#125; &#125; = o; // SyntaxError: ... must be followed by an identifier in declaration contexts</code></pre></li><li><p>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作</p><pre><code class="hljs"> function baseFunction(&#123; a, b &#125;) &#123;     // ... &#125; function wrapperFunction(&#123; x, y, ...restConfig &#125;) &#123;     // 使用 x 和 y 参数进行操作     // 其余参数传给原始函数     return baseFunction(restConfig) &#125;</code></pre><p> 上面代码中，原始函数<code>baseFunction</code>接受<code>a</code>和<code>b</code>作为参数，函数<code>wrapperFunction</code>在<code>baseFunction</code>的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为</p></li></ol><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符..."></a>扩展运算符<code>...</code></h3><p>对象的扩展运算符(<code>...</code>)用于取出参数对象的所有可遍历属性，拷贝到当前对象之中，这等同于使用<code>Object.assign</code>方法</p><pre><code class="hljs">    let z = &#123; a: 3, b: 4 &#125;    let n = &#123; ...z &#125;    n // &#123; a: 3, b: 4 &#125;    // 等同于    let n2 = Object.assign(&#123;&#125;, z)</code></pre><p>上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法</p><pre><code class="hljs">    // 写法一 （不推荐）    const clone1 = &#123;        __proto__: Object.getPrototypeOf(obj),        ...obj,    &#125;    // 写法二    const clone2 = Object.assign(Object.create(Object.getPrototypeOf(obj)), obj)    // 写法三    const clone3 = Object.create(        Object.getPrototypeOf(obj),        Object.getOwnPropertyDescriptors(obj)    )</code></pre><p>注：</p><ol><li><p>扩展运算符可以用于合并两个对象</p><pre><code class="hljs"> let ab = &#123; ...a, ...b &#125; // 等同于 let ab2 = Object.assign(&#123;&#125;, a, b)</code></pre></li><li><p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉</p><pre><code class="hljs"> let a = &#123; x: &#39;x&#39;, y: &#39;y&#39;, z: &#39;z&#39; &#125; let aWithOverrides = &#123; ...a, x: 1, y: 2 &#125; // 等同于 let aWithOverrides = &#123; ...a, ...&#123; x: 1, y: 2 &#125; &#125; // 等同于 let x = 1,     y = 2,     aWithOverrides = &#123; ...a, x, y &#125; // 等同于 let aWithOverrides = Object.assign(&#123;&#125;, a, &#123; x: 1, y: 2 &#125;) // &#123;x: 1, y: 2, z: &#39;z&#39;&#125;</code></pre></li><li><p>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值</p><pre><code class="hljs"> let a = &#123; x: &#39;x&#39;, z: &#39;z&#39; &#125; let aWithDefaults = &#123; x: 1, y: 2, ...a &#125; // 等同于 let aWithDefaults2 = Object.assign(&#123;&#125;, &#123; x: 1, y: 2 &#125;, a) // 等同于 let aWithDefaults3 = Object.assign(&#123; x: 1, y: 2 &#125;, a) // &#123;x: &#39;x&#39;, y: 2, z: &#39;z&#39;&#125;</code></pre></li><li><p>与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式</p><pre><code class="hljs"> let x = 2 const obj = &#123;     ...(x &gt; 1 ? &#123; a: 1 &#125; : &#123;&#125;),     b: 2, &#125; // &#123;a: 1, b: 2&#125;</code></pre></li><li><p>如果扩展运算符后面是一个空对象，则没有任何效果。</p><pre><code class="hljs"> &#123;...&#123;&#125;, a: 1&#125; // &#123; a: 1 &#125;</code></pre></li><li><p>如果扩展运算符的参数是null或undefined，这两个值会被忽略，不会报错</p><pre><code class="hljs"> let emptyObject = &#123; ...null, ...undefined &#125; // &#123;&#125; 不报错 </code></pre></li><li><p>扩展运算符的参数对象之中，如果有取值函数<code>get</code>，这个函数是会执行的。</p><pre><code class="hljs"> // 并不会抛出错误，因为 x 属性只是被定义，但没执行 let aWithXGetter = &#123;     ...a,     get x() &#123;         throw new Error(&#39;not throw yet&#39;)     &#125;, &#125; // 会抛出错误，因为 x 属性被执行了 let runtimeError = &#123;     ...a,     ...&#123;         get x() &#123;             throw new Error(&#39;throw now&#39;)         &#125;,     &#125;, &#125;</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Class的基本用法</title>
    <link href="/2022/06/25/ES6/Class%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
    <url>/2022/06/25/ES6/Class%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="Class的基本用法"><a href="#Class的基本用法" class="headerlink" title="Class的基本用法"></a>Class的基本用法</h1><p>Class 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p><span id="more"></span><h2 id="extends关键字"><a href="#extends关键字" class="headerlink" title="extends关键字"></a>extends关键字</h2><p>Class 可以通过<code>extends</code>关键字实现继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;<br>    &#125;<br><br>    <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;(&quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> + <span class="hljs-string">&quot;, &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> + <span class="hljs-string">&quot;)&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ColorPoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Point</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y, color</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(x, y); <span class="hljs-comment">// 调用父类的constructor(x, y)</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = color;<br>    &#125;<br><br>    <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// 调用父类的toString()</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码定义了一个<code>ColorPoint</code>类，该类通过<code>extends</code>关键字，继承了<code>Point</code>类的所有属性和方法。<br><code>constructor</code>方法和<code>toString</code>方法之中，都出现了<code>super</code>关键字，它在这里表示父类的构造函数，用来新建父类的<code>this</code>对象。</p><p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。<br>另一个需要注意的地方是，在子类的构造函数中，只有调用<code>super</code>之后，才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有<code>super</code>方法才能调用父类实例。</p><h2 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h2><p><code>Object.getPrototypeOf</code>方法可以用来从子类上获取父类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-title class_">ColorPoint</span>) === <span class="hljs-title class_">Point</span><br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p><h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p><h3 id="作为函数调用"><a href="#作为函数调用" class="headerlink" title="作为函数调用"></a>作为函数调用</h3><p><code>super</code>作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次<code>super</code>函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">super</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>子类<code>B</code>的构造函数之中的<code>super()</code>，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错</p><p><code>super</code>虽然代表了父类<code>A</code>的构造函数，但是返回的是子类B的实例，即s<code>uper</code>内部的<code>this</code>指的是<code>B</code>，因此<code>super()</code>在这里相当于<code>A.prototype.constructor.call(this)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">super</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>(); <span class="hljs-comment">// A</span><br><span class="hljs-keyword">new</span> <span class="hljs-title function_">B</span>(); <span class="hljs-comment">// B</span><br></code></pre></td></tr></table></figure><p><code>new.target</code>指向当前正在执行的函数。可以看到，在<code>super()</code>执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，<code>super()</code>内部的<code>this</code>指向的是B。 </p><p>作为函数时，<code>super()</code>只能用在子类的构造函数之中，用在其他地方就会报错</p><p>###作为对象使用 ###<br><code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-title function_">p</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">super</span>()<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">super</span>.<span class="hljs-title function_">p</span>()) <span class="hljs-comment">// 2</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title function_">B</span>()<br></code></pre></td></tr></table></figure><p>上面代码中，子类B当中的<code>super.p()</code>，就是将<code>super</code>当作一个对象使用。这时，<code>super</code>在普通方法之中，指向<code>A.prototype</code>，所以<code>super.p()</code>就相当于<code>A.prototype.p()</code>。<br>这里需要注意，由于<code>super</code>指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的，而定义在父类原型对象上的，<code>super</code> 就可以直接取到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">p</span> = <span class="hljs-number">2</span><br>    &#125;<br>&#125;<br>A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">x</span> = <span class="hljs-number">2</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> &#123;<br>    <span class="hljs-title function_">p</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.<span class="hljs-property">p</span><br>    &#125;<br>    <span class="hljs-title function_">x</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.<span class="hljs-property">x</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title function_">B</span>()<br>b.<span class="hljs-title function_">p</span>() <span class="hljs-comment">// undefined</span><br>b.<span class="hljs-title function_">x</span>() <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>ES6 规定，在子类普通方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-title function_">print</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">super</span>()<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = <span class="hljs-number">2</span><br>    &#125;<br>    <span class="hljs-title function_">m</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">print</span>()<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title function_">B</span>()<br>b.<span class="hljs-title function_">m</span>() <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>super.print()</code>虽然调用的是<code>A.prototype.print()</code>，但是<code>A.prototype.print()</code>内部的<code>this</code>指向子类B的实例，导致输出的是2，而不是1。也就是说，实际上执行的是<code>super.print.call(this)</code>。</p><p>由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = <span class="hljs-number">1</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">super</span>()<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = <span class="hljs-number">2</span><br>        <span class="hljs-variable language_">super</span>.<span class="hljs-property">x</span> = <span class="hljs-number">3</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">super</span>.<span class="hljs-property">x</span>) <span class="hljs-comment">// undefined</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>) <span class="hljs-comment">// 3</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title function_">B</span>()<br></code></pre></td></tr></table></figure><p>上面代码中，<code>super.x</code>赋值为3，这时等同于对<code>this.x</code>赋值为3。而当读取<code>super.x</code>的时候，读的是<code>A.prototype.x</code>，所以返回<code>undefined</code>。</p><p>如果<code>super</code>作为对象，用在静态方法之中，这时<code>super</code>将指向父类，而不是父类的原型对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">myMethod</span>(<span class="hljs-params">msg</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;static&#x27;</span>, msg)<br>    &#125;<br><br>    <span class="hljs-title function_">myMethod</span>(<span class="hljs-params">msg</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;instance&#x27;</span>, msg)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">myMethod</span>(<span class="hljs-params">msg</span>) &#123;<br>        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">myMethod</span>(msg)<br>    &#125;<br><br>    <span class="hljs-title function_">myMethod</span>(<span class="hljs-params">msg</span>) &#123;<br>        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">myMethod</span>(msg)<br>    &#125;<br>&#125;<br><br><span class="hljs-title class_">Child</span>.<span class="hljs-title function_">myMethod</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// static 1</span><br><br><span class="hljs-keyword">let</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()<br>child.<span class="hljs-title function_">myMethod</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// instance 2</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>super</code>在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</p><p>另外，在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">print</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">super</span>()<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = <span class="hljs-number">2</span><br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">m</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">print</span>()<br>    &#125;<br>    <span class="hljs-title function_">m</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">print</span>()<br>    &#125;<br>&#125;<br><br>B.<span class="hljs-property">x</span> = <span class="hljs-number">3</span><br>B.<span class="hljs-title function_">m</span>() <span class="hljs-comment">// 3</span><br><span class="hljs-keyword">new</span> <span class="hljs-title function_">B</span>().<span class="hljs-title function_">m</span>() <span class="hljs-comment">//TypeError: (intermediate value).print is not a function</span><br></code></pre></td></tr></table></figure><p>静态方法<code>B.m</code>里面，<code>super.print</code>指向父类的静态方法。这个方法里面的<code>this</code>指向的是<code>B</code>，而不是<code>B</code>的实例，而普通方法<code>B.m()</code>中，由于<code>super</code>指向父类的原型对象<code>A.prototype</code>，其中没有<code> print()</code>这个方法，所以会报错</p><p>最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用<code>super</code>关键字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyObject: &quot;</span> + <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">toString</span>()<br>    &#125;,<br>&#125;<br><br>obj.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// MyObject: [object Object]</span><br></code></pre></td></tr></table></figure><h2 id="类的-prototype-属性和-proto-属性"><a href="#类的-prototype-属性和-proto-属性" class="headerlink" title="类的 prototype 属性和__proto__属性"></a>类的 <code>prototype</code> 属性和<code>__proto__</code>属性</h2><p>大多数浏览器的 ES5 实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的<code>prototype</code>属性。Class 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p><ol><li><p>子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</p></li><li><p>子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属 性。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> &#123;&#125;<br><br>B.<span class="hljs-property">__proto__</span> === A <span class="hljs-comment">// true</span><br>B.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>这样的结果是因为，类的继承是按照下面的模式实现的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;&#125;<br><br><span class="hljs-comment">// B 的实例继承 A 的实例</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(B.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<br><span class="hljs-comment">// 等同于B.prototype.__proto__ = A.prototype</span><br><span class="hljs-comment">// B 继承 A 的静态属性</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(B, A)<br><span class="hljs-comment">// 等同于B.__proto__ = A</span><br><br><span class="hljs-keyword">const</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title function_">B</span>()<br></code></pre></td></tr></table></figure><p>这两条继承链，可以这样理解: 作为一个对象，子类(B)的原型(<code>__proto__</code>属性)是父类(A)；作为一个构造函数，子类(B)的原型对象(<code>prototype</code>属性)是父类的原型对象(<code>prototype</code>属性)的实例</p><h2 id="实例的-proto-属性"><a href="#实例的-proto-属性" class="headerlink" title="实例的 __proto__ 属性"></a>实例的<code> __proto__</code> 属性</h2><p>子类实例的<code>__proto__</code>属性的<code>__proto__</code>属性，指向父类实例的<code>__proto__</code>属性。也就是说，子类的原型的原型，是父类的原型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">   <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125;<br>   <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> &#123;&#125;<br>   <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>()<br>   <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title function_">B</span>()<br><br>b.<span class="hljs-property">__proto__</span> === B.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> <span class="hljs-comment">//true</span><br>b.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span> === a.<span class="hljs-property">__proto__</span> <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>因此，通过子类实例的<code>__proto__.__proto__</code>属性，可以修改父类实例的行为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">b.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span>.<span class="hljs-property">fun</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;fun&quot;</span>)<br>&#125;<br><br>a.<span class="hljs-title function_">fun</span>() <span class="hljs-comment">// &quot;fun&quot;</span><br></code></pre></td></tr></table></figure><h2 id="原生构造函数的继承"><a href="#原生构造函数的继承" class="headerlink" title="原生构造函数的继承"></a>原生构造函数的继承</h2><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。</p><ul><li><code>Boolean()</code></li><li><code>Number()</code></li><li><code>String()</code></li><li><code>Array()</code></li><li><code>Date()</code></li><li><code>Function()</code></li><li><code>RegExp()</code></li><li><code>Error()</code></li><li><code>Object()</code></li></ul><p>以前，这些原生构造函数是无法继承的，比如，不能自己定义一个<code>Array</code>的子类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyArray</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<br>&#125;<br><br><span class="hljs-title class_">MyArray</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, &#123;<br>    <span class="hljs-attr">constructor</span>: &#123;<br>        <span class="hljs-attr">value</span>: <span class="hljs-title class_">MyArray</span>,<br>        <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>    &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><p>上面代码定义了一个继承 <code>Array</code> 的<code>MyArray</code>类。但是，这个类的行为与<code>Array</code>完全不一致。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArray</span>()<br>   colors[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;red&#x27;</span><br>   colors.<span class="hljs-property">length</span> <span class="hljs-comment">// 0</span><br><br>   colors.<span class="hljs-property">length</span> = <span class="hljs-number">0</span><br>   colors[<span class="hljs-number">0</span>] <span class="hljs-comment">// &quot;red&quot;</span><br></code></pre></td></tr></table></figure><p>之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过<code>Array.apply()</code>或者分配给原型对象都不行。原生构造函数会忽略<code>apply</code>方法传入的<code>this</code>，也就是说，原生构造函数的<code>this</code>无法绑定，导致拿不到内部属性。 </p><p>ES5 是先新建子类的实例对象<code>this</code>，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，<code>Array</code>构造函数有一个内部属性<code>[[DefineOwnProperty]]</code>，用来定义新属性时，更新<code>length</code>属性，这个内部属性无法在子类获取，导致子类的<code>length</code>属性行为不正常。 </p><p>下面的例子中，我们想让一个普通对象继承<code>Error</code>对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> e = &#123;&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(<span class="hljs-title class_">Error</span>.<span class="hljs-title function_">call</span>(e))<br><span class="hljs-comment">// [ &#x27;stack&#x27; ]</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(e)<br><span class="hljs-comment">// []</span><br></code></pre></td></tr></table></figure><p>上面代码中，我们想通过<code>Error.call(e)</code>这种写法，让普通对象e具有<code>Error</code>对象的实例属性。但是，<code>Error.call()</code>完全忽略传入的第一个参数，而是返回一个新对象，<code>e</code>本身没有任何变化。这证明了<code>Error.call(e)</code>这种写法，无法继承原生构造函数。</p><p>ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象<code>this</code>，然后再用子类的构造函数修饰<code>this</code>，使得父类的所有行为都可以继承。</p><p>下面是ES6中一个继承<code>Array</code>的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Array</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">...args</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(...args)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArray</span>();<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">12</span><br>arr.<span class="hljs-property">length</span> <span class="hljs-comment">// 1</span><br><br>arr.<span class="hljs-property">length</span> = <span class="hljs-number">0</span><br>arr[<span class="hljs-number">0</span>] <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>上面代码定义了一个<code>MyArray</code>类，继承了<code>Array</code>构造函数，因此就可以从<code>MyArray</code>生成数组的实例。这意味着，ES6 可以自定义原生数据结构(比如<code>Array</code>、<code>String</code>等)的子类，这是 ES5 无法做到的。 </p><p>上面这个例子也说明，<code>extends</code>关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。</p><p>下面就是定义了一个带版本功能的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">VersionedArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Array</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">super</span>()<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span> = [[]]<br>    &#125;<br>    <span class="hljs-title function_">commit</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">slice</span>())<br>    &#125;<br>    <span class="hljs-title function_">revert</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>, ...<span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>])<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VersionedArray</span>()<br><br>x.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>)<br>x.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>)<br>x <span class="hljs-comment">// [1, 2]</span><br>x.<span class="hljs-property">history</span> <span class="hljs-comment">// [[]]</span><br><br>x.<span class="hljs-title function_">commit</span>()<br>x.<span class="hljs-property">history</span> <span class="hljs-comment">// [[], [1, 2]]</span><br><br>x.<span class="hljs-title function_">push</span>(<span class="hljs-number">3</span>)<br>x <span class="hljs-comment">// [1, 2, 3]</span><br>x.<span class="hljs-property">history</span> <span class="hljs-comment">// [[], [1, 2]]</span><br><br>x.<span class="hljs-title function_">revert</span>()<br>x <span class="hljs-comment">// [1, 2]</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>VersionedArray</code>会通过<code>commit</code>方法，将自己的当前状态生成一个版本快照，存入<code>history</code>属性。<code>revert</code>方法用来将数组重置为最新一次保存的版本。除此之外，<code>VersionedArray</code>依然是一个普通数组，所有原生的数组方法都可以在它上面调用。</p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Class的基本用法</title>
    <link href="/2022/06/24/ES6/Class%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <url>/2022/06/24/ES6/Class%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Class的基本用法"><a href="#Class的基本用法" class="headerlink" title="Class的基本用法"></a>Class的基本用法</h1><p>ES6 提供了更接近传统语言的写法，引入了 Class(类)这个概念，作为对象的模板。通过class关键字，可以定义类。<br>基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。</p><pre><code class="hljs">    function Obj(x, y) &#123;        this.x = x        this.y = y    &#125;    Obj.prototype.add = function () &#123;        return this.x + this.y    &#125;    let num = new Obj(1, 2)</code></pre><p>上面的代码用 ES6 的class改写，就是下面这样</p><pre><code class="hljs">    class Obj &#123;        constructor(x, y)&#123;            this.x = x            this.y = y        &#125;        add() &#123;            return this.x + this.y        &#125;    &#125; </code></pre><p>上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象</p><p><code>obj</code> 类除了构造方法，还定义了一个 <code>add()</code> 方法。注意，定义“类”的方法的时候，前面不需要加上<code>function</code>这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p><p>ES6 的类，完全可以看作构造函数的另一种写法,类的数据类型就是函数，类本身就指向构造函数。</p><pre><code class="hljs">    class Obj &#123;      // ...    &#125;        typeof Obj // &quot;function&quot;    Obj === Obj.prototype.constructor // true</code></pre><p>构造函数的 <code>prototype</code> 属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的 <code>prototype</code> 属性上面</p><pre><code class="hljs">    class Obj &#123;        constructor()&#123;&#125;        add() &#123;&#125;    &#125;     //等同于    Obj.prototype = &#123;        constructor()&#123;&#125;,        add() &#123;&#125;    &#125;</code></pre><p>因此在类的实例上调用方法。相当于调用原型上的方法。</p><h2 id="constructor方法"><a href="#constructor方法" class="headerlink" title="constructor方法"></a>constructor方法</h2><p><code>constructor</code>方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加</p><pre><code class="hljs">    class Obj &#123;&#125;        // 等同于    class Obj &#123;      constructor() &#123;&#125;    &#125;</code></pre><p>上面代码中，定义了一个空的类 <code>Obj</code>，JavaScript 引擎会自动为它添加一个空的<code>constructor</code>方法。 <code>constructor</code>方法默认返回实例对象(即<code>this</code>)，完全可以指定返回另外一个对象</p><pre><code class="hljs">    class Foo &#123;        constructor()&#123;            return &#123;&#125;        &#125;    &#125;    new Foo() instanceof Foo  // flase</code></pre><p><code>constructor</code> 函数返回一个全新的对象，结果导致实例对象不是Foo类的实例</p><p><strong>注</strong>：类必须使用<code>new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，构造函数不用<code>new</code>也可以执行。</p><h2 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h2><p>众所周知，在JS中，new的作用是通过构造函数来创建一个实例对象</p><p>实际上，<code>new</code> 操作符帮我们做了这些事</p><ol><li><p>帮我们创建了一个空对象，例如：obj；</p></li><li><p>将空对象原型的内存地址__proto__指向函数的原型对象；</p></li><li><p>利用函数的call方法，将原本指向window的绑定对象this指向了obj。（这样一来，当我们向函数中再传递实参时，对象的属性就会被挂载到obj上。）</p></li><li><p>利用函数返回对象obj。</p><pre><code class="hljs"> function Foo(name) &#123;     this.name = name &#125; let foo = new Foo(&quot;aaa&quot;) //等价于 function Foo(name) &#123;     this.name = name     return this    //4 &#125; let obj = &#123;&#125;   //1 obj.__proto__ = Foo.prototype  //2 // Foo.call(obj, &#39;aaa&#39;) let foo = Foo.call(obj, &#39;aaa&#39;) //3</code></pre></li></ol><p><strong>注</strong>：类的构造函数与普通构造函数之间的区别是，调用构造函数必须使用<code>new</code> 操作符。而普通构造函数如果不使用 <code>new</code> 调用，name就会以全局的 <code>this</code> （通常是 <code>window</code>）作为内部对象。调用类构造函数时如果忘记使用 <code>new</code> 则会报错。</p><h2 id="类的实例对象"><a href="#类的实例对象" class="headerlink" title="类的实例对象"></a>类的实例对象</h2><p>与 ES5 一样，实例的属性除非显式定义在其本身(即定义在this对象上)，否则都是定义在原型上(即定义在class上)。 </p><pre><code class="hljs">    //定义类    class Point &#123;      constructor(x, y) &#123;        this.x = x        this.y = y      &#125;          toString() &#123;        return &quot;(&quot; + this.x + &quot;, &quot; + this.y + &quot;)&quot;      &#125;    &#125;        let point = new Point(2, 3)        point.toString() // (2, 3)        point.hasOwnProperty(&quot;x&quot;) // true    point.hasOwnProperty(&quot;y&quot;) // true    point.hasOwnProperty(&quot;toString&quot;) // false    point.__proto__.hasOwnProperty(&quot;toString&quot;) // true</code></pre><p>上面代码中，<code>x</code>和<code>y</code>都是实例对象<code>point</code>自身的属性(因为定义在<code>this</code>变量上)，所以<code>hasOwnProperty</code>方法返回<code>true</code>，而<code>toString</code>是原型对象的属性(因为定义在<code>Point</code>类上)，所以<code>hasOwnProperty</code>方法返回<code>false</code>。这些都与 ES5 的行为保持一致。</p><p>与 ES5 一样，类的所有实例共享一个原型对象。</p><pre><code class="hljs">    let p1 = new Point(2, 3)    let p2 = new Point(3, 2)        p1.__proto__ === p2.__proto__//true</code></pre><p>上面代码中，<code>p1</code>和<code>p2</code>都是<code>Point</code>的实例，它们的原型都是P<code>oint.prototype</code>，所以<code>__proto__</code>属性是相等的。</p><p>这也意味着，可以通过实例的<code>__proto__</code>属性为“类”添加方法。</p><blockquote><p><strong>proto</strong> 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 <code>Object.getPrototypeOf</code> 方法来获取实例对象的原型，然后再来为原型添加方法&#x2F;属性。</p></blockquote><h2 id="Class表达式"><a href="#Class表达式" class="headerlink" title="Class表达式"></a>Class表达式</h2><p>与函数一样，类也可以使用表达式的形式定义</p><pre><code class="hljs">    const MyClass = class Me &#123;      getClassName() &#123;        return Me.name      &#125;    &#125;</code></pre><p>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是<code>MyClass</code>而不是<code>Me</code>，<code>Me</code>只在 Class 的内部代码可用，指代当前类。如果类的内部没用到的话，可以省略 <code>Me</code></p><pre><code class="hljs">    let inst = new MyClass()    inst.getClassName() // Me    Me.name // ReferenceError: Me is not defined</code></pre><p>采用 Class 表达式，可以写出立即执行的 Class。</p><pre><code class="hljs">    let person = new (class &#123;      constructor(name) &#123;        this.name = name      &#125;          sayName() &#123;        console.log(this.name)      &#125;    &#125;)(&quot;张三&quot;)        person.sayName() // &quot;张三&quot;</code></pre><h2 id="Class-的取值函数-getter-和存值函数-setter"><a href="#Class-的取值函数-getter-和存值函数-setter" class="headerlink" title="Class 的取值函数(getter)和存值函数(setter)"></a>Class 的取值函数(getter)和存值函数(setter)</h2><p>与 ES5 一样，在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p><pre><code class="hljs">    class MyClass &#123;        constructor() &#123;            // ...        &#125;        get prop() &#123;            return &quot;getter&quot;        &#125;        set prop(value) &#123;            console.log(&quot;setter: &quot; + value)        &#125;    &#125;    let inst = new MyClass()    inst.prop = 123  // setter: 123    inst.prop  // &#39;getter&#39;</code></pre><p>上面代码中，<code>prop</code>属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</p><p>存值函数和取值函数是设置在属性的 <code>Descriptor</code> 对象上的</p><pre><code class="hljs">    class CustomHTMLElement &#123;      constructor(element) &#123;        this.element = element      &#125;          get html() &#123;        return this.element.innerHTML      &#125;          set html(value) &#123;        this.element.innerHTML = value      &#125;    &#125;        let descriptor = Object.getOwnPropertyDescriptor(      CustomHTMLElement.prototype,      &quot;html&quot;    );        &quot;get&quot; in descriptor // true    &quot;set&quot; in descriptor // true</code></pre><p>上面代码中，存值函数和取值函数是定义在<code>html</code>属性的描述对象上面，这与 ES5 完全一致</p><h2 id="Class-的-Generator-方法"><a href="#Class-的-Generator-方法" class="headerlink" title="Class 的 Generator 方法"></a>Class 的 Generator 方法</h2><p>如果某个方法之前加上星号(*)，就表示该方法是一个 Generator 函数。 </p><pre><code class="hljs">    class Foo &#123;      constructor(...args) &#123;        this.args = args;      &#125;      *[Symbol.iterator]() &#123;        for (let arg of this.args) &#123;          yield arg;        &#125;      &#125;    &#125;        for (let x of new Foo(&quot;hello&quot;, &quot;world&quot;)) &#123;      console.log(x);    &#125;    // hello    // world</code></pre><p>上面代码中，<code>Foo</code>类的<code>Symbol.iterator</code>方法前有一个星号，表示该方法是一个 <code>Generator</code> 函数。<br><code>Symbol.iterator</code>方法返回一个<code>Foo</code>类的默认遍历器，<code>for...of</code>循环会自动调用这个遍历器</p><h2 id="Class-的静态方法"><a href="#Class-的静态方法" class="headerlink" title="Class 的静态方法"></a>Class 的静态方法</h2><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p><pre><code class="hljs">    class Foo &#123;        static classMethod() &#123;            return &quot;hello&quot;        &#125;    &#125;        Foo.classMethod() // &#39;hello&#39;        let foo = new Foo()    foo.classMethod() // TypeError: foo.classMethod is not a function</code></pre><p><code>Foo</code>类的<code>classMethod</code>方法前有<code>static</code>关键字，表明该方法是一个静态方法，可以直接在<code>Foo</code>类上调用<code>Foo.classMethod()</code>，而不是在<code>Foo</code>类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法</p><p>注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。</p><pre><code class="hljs">    class Foo &#123;        static bar() &#123;            this.baz()        &#125;        static baz() &#123;            console.log(&quot;hello&quot;)        &#125;        baz() &#123;            console.log(&quot;world&quot;)        &#125;    &#125;    Foo.bar() // hello</code></pre><p>静态方法<code>bar</code>调用了<code>this.baz</code>，这里的<code>this</code>指的是<code>Foo</code>类，而不是<code>Foo</code>的实例，等同于调用<code>Foo.baz</code>。另外，从这个例子还可以看出，静态方法可以与非静态方法重名</p><p>父类的静态方法，可以被子类继承</p><pre><code class="hljs">    class Foo &#123;        static classMethod() &#123;            return &quot;hello&quot;        &#125;    &#125;    class Bar extends Foo &#123;&#125;    Bar.classMethod(); // &#39;hello&#39;</code></pre><p>并且，静态方法也是可以从<code>super</code>对象上调用的。</p><pre><code class="hljs">    class Foo &#123;        static classMethod() &#123;            return &quot;hello&quot;        &#125;    &#125;    class Bar extends Foo &#123;        static classMethod() &#123;            return super.classMethod() + &quot;, too&quot;        &#125;    &#125;    Bar.classMethod() // &quot;hello, too&quot;</code></pre><h2 id="Class-的静态属性"><a href="#Class-的静态属性" class="headerlink" title="Class 的静态属性"></a>Class 的静态属性</h2><p>类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。 </p><pre><code class="hljs">    class MyClass &#123;        static myStaticProp = &#39;aa&#39;        constructor() &#123;            console.log(MyClass.myStaticProp) // &#39;aa&#39;        &#125;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>set 与 map</title>
    <link href="/2021/12/18/ES6/set%E4%B8%8Emap/"/>
    <url>/2021/12/18/ES6/set%E4%B8%8Emap/</url>
    
    <content type="html"><![CDATA[<h1 id="set-与-map"><a href="#set-与-map" class="headerlink" title="set 与 map"></a>set 与 map</h1><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 提供了新的数据结构 Set。它类似于数组，<strong>但是成员的值都是唯一的，没有重复的值</strong>。</p><p>Set 本身是一个构造函数，用来生成 Set 数据结构。</p><span id="more"></span><h4 id="set-结构的声明"><a href="#set-结构的声明" class="headerlink" title="set 结构的声明"></a>set 结构的声明</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br></code></pre></td></tr></table></figure><h4 id="set-的初始化"><a href="#set-的初始化" class="headerlink" title="set 的初始化"></a>set 的初始化</h4><p>Set 函数可以接受一个数组(或者具有 iterable 接口的其他数据结构)作为参数，用来初始化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-keyword">let</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)<br><br><span class="hljs-keyword">let</span> s2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> s.<span class="hljs-title function_">add</span>(x))<br><br><span class="hljs-keyword">let</span> s3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&quot;div&quot;</span>))<br></code></pre></td></tr></table></figure><h4 id="set-转换为数组"><a href="#set-转换为数组" class="headerlink" title="set 转换为数组"></a>set 转换为数组</h4><p>使用<code>...</code>扩展运算符或<code>Array.from</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><span class="hljs-keyword">let</span> arr = [...s]<br><span class="hljs-keyword">let</span> arr2 = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(set)<br></code></pre></td></tr></table></figure><p>因此有两种数组去重的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>])<br><span class="hljs-keyword">let</span> arr = [...s]<br><span class="hljs-keyword">let</span> arr2 = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(s)<br></code></pre></td></tr></table></figure><h4 id="注"><a href="#注" class="headerlink" title="注"></a>注</h4><p>向 Set 加入值的时候，不会发生类型转换，所以5和”5”是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符(&#x3D;&#x3D;&#x3D;)，主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br><span class="hljs-keyword">let</span> a = <span class="hljs-title class_">NaN</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-title class_">NaN</span><br>set.<span class="hljs-title function_">add</span>(a)<br>set.<span class="hljs-title function_">add</span>(b)<br><span class="hljs-comment">// Set &#123;NaN&#125;</span><br></code></pre></td></tr></table></figure><p>上面代码向 Set 实例添加了两个NaN，但是只能加入一个。这表明，在 Set 内部，两个NaN是相等.另外，两个对象总是不相等的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br><br>set.<span class="hljs-title function_">add</span>(&#123;&#125;)<br>set.<span class="hljs-property">size</span> <span class="hljs-comment">// 1</span><br><br>set.<span class="hljs-title function_">add</span>(&#123;&#125;)<br>set.<span class="hljs-property">size</span> <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h3 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h3><p>属性：</p><ul><li><code>Set.prototype.constructor</code>: 构造函数，默认就是Set函数。</li><li><code>Set.prototype.size</code>: 返回Set实例的成员总数。</li></ul><p>方法：<br>Set 实例的方法分为两大类: 操作方法(用于操作数据)和遍历方法(用于遍历成员)。下面先介绍四个操作方法</p><ul><li><code>add(value)</code>: 添加某个值，返回 Set 结构本身。 </li><li><code>delete(value)</code>: 删除某个值，返回一个布尔值，表示删除是否成功。 </li><li><code>has(value)</code>: 返回一个布尔值，表示该值是否为Set的成员。 </li><li><code>clear()</code>: 清除所有成员，没有返回值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">s.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>)<br>s.<span class="hljs-property">size</span> <span class="hljs-comment">// 2</span><br><br>s.<span class="hljs-title function_">has</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// true</span><br>s.<span class="hljs-title function_">has</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// true</span><br>s.<span class="hljs-title function_">has</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// false</span><br><br>s.<span class="hljs-title function_">delete</span>(<span class="hljs-number">2</span>)<br>s.<span class="hljs-title function_">has</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p><ul><li><code>keys()</code>: 返回键名的遍历器</li><li><code>values()</code>: 返回键值的遍历器</li><li><code>entries()</code>: 返回键值对的遍历器</li><li><code>forEach()</code>: 使用回调函数遍历每个成员</li></ul><p>需要特别指出的是，<strong>Set的遍历顺序就是插入顺序</strong>。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p><h4 id="keys-，values-，entries"><a href="#keys-，values-，entries" class="headerlink" title="keys()，values()，entries()"></a><code>keys()</code>，<code>values()</code>，<code>entries()</code></h4><p>以上三个方法的返回值都是遍历器对象。由于 Set 结构没有键名，只有键值(或者说键名和键值是同一个值)，所以<code>keys()</code>方法和<code>values()</code>方法的行为完全一致</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>]);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> set.<span class="hljs-title function_">keys</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<br>&#125;<br><span class="hljs-comment">// red</span><br><span class="hljs-comment">// green</span><br><span class="hljs-comment">// blue</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> set.<span class="hljs-title function_">values</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<br>&#125;<br><span class="hljs-comment">// red</span><br><span class="hljs-comment">// green</span><br><span class="hljs-comment">// blue</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> set.<span class="hljs-title function_">entries</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<br>&#125;<br><span class="hljs-comment">// [&quot;red&quot;, &quot;red&quot;]</span><br><span class="hljs-comment">// [&quot;green&quot;, &quot;green&quot;]</span><br><span class="hljs-comment">// [&quot;blue&quot;, &quot;blue&quot;]</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>entries()</code>方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p><p>Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的<code>values</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Set</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] === <span class="hljs-title class_">Set</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">values</span>  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a><code>forEach()</code></h4><p>Set 结构的实例与数组一样，也拥有<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">   set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;bule&quot;</span>, <span class="hljs-string">&quot;black&quot;</span>])<br>   set.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key + <span class="hljs-string">&quot; : &quot;</span> + value))<br><span class="hljs-comment">// red : red</span><br><span class="hljs-comment">// bule : bule</span><br><span class="hljs-comment">// black : black</span><br></code></pre></td></tr></table></figure><p>上面代码说明，<code>forEach</code>方法的参数就是一个处理函数。该函数的参数与数组的<code>forEach</code>一致，依次为键值、键名、集合本身(上例省略了该参数)。这里需要注意，Set 结构的键名就是键值(两者是同一个值)，因此第一个参数与第二个参数的值永远都是一样的。<br>另外，<code>forEach</code>方法还可以有第二个参数，表示绑定处理函数内部的<code>this</code>对象</p><h4 id="遍历的应用"><a href="#遍历的应用" class="headerlink" title="遍历的应用"></a>遍历的应用</h4><p>实现并集(Union)、交集(Intersect)和差集(Difference)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><br><span class="hljs-comment">// 并集</span><br><span class="hljs-keyword">let</span> union = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...s, ...s2])<br><span class="hljs-comment">//交集</span><br><span class="hljs-keyword">let</span> intersect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...s].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> s2.<span class="hljs-title function_">has</span>(num)))<br><span class="hljs-comment">//差集</span><br><span class="hljs-keyword">let</span> difference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...s].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> !s2.<span class="hljs-title function_">has</span>(num)))<br></code></pre></td></tr></table></figure><p>如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用<code>Array.from()</code>方法。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 方法一</span><br><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br>set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...set].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> val * <span class="hljs-number">2</span>));<br><span class="hljs-comment">// set的值是2, 4, 6</span><br><br><span class="hljs-comment">// 方法二</span><br><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br>set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(set, <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> val * <span class="hljs-number">2</span>));<br><span class="hljs-comment">// set的值是2, 4, 6</span><br></code></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>JavaScript 的对象(Object)，本质上是键值对的集合(Hash 结构)，但是传统上只能用字符串当作键。这给它的使用带来了很大的限制</p><p>ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值(包括对象)都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果您需要“键值对”的数据结构，Map 比 Object 更合适。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="map-创建"><a href="#map-创建" class="headerlink" title="map 创建"></a>map 创建</h4><p>作为构造函数，Map 也可以接受一个数组作为参数。该<strong>数组的成员是一个个表示键值对的数组</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">   <span class="hljs-keyword">let</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>       [<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;tom&quot;</span>],<br>       [<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">18</span>]<br>   ])<br>m.<span class="hljs-property">size</span> <span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><p>上面代码在新建 Map 实例时，就指定了两个键<code>name</code>和<code>age</code>，相当于下面代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ja">let item = [<br>    [&#x27;name&#x27;, &#x27;tom&#x27;],<br>    [&#x27;age&#x27;, 18],<br>]<br><br>let m = new Map()<br>item.forEach(([key, value]) =&gt; m.set(key, value))<br></code></pre></td></tr></table></figure><p>不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数。这就是说，Set和Map都可以用来生成新的 Map。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">   <span class="hljs-keyword">let</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<br>       [<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;tom&quot;</span>],<br>       [<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">18</span>]<br>   ])<br>   <br>   <span class="hljs-keyword">let</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(s)<br><span class="hljs-keyword">let</span> m2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(m)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m == m2) <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p>同样的值的两个实例，在 Map 结构中被视为两个键</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br><br><span class="hljs-keyword">const</span> k1 = [<span class="hljs-string">&#x27;a&#x27;</span>]<br><span class="hljs-keyword">const</span> k2 = [<span class="hljs-string">&#x27;a&#x27;</span>]<br><br>map.<span class="hljs-title function_">set</span>(k1, <span class="hljs-number">111</span>).<span class="hljs-title function_">set</span>(k2, <span class="hljs-number">222</span>)<br><br>map.<span class="hljs-title function_">get</span>(k1) <span class="hljs-comment">// 111</span><br>map.<span class="hljs-title function_">get</span>(k2) <span class="hljs-comment">// 222</span><br></code></pre></td></tr></table></figure><p>变量k1和k2的值是一样的，但是它们在 Map 结构中被视为两个键<br>由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞(clash)的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名</p><h3 id="map-的属性和操作方法"><a href="#map-的属性和操作方法" class="headerlink" title="map 的属性和操作方法"></a>map 的属性和操作方法</h3><h4 id="size-属性"><a href="#size-属性" class="headerlink" title="size 属性"></a><code>size</code> 属性</h4><p><code>size</code>属性返回map的成员总数</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lasso"> <span class="hljs-keyword">let</span> <span class="hljs-built_in">map</span> = <span class="hljs-literal">new</span> <span class="hljs-built_in">Map</span>()<br> <span class="hljs-built_in">map</span>.<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">1</span>)<br> <span class="hljs-built_in">map</span>.<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-number">2</span>)<br><span class="hljs-comment">// map.size == 3</span><br></code></pre></td></tr></table></figure><h4 id="set-key-value"><a href="#set-key-value" class="headerlink" title="set(key, value)"></a><code>set(key, value)</code></h4><p><code>set</code>方法设置键名<code>key</code>对应的键值为value<code>，</code>然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br><span class="hljs-keyword">let</span> a = <span class="hljs-string">&quot;abc&quot;</span><br>m.<span class="hljs-title function_">set</span>(a, <span class="hljs-number">3</span>) <span class="hljs-comment">//键是变量</span><br>m.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;edition&quot;</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// 键是字符串</span><br>m.<span class="hljs-title function_">set</span>(<span class="hljs-number">262</span>, <span class="hljs-string">&quot;standard&quot;</span>) <span class="hljs-comment">// 键是数值</span><br>m.<span class="hljs-title function_">set</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-string">&quot;nah&quot;</span>) <span class="hljs-comment">// 键是 undefined</span><br></code></pre></td></tr></table></figure><p><code>set()</code>方法返回的是当前的Map对象，因此可以采用链式写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-string">&quot;abc&quot;</span><br><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>().<span class="hljs-title function_">set</span>(a, <span class="hljs-number">3</span>).<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;edition&quot;</span>, <span class="hljs-number">6</span>).<span class="hljs-title function_">set</span>(<span class="hljs-number">262</span>, <span class="hljs-string">&quot;standard&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="get-key"><a href="#get-key" class="headerlink" title="get(key)"></a><code>get(key)</code></h4><p><code>get()</code> 方法读取key所对应的键值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>     [<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">1</span>]<br> ])<br>map.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;foo&quot;</span>) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h4 id="has-key"><a href="#has-key" class="headerlink" title="has(key)"></a><code>has(key)</code></h4><p><code>has()</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>     [<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">1</span>]<br> ])<br>map.<span class="hljs-title function_">has</span>(<span class="hljs-string">&quot;foo&quot;</span>) <span class="hljs-comment">// true</span><br>map.<span class="hljs-title function_">has</span>(<span class="hljs-string">&quot;bar&quot;</span>) <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h4 id="delete-key"><a href="#delete-key" class="headerlink" title="delete(key)"></a><code>delete(key)</code></h4><p><code>delete()</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回false</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>    [<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">1</span>]<br>])<br>map.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&quot;foo&quot;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">has</span>(<span class="hljs-string">&quot;foo&quot;</span>)) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h4 id="clear"><a href="#clear" class="headerlink" title="clear()"></a><code>clear()</code></h4><p><code>clear()</code>方法清除所有成员，没有返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>     [<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">1</span>],<br>     [<span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-number">2</span>]<br> ])<br> map.<span class="hljs-title function_">clear</span>()<br> map.<span class="hljs-property">size</span> <span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure><h3 id="map-的遍历操作"><a href="#map-的遍历操作" class="headerlink" title="map 的遍历操作"></a>map 的遍历操作</h3><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。 </p><ul><li><code>keys()</code>: 返回键名的遍历器。 </li><li><code>values()</code>: 返回键值的遍历器。 </li><li><code>entries()</code>: 返回所有成员的遍历器。 </li><li><code>forEach()</code>: 遍历 Map 的所有成员</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>    [<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-number">2</span>]<br>])<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> map.<span class="hljs-title function_">keys</span>()) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key)<br>&#125;<br><span class="hljs-comment">// foo , bar </span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> map.<span class="hljs-title function_">values</span>()) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br>&#125;<br><span class="hljs-comment">// 1 , 2</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> map.<span class="hljs-title function_">entries</span>()) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item)<br>&#125;<br><span class="hljs-comment">// [&quot;foo&quot;, 1] , [&quot;bar&quot;, 2]</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> map.<span class="hljs-title function_">entries</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, value)<br>&#125;<br><span class="hljs-comment">// [&quot;foo&quot;, 1] , [&quot;bar&quot;, 2]</span><br><br><span class="hljs-comment">// 等同于使用map.entries()</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> map) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, value);<br>&#125;<br><span class="hljs-comment">// [&quot;foo&quot;, 1] , [&quot;bar&quot;, 2]</span><br></code></pre></td></tr></table></figure><p>上面代码最后的那个例子，表示 Map 结构的默认遍历器接口(<code>Symbol.iterator</code>属性)，就是<code>entries()</code>方法</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">map[Symbol.iterator] <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> map.entries<br>// true<br></code></pre></td></tr></table></figure><p>结合数组的<code>map</code>方法、<code>filter</code>方法，可以实现 Map 的遍历和过滤(Map 本身没有<code>map</code>和<code>filter</code>方法)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> map0 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>().<span class="hljs-title function_">set</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;a&quot;</span>).<span class="hljs-title function_">set</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;b&quot;</span>).<span class="hljs-title function_">set</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;c&quot;</span>)<br><br><span class="hljs-keyword">const</span> map1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([...map0].<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">[k, v]</span>) =&gt;</span> k &lt; <span class="hljs-number">3</span>))<br><span class="hljs-comment">// 产生 Map 结构 &#123;1 =&gt; &#x27;a&#x27;, 2 =&gt; &#x27;b&#x27;&#125;</span><br><br><span class="hljs-keyword">const</span> map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([...map0].<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">[k, v]</span>) =&gt;</span> [k * <span class="hljs-number">2</span>, <span class="hljs-string">&quot;_&quot;</span> + v]))<br><span class="hljs-comment">// 产生 Map 结构 &#123;2 =&gt; &#x27;_a&#x27;, 4 =&gt; &#x27;_b&#x27;, 6 =&gt; &#x27;_c&#x27;&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ajax跨域</title>
    <link href="/2021/12/05/Ajax/Ajax%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/"/>
    <url>/2021/12/05/Ajax/Ajax%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="Ajax跨域"><a href="#Ajax跨域" class="headerlink" title="Ajax跨域"></a>Ajax跨域</h1><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。<br><strong>所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）</strong></p><span id="more"></span><h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域</p><table><thead><tr><th>当前页面url</th><th align="center">被请求页面url</th><th align="center">是否跨域</th><th>原因</th></tr></thead><tbody><tr><td><a href="http://www.test.com/">http://www.test.com/</a></td><td align="center"><a href="http://www.test.com/index.html">http://www.test.com/index.html</a></td><td align="center">否</td><td>同源（协议、域名、端口号相同）</td></tr><tr><td><a href="http://www.test.com/">http://www.test.com/</a></td><td align="center"><a href="https://www.test.com/index.html">https://www.test.com/index.html</a></td><td align="center">跨域</td><td>协议不同（http&#x2F;https）</td></tr><tr><td><a href="http://www.test.com/">http://www.test.com/</a></td><td align="center"><a href="http://www.baidu.com/">http://www.baidu.com/</a></td><td align="center">跨域</td><td>主域名不同（test&#x2F;baidu）</td></tr><tr><td><a href="http://www.test.com/">http://www.test.com/</a></td><td align="center"><a href="http://blog.test.com/">http://blog.test.com/</a></td><td align="center">跨域</td><td>子域名不同（www&#x2F;blog）</td></tr><tr><td><a href="http://www.test.com:8080/">http://www.test.com:8080/</a></td><td align="center"><a href="http://www.test.com:7001/">http://www.test.com:7001/</a></td><td align="center">跨域</td><td>端口号不同（8080&#x2F;7001）</td></tr></tbody></table><h2 id="非同源限制"><a href="#非同源限制" class="headerlink" title="非同源限制"></a>非同源限制</h2><ul><li><p>无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB</p></li><li><p>无法接触非同源网页的 DOM</p></li><li><p>无法向非同源地址发送 AJAX 请求</p></li></ul><h2 id="跨域解决方法"><a href="#跨域解决方法" class="headerlink" title="跨域解决方法"></a>跨域解决方法</h2><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，兼容性好（兼容低版本IE），缺点是只支持get请求，不支持post请求。</p><p>核心思想：网页通过添加一个<code>&lt;script&gt;</code>元素，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。</p><pre><code class="hljs">    // 处理服务器返回回调函数的数据    &lt;script type=&quot;text/javascript&quot;&gt;        function dosomething(res)&#123;            // 处理获得的数据            console.log(res.data)        &#125;    &lt;/script&gt;    // 向服务器127.0.0.1:8000/test发出请求，            该请求的查询字符串有一个callback参数，用来指定回调函数的名字    &lt;script src=&quot;http://127.0.0.1:8000/test?callback=dosomething&quot;&gt;&lt;/script&gt;        // node 部分    app.all(&#39;/test&#39;,(request, response) =&gt; &#123;        // response.send(&#39;console.log(&quot;hello jsonp&quot;)&#39;);        const data = &#123;            data: &quot;data&quot;        &#125;;        //将数据转化为字符串        let str = JSON.stringify(data)        //返回结果        response.end(`dosomething($&#123;str&#125;)`)        // 返回的结果 dosomething(&#123;&quot;data&quot;:&quot;data&quot;&#125;)    &#125;)</code></pre><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS 是跨域资源分享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法<br>服务器端对于CORS的支持，主要是通过设置<code>Access-Control-Allow-Origin</code>来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问</p><pre><code class="hljs">    // node    app.all(&#39;/cors-server&#39;, (request, response)=&gt;&#123;        //设置响应头        response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)        // response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:5500&quot;)        response.send(&#39;hello CORS&#39;);    &#125;)</code></pre>]]></content>
    
    
    <categories>
      
      <category>Ajax</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ajax</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fetch</title>
    <link href="/2021/11/24/Ajax/Fetch/"/>
    <url>/2021/11/24/Ajax/Fetch/</url>
    
    <content type="html"><![CDATA[<h1 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h1><p>fetch 是一种 HTTP 数据请求的方式，是 XMLHttpRequest 的一种替代方案。fetch 不是 ajax 的进一步封装，而是原生 js。Fetch 函数就是原生 js，没有使用 XMLHttpRequest 对象</p><span id="more"></span><h2 id="Fetch-的参数"><a href="#Fetch-的参数" class="headerlink" title="Fetch 的参数"></a>Fetch 的参数</h2><ul><li><code>url</code> ,该参数定义要获取的资源,可以是一个 url 字符串,也可以是一个 Request 对象</li><li><code>options</code> ,该参数可选,为一个对象,内部含有一些对请求的设置属性<ul><li><code>method</code>:请求使用的方法。如:GET、POST 等 </li><li><code>headers</code>:请求头信息。形式为 Headers 对象或 ByteString </li><li><code>body</code>:请求的 body 信息,可能是一个 Blob、BufferSource、FormData、URLSearchParams 或者 USVString 对象。注意 GET 或 HEAD 方法的请求不能包含 body 信息 </li><li><code>mode</code>:请求的模式。如 cors、no-cors 或者 same-origin </li><li><code>credentiala</code>:请求的 credentials。如 omit、same-origin 或者 include </li><li><code>cache</code>:请求的 cache 模式:default,no-store,reload,no-cache 或者 only-if-cached</li></ul></li></ul><h3 id="response-对象"><a href="#response-对象" class="headerlink" title="response 对象"></a>response 对象</h3><p>response 为一个 Promise 对象成功时传回的对象,该属性含有对应返回数据的属性和方法</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul><li><code>status</code> (number),HTTP 请求结果参数,在 100-599 范围 </li><li><code>statusText</code> (string),服务器返回的状态报告 </li><li><code>ok</code> (boolean),如果返回 200 表示请求成功则为 true </li><li><code>headers</code> (Headers),返回头部信息,该属性后面也有对应的方法 </li><li><code>has(name)</code> (boolean),判断是否存在该信息头 </li><li><code>get(name)</code> (string),获取信息头的数据 </li><li><code>getAll(name)</code> (Array),获取所有头部数据 </li><li><code>set(name,value)</code>,设置请求头信息 </li><li><code>append(name,value)</code>,添加 header 的内容 </li><li><code>delete(name)</code>,删除 header 的信息 </li><li><code>forEach(function(value,name)&#123;...&#125;,[thisContext])</code>,循环读取 header 的信息 </li><li><code>url</code> (string),详细的地址</li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li><code>text()</code>,以 string 的形式生成请求 text </li><li><code>json()</code>,生成 JSON.parse(responseText)的结果 </li><li><code>blob()</code>,生成一个 Blob </li><li><code>arrayBuffer()</code>,生成一个 ArrayBuffer </li><li><code>formData()</code>,生成格式化数据,可用于其它的请求</li></ul><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul><li><code>clone()</code>,创建一个 Response 对象的克隆 </li><li><code>Response.error()</code>,返回一个绑定了网络错误的新的 Response 对象 </li><li><code>Response.redirect()</code>,用另一个 URL 创建一个新的 Resonse 对象</li></ul><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><pre><code class="hljs">    fetch(&quot;a.html&quot;)        .then(function (response) &#123;            return response.text()        &#125;)        .then(function (response) &#123;            document.body.innerHTML = response        &#125;)</code></pre><h3 id="post"><a href="#post" class="headerlink" title="post"></a>post</h3><pre><code class="hljs">    fetch(&quot;a.html&quot;, &#123;        method: &quot;POST&quot;,        headers: &#123;            &quot;Accept&quot;: &quot;application/json&quot;,            &quot;Content-Type&quot;: &quot;application/json&quot;;        &#125;,        body: JSON.stringify(&#123;            user: &quot;zhangsan&quot;,            pwd: 123456;        &#125;)    &#125;)</code></pre><h2 id="与原生-Ajax-的比较"><a href="#与原生-Ajax-的比较" class="headerlink" title="与原生 Ajax 的比较"></a>与原生 Ajax 的比较</h2><h3 id="原生-Ajax"><a href="#原生-Ajax" class="headerlink" title="原生 Ajax"></a>原生 Ajax</h3><pre><code class="hljs">    var Ajax = new XMLHttpRequest()    Ajax.open(&quot;GET&quot;, url)    Ajax.responseType = &quot;json&quot;    Ajax.send()    Ajax.onreadystatechange = function () &#123;        console.log(Ajax.response)    &#125;    Ajax.onerror = function () &#123;        console.log(&quot;error&quot;)    &#125;</code></pre><h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><pre><code class="hljs">    fetch(url).then(function (response) &#123;        return response.json() //相当于JSON.parse(response);    &#125;).then(function (data) &#123;        console.log(data)    &#125;).catch(function (err) &#123;        console.log(&quot;error&quot;, err)    &#125;);        //使用箭头函数    fetch(url).then(        response =&gt; response.json()    ).then(        data =&gt; console.log(data)    ).catch(        err =&gt; console.log(&quot;error&quot;, err)    );        //使用async函数    let Fetch = async function () &#123;        try &#123;            let response = await fetch(url)            let data = await response.json()            console.log(data)        &#125; catch (err) &#123;            console.log(&quot;error&quot;, err)        &#125;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Ajax</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ajax</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Axios</title>
    <link href="/2021/11/24/Ajax/Axios/"/>
    <url>/2021/11/24/Ajax/Axios/</url>
    
    <content type="html"><![CDATA[<h1 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h1><h2 id="创建-API"><a href="#创建-API" class="headerlink" title="创建 API"></a>创建 API</h2><h3 id="API-的分类"><a href="#API-的分类" class="headerlink" title="API 的分类"></a>API 的分类</h3><ol><li>REST API: restful （Representational State Transfer (资源)表现层状态转化）<ol><li>发送请求进行CRUD 哪个操作由请求方式来决定</li><li>同一个请求路径可以进行多个操作</li><li>请求方式会用到GET&#x2F;POST&#x2F;PUT&#x2F;DELETE</li></ol></li><li>非REST API: restless<ol><li>请求方式不决定请求的CRUD 操作</li><li>一个请求路径只对应一个操作</li><li>一般只有GET&#x2F;POST</li></ol></li></ol><span id="more"></span><h3 id="使用json-server-搭建REST-API"><a href="#使用json-server-搭建REST-API" class="headerlink" title="使用json-server 搭建REST API"></a>使用<a href="https://github.com/typicode/json-server">json-server</a> 搭建REST API</h3><h4 id="json-server"><a href="#json-server" class="headerlink" title="json-server"></a>json-server</h4><p>json-server 是用来快速搭建REST API 的工具包</p><h4 id="使用json-server"><a href="#使用json-server" class="headerlink" title="使用json-server"></a>使用json-server</h4><ol><li><a href="https://github.com/typicode/json-server">在线文档: https://github.com/typicode/json-server</a></li><li>下载: <code>npm install -g json-server</code></li><li>目标根目录下创建数据库 json 文件: <code>db.json</code></li></ol><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br><span class="hljs-string">&quot;posts&quot;</span>: [<br>&#123; <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;json-server&quot;</span>, <span class="hljs-string">&quot;author&quot;</span>: <span class="hljs-string">&quot;typicode&quot;</span> &#125;,<br>&#123; <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;json-server2&quot;</span>, <span class="hljs-string">&quot;author&quot;</span>: <span class="hljs-string">&quot;typicode&quot;</span> &#125;<br>],<br><span class="hljs-string">&quot;comments&quot;</span>: [<br>&#123; <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;body&quot;</span>: <span class="hljs-string">&quot;some comment&quot;</span>, <span class="hljs-string">&quot;postId&quot;</span>: <span class="hljs-number">1</span> &#125;<br>],<br><span class="hljs-string">&quot;profile&quot;</span>: &#123; <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;typicode&quot;</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>启动服务器执行命令: <code>json-server --watch db.json</code></li><li>使用浏览器访问测试 <code>http://localhost:3000/posts</code></li></ol><h2 id="XHR-的-ajax封装-简单版axios"><a href="#XHR-的-ajax封装-简单版axios" class="headerlink" title="XHR 的 ajax封装 (简单版axios)"></a>XHR 的 ajax封装 (简单版axios)</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>函数的返回值为<code>promise</code>, 成功的结果为<code>response</code>, 失败的结果为<code>error</code></li><li>能处理多种类型的请求: GET&#x2F;POST&#x2F;PUT&#x2F;DELETE</li><li>函数的参数为一个配置对象</li></ol><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl">&#123;<br>url: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-regexp">//</span> 请求地址<br><span class="hljs-function"><span class="hljs-keyword">method</span>: &#x27;&#x27;, // 请求方式<span class="hljs-title">GET</span>/<span class="hljs-title">POST</span>/<span class="hljs-title">PUT</span>/<span class="hljs-title">DELETE</span></span><br><span class="hljs-function"><span class="hljs-title">params</span>: </span>&#123;&#125;, <span class="hljs-regexp">//</span> GET/DELETE 请求的 query 参数<br>data: &#123;&#125;, <span class="hljs-regexp">//</span> POST/PUT 请求的请求体参数<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>响应 <code>json</code>数据 自动解析为 <code>js</code>的对象&#x2F;数组</li></ol><h3 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">axios</span>(<span class="hljs-params">&#123; url, method = <span class="hljs-string">&#x27;GET&#x27;</span>, params = &#123;&#125;, data = &#123;&#125; &#125;</span>) &#123;<br>    <span class="hljs-comment">// 返回一个promise对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 处理method 转大写</span><br>        method = method.<span class="hljs-title function_">toUpperCase</span>()<br><br>        <span class="hljs-comment">// 处理 query参数（拼接到url上）id=1&amp;xxx=abc</span><br>        <span class="hljs-keyword">let</span> queryString = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(params).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;<br>            queryString += <span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;params[key]&#125;</span>&amp;`</span><br>        &#125;)<br>        <span class="hljs-keyword">if</span> (queryString) &#123;<br>            <span class="hljs-comment">// 去除最后的&#x27;&amp;&#x27;</span><br>            queryString = queryString.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, queryString.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>)<br>            <span class="hljs-comment">// 接到url</span><br>            url += <span class="hljs-string">&#x27;?&#x27;</span> + queryString<br>        &#125;<br><br>        <span class="hljs-comment">// 1. 执行异步Ajax请求</span><br>        <span class="hljs-comment">// 创建xhr对象</span><br>        <span class="hljs-keyword">const</span> request = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>        <span class="hljs-comment">// 打开连接（初始化请求，没有请求）</span><br>        request.<span class="hljs-title function_">open</span>(method, url, <span class="hljs-literal">true</span>)<br>        <span class="hljs-comment">// 发送请求</span><br>        <span class="hljs-keyword">if</span> (method === <span class="hljs-string">&#x27;GET&#x27;</span> || method === <span class="hljs-string">&#x27;DELETE&#x27;</span>) &#123;<br>            request.<span class="hljs-title function_">send</span>() <span class="hljs-comment">// undefined</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method === <span class="hljs-string">&#x27;POST&#x27;</span> || method === <span class="hljs-string">&#x27;PUT&#x27;</span>) &#123;<br>            <span class="hljs-comment">// 设置请求头，告诉服务器请求体的格式是json</span><br>            request.<span class="hljs-title function_">setRequestHeader</span>(<br>                <span class="hljs-string">&#x27;Content-Type&#x27;</span>,<br>                <span class="hljs-string">&#x27;appliaction/json;charset=utf-8&#x27;</span><br>            )<br>            <span class="hljs-comment">// 发送json格式请求参数</span><br>            request.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data)) <span class="hljs-comment">// 异步执行</span><br>        &#125;<br><br>        <span class="hljs-comment">// 绑定状态改变的监听</span><br>        request.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-comment">// 同步执行</span><br>            <span class="hljs-comment">// 如果请求没有完成，直接结束</span><br>            <span class="hljs-keyword">if</span> (request.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) &#123;<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            <span class="hljs-comment">// 如果响应状态码在[200, 300)之间代表成功，否则失败</span><br>            <span class="hljs-keyword">const</span> &#123; status, statusText &#125; = request<br>            <span class="hljs-keyword">if</span> (status &gt;= <span class="hljs-number">200</span> &amp;&amp; status &lt;= <span class="hljs-number">299</span>) &#123;<br>                <span class="hljs-comment">// 2.1 如果请求成功，调用resolve()</span><br>                <span class="hljs-comment">// 准备结果数据对象response</span><br>                <span class="hljs-keyword">const</span> response = &#123;<br>                    <span class="hljs-attr">data</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(request.<span class="hljs-property">response</span>),<br>                    status,<br>                    statusText,<br>                &#125;<br>                <span class="hljs-title function_">resolve</span>(response)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 2.2 如果请求失败，调用reject()</span><br>                <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;request error status is &#x27;</span> + status))<br>            &#125;<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用测试"><a href="#使用测试" class="headerlink" title="使用测试"></a>使用测试</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. GET请求：从服务器端获取数据</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">testGet</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">axios</span>(&#123;<br>        <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://localhost:3000/posts&#x27;</span>,<br>        <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span>,<br>        <span class="hljs-attr">params</span>: &#123;<br>            <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>            <span class="hljs-attr">xxx</span>: <span class="hljs-string">&#x27;abc&#x27;</span>,<br>        &#125;,<br>    &#125;).<span class="hljs-title function_">then</span>(<br>        <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response)<br>        &#125;,<br>        <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>            <span class="hljs-title function_">alert</span>(error.<span class="hljs-property">message</span>)<br>        &#125;<br>    )<br>&#125;<br><br><span class="hljs-comment">// 2. POST请求：向服务器端添加数据</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">testPost</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">axios</span>(&#123;<br>        <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://localhost:3000/posts&#x27;</span>,<br>        <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>        <span class="hljs-attr">data</span>: &#123;<br>            <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;json-server_post&#x27;</span>,<br>            <span class="hljs-attr">author</span>: <span class="hljs-string">&#x27;typicode_post&#x27;</span>,<br>        &#125;,<br>    &#125;).<span class="hljs-title function_">then</span>(<br>        <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response)<br>        &#125;,<br>        <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>            <span class="hljs-title function_">alert</span>(error.<span class="hljs-property">message</span>)<br>        &#125;<br>    )<br>&#125;<br><span class="hljs-comment">// 3. PUT请求：服务器更新数据</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">testPut</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">axios</span>(&#123;<br>        <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://localhost:3000/posts/1&#x27;</span>,<br>        <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;PUT&#x27;</span>,<br>        <span class="hljs-attr">data</span>: &#123;<br>            <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;json-server_put&#x27;</span>,<br>            <span class="hljs-attr">author</span>: <span class="hljs-string">&#x27;typicode_put&#x27;</span>,<br>        &#125;,<br>    &#125;).<span class="hljs-title function_">then</span>(<br>        <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response)<br>        &#125;,<br>        <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>            <span class="hljs-title function_">alert</span>(error.<span class="hljs-property">message</span>)<br>        &#125;<br>    )<br>&#125;<br><br><span class="hljs-comment">// 4. DELETE请求：服务器删除数据</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">testDelete</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">axios</span>(&#123;<br>        <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://localhost:3000/posts/2&#x27;</span>,<br>        <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;delete&#x27;</span>,<br>    &#125;).<span class="hljs-title function_">then</span>(<br>        <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response)<br>        &#125;,<br>        <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>            <span class="hljs-title function_">alert</span>(error.<span class="hljs-property">message</span>)<br>        &#125;<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="axios-的理解和使用"><a href="#axios-的理解和使用" class="headerlink" title="axios 的理解和使用"></a>axios 的理解和使用</h2><h3 id="axios-是什么"><a href="#axios-是什么" class="headerlink" title="axios 是什么"></a>axios 是什么</h3><ol><li>前端最流行的 ajax请求库</li><li>react&#x2F;vue 官方都推荐使用 axios 发ajax 请求</li><li><a href="https://github.com/axios/axios">文档: https://github.com/axios/axios</a></li></ol><h3 id="axios-特点"><a href="#axios-特点" class="headerlink" title="axios 特点"></a>axios 特点</h3><ol><li>基于 xhr + promise 的异步 ajax请求库</li><li>浏览器端&#x2F;node 端都可以使用</li><li>支持请求／响应拦截器</li><li>支持请求取消</li><li>请求&#x2F;响应数据转换</li><li>批量发送多个请求</li></ol><h3 id="axios-常用语法"><a href="#axios-常用语法" class="headerlink" title="axios 常用语法"></a>axios 常用语法</h3><ul><li><code>axios(config)</code>: 通用&#x2F;最本质的发任意类型请求的方式</li><li><code>axios(url[, config])</code>: 可以只指定url 发get 请求</li><li><code>axios.request(config)</code>: 等同于axios(config)</li><li><code>axios.get(url[, config])</code>: 发get 请求</li><li><code>axios.delete(url[, config])</code>: 发delete 请求</li><li><code>axios.post(url[, data, config])</code>: 发post 请求</li><li><code>axios.put(url[, data, config])</code>: 发put 请求</li><li><code>axios.defaults.xxx</code>: 请求的默认全局配置（method\baseURL\params\timeout…）</li><li><code>axios.interceptors.request.use()</code>: 添加请求拦截器</li><li><code>axios.interceptors.response.use()</code>: 添加响应拦截器</li><li><code>axios.create([config])</code>: 创建一个新的axios(它没有下面的功能)</li><li><code>axios.Cancel()</code>: 用于创建取消请求的错误对象</li><li><code>axios.CancelToken()</code>: 用于创建取消请求的 token 对象</li><li><code>axios.isCancel()</code>: 是否是一个取消请求的错误</li><li><code>axios.all(promises)</code>: 用于批量执行多个异步请求</li><li><code>axios.spread()</code>: 用来指定接收所有成功数据的回调函数的方法</li></ul><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><h4 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 为给定 ID 的 user 创建请求</span><br>axios<br>    .get(<span class="hljs-string">&#x27;/user?ID=12345&#x27;</span>)<br>    .then(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(response)<br>    &#125;)<br>    .<span class="hljs-keyword">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(error)<br>    &#125;)<br><br><span class="hljs-comment">// 可选地，上面的请求可以这样做</span><br>axios<br>    .get(<span class="hljs-string">&#x27;/user&#x27;</span>, &#123;<br>        <span class="hljs-attr">params</span>: &#123;<br>            <span class="hljs-attr">ID</span>: <span class="hljs-number">12345</span>,<br>        &#125;,<br>    &#125;)<br>    .then(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(response)<br>    &#125;)<br>    .<span class="hljs-keyword">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(error)<br>    &#125;)<br></code></pre></td></tr></table></figure><h4 id="通过语法糖发送GET请求"><a href="#通过语法糖发送GET请求" class="headerlink" title="通过语法糖发送GET请求"></a>通过语法糖发送GET请求</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">axios</span><span class="hljs-params">(config)</span></span><br><br><span class="hljs-comment">// 发送 POST 请求</span><br><span class="hljs-built_in">axios</span>(&#123;<br>    method: <span class="hljs-string">&#x27;post&#x27;</span>,<br>    url: <span class="hljs-string">&#x27;/user/12345&#x27;</span>,<br>    data: &#123;<br>        firstName: <span class="hljs-string">&#x27;Fred&#x27;</span>,<br>        lastName: <span class="hljs-string">&#x27;Flintstone&#x27;</span>,<br>    &#125;,<br>&#125;)<br><br><span class="hljs-comment">// 发送 GET 请求（默认的方法）</span><br><span class="hljs-function"><span class="hljs-title">axios</span><span class="hljs-params">(<span class="hljs-string">&#x27;/user/12345&#x27;</span>)</span></span><br><br><span class="hljs-comment">// 发送 GET 请求（axios.get方法）</span><br>axios<span class="hljs-selector-class">.get</span>(<span class="hljs-string">&#x27;/user/12345&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="重点注意"><a href="#重点注意" class="headerlink" title="重点注意"></a>重点注意</h2><h3 id="axios-create-config"><a href="#axios-create-config" class="headerlink" title="axios.create(config)"></a><code>axios.create(config)</code></h3><ol><li>根据指定配置创建一个新的 axios, 也就是每个新 axios 都有自己的配置</li><li>新 axios 只是没有<strong>取消请求</strong>和<strong>批量发请求</strong>的方法, 其它所有语法都是一致的</li><li>为什么要设计这个语法?<ul><li>需求: 项目中有部分接口需要的配置与另一部分接口需要的配置不太一样, 如何处理（比如有多个baseURL需要指定）</li><li>解决: 创建2 个新axios, 每个都有自己特有的配置, 分别应用到不同要求的接口请求中</li></ul></li></ol><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs smali">const<span class="hljs-built_in"> instance </span>= axios.create(&#123;<br>    // instance是函数类型<br>    baseURL: &#x27;http://localhost:3000&#x27;,<br>&#125;)<br>// 使用instance发Ajax请求<br>instance(&#123;<br>    url: &#x27;/posts&#x27;,<br>&#125;)<br>instance.get(&#x27;/posts&#x27;)<br><br></code></pre></td></tr></table></figure><h3 id="拦截器函数的调用顺序"><a href="#拦截器函数的调用顺序" class="headerlink" title="拦截器函数的调用顺序"></a>拦截器函数的调用顺序</h3><ol><li>说明: 调用<code>axios()</code>并不是立即发送ajax 请求, 而是需要经历一个较长的流程</li><li>流程: 请求拦截器2 &#x3D;&gt; 请求拦截器1 &#x3D;&gt; 发ajax 请求 &#x3D;&gt; 响应拦截器1 &#x3D;&gt; 响应拦截器2 &#x3D;&gt; 请求的回调</li><li>注意: 此流程是通过 promise 串连起来的, 请求拦截器传递的是<code>config</code>, 响应拦截器传递的是<code>response</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 添加两个请求拦截器(回调函数)</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>    <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;request interceptor1 onResolved()&#x27;</span>) <span class="hljs-comment">// -----------2</span><br>        <span class="hljs-keyword">return</span> config<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;request interceptor1 onRejected()&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>    &#125;<br>)<br><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>    <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;request interceptor2 onResolved()&#x27;</span>) <span class="hljs-comment">// -----------1</span><br>        <span class="hljs-keyword">return</span> config<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;request interceptor2 onRejected()&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>    &#125;<br>)<br><br><span class="hljs-comment">// 添加两个响应拦截器</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>    <span class="hljs-function">(<span class="hljs-params">resopnse</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;response interceptor1 onResolved()&#x27;</span>) <span class="hljs-comment">// -----------3</span><br>        <span class="hljs-keyword">return</span> resopnse<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;response interceptor1 onRejected()&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>    &#125;<br>)<br><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>    <span class="hljs-function">(<span class="hljs-params">resopnse</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;response interceptor2 onResolved()&#x27;</span>) <span class="hljs-comment">// -----------4</span><br>        <span class="hljs-keyword">return</span> resopnse<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;response interceptor2 onRejected()&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>    &#125;<br>)<br><br>axios<br>    .<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://localhost:3000/posts&#x27;</span>)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;data&#x27;</span>, response.<span class="hljs-property">data</span>) <span class="hljs-comment">//data Array(4) -------------5</span><br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>        cosole.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;error&#x27;</span>, error.<span class="hljs-property">message</span>)<br>    &#125;)<br><br><span class="hljs-comment">// request interceptor2 onResolved()</span><br><span class="hljs-comment">// request interceptor1 onResolved()</span><br><span class="hljs-comment">// response interceptor1 onResolved()</span><br><span class="hljs-comment">// response interceptor2 onResolved()</span><br><span class="hljs-comment">// data Array(4)</span><br></code></pre></td></tr></table></figure><h3 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h3><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><ol><li>配置 <code>cancelToken</code> 对象</li><li>缓存用于取消请求的 <code>cancel</code> 函数</li><li>在后面特定时机调用 <code>cancel</code> 函数取消请求</li><li>在错误回调中判断如果 <code>error</code> 是 <code>cancel</code>, 做相应处理</li></ol><h4 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h4><p>在请求一个接口前, 取消前面一个未完成的请求</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let cancel <span class="hljs-comment">// 用于保存取消请求的函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getProducts1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 在准备发请求前，取消未完成的请求</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">typeof</span> cancel === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        cancel(<span class="hljs-string">&#x27;取消请求&#x27;</span>)<br>    &#125;<br>    axios(&#123;<br>        <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://localhost:4000/products1&#x27;</span>,<br>        <span class="hljs-attr">cancelToken</span>: <span class="hljs-keyword">new</span> axios.CancelToken(<span class="hljs-keyword">function</span> <span class="hljs-title function_">executor</span>(<span class="hljs-params">c</span>) &#123;<br>            <span class="hljs-comment">// c是用于取消当前请求的函数</span><br>            <span class="hljs-comment">// 保存取消函数，用于之后可能需要取消当前请求</span><br>            cancel = c<br>        &#125;),<br>    &#125;).then(<br>        <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>            cancel = <span class="hljs-literal">null</span><br>            <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;请求1成功了&#x27;</span>, response.data)<br>        &#125;,<br>        (error) =&gt; &#123;<br>            <span class="hljs-keyword">if</span> (axios.isCancel(error)) &#123;<br>                <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;请求1取消的错误&#x27;</span>, error.message)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 请求出错了</span><br>                cancel = <span class="hljs-literal">null</span><br>                <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;请求1失败了&#x27;</span>, error.message, error) <span class="hljs-comment">// 请求1失败了 强制取消请求 Cancel &#123;message: &quot;强制取消请求&quot;&#125;</span><br>            &#125;<br>        &#125;<br>    )<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getProducts2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 在准备发请求前，取消未完成的请求</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">typeof</span> cancel === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        cancel(<span class="hljs-string">&#x27;取消请求&#x27;</span>)<br>    &#125;<br>    axios(&#123;<br>        <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://localhost:4000/products2&#x27;</span>,<br>        <span class="hljs-attr">cancelToken</span>: <span class="hljs-keyword">new</span> axios.CancelToken(<span class="hljs-keyword">function</span> <span class="hljs-title function_">executor</span>(<span class="hljs-params">c</span>) &#123;<br>            cancel = c<br>        &#125;),<br>    &#125;).then(<br>        <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>            cancel = <span class="hljs-literal">null</span><br>            <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;请求2成功了&#x27;</span>, response.data)<br>        &#125;,<br>        (error) =&gt; &#123;<br>            <span class="hljs-keyword">if</span> (axios.isCancel(error)) &#123;<br>                <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;请求2取消的错误&#x27;</span>, error.message)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cancel = <span class="hljs-literal">null</span><br>                <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;请求2失败了&#x27;</span>, error.message, error)<br>            &#125;<br>        &#125;<br>    )<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">cancelReq</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 执行取消请求的函数</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">typeof</span> cancel === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        cancel(<span class="hljs-string">&#x27;强制取消请求&#x27;</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;没有可取消的请求&#x27;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用拦截器，减少重复代码"><a href="#使用拦截器，减少重复代码" class="headerlink" title="使用拦截器，减少重复代码"></a>使用拦截器，减少重复代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 添加请求拦截器</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 只写一个成功的回调</span><br>    <span class="hljs-comment">// 在准备发请求前，取消未完成的请求</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> cancel === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-title function_">cancel</span>(<span class="hljs-string">&#x27;取消请求&#x27;</span>)<br>    &#125;<br>    <span class="hljs-comment">// 添加一个cancelToken的配置</span><br>    config.<span class="hljs-property">cancelToken</span> = <span class="hljs-keyword">new</span> axios.<span class="hljs-title class_">CancelToken</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">executor</span>(<span class="hljs-params">c</span>) &#123;<br>        <span class="hljs-comment">// c是用于取消当前请求的函数</span><br>        <span class="hljs-comment">// 保存取消函数，用于之后可能需要取消当前请求</span><br>        cancel = c<br>    &#125;)<br>    <span class="hljs-keyword">return</span> config<br>&#125;)<br><br><span class="hljs-comment">// 添加响应拦截器</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>    <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 成功的回调</span><br>        cancel = <span class="hljs-literal">null</span><br>        <span class="hljs-keyword">return</span> response<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 失败的回调</span><br>        <span class="hljs-keyword">if</span> (axios.<span class="hljs-title function_">isCancel</span>(error)) &#123;<br>            <span class="hljs-comment">// 请求取消的错误</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求取消的错误&#x27;</span>, error.<span class="hljs-property">message</span>)<br>            <span class="hljs-comment">// 中断promise链</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 请求出错了</span><br>            cancel = <span class="hljs-literal">null</span><br>            <span class="hljs-comment">// 将错误向下传递</span><br>            <span class="hljs-comment">// throw error</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>        &#125;<br>    &#125;<br>)<br><br><span class="hljs-keyword">let</span> cancel <span class="hljs-comment">// 用于保存取消请求的函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getProducts1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">axios</span>(&#123;<br>        <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://localhost:4000/products1&#x27;</span>,<br>    &#125;).<span class="hljs-title function_">then</span>(<br>        <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求1成功了&#x27;</span>, response.<span class="hljs-property">data</span>)<br>        &#125;,<br>        <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">// 只用处理请求失败的情况，取消请求的错误不用处理</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求1失败了&#x27;</span>, error.<span class="hljs-property">message</span>, error)<br>        &#125;<br>    )<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getProducts2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">axios</span>(&#123;<br>        <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://localhost:4000/products2&#x27;</span>,<br>    &#125;).<span class="hljs-title function_">then</span>(<br>        <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求2成功了&#x27;</span>, response.<span class="hljs-property">data</span>)<br>        &#125;,<br>        <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求2失败了&#x27;</span>, error.<span class="hljs-property">message</span>, error)<br>        &#125;<br>    )<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">cancelReq</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> cancel === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-title function_">cancel</span>(<span class="hljs-string">&#x27;强制取消请求&#x27;</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;没有可取消的请求&#x27;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Ajax</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ajax</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原生Ajax</title>
    <link href="/2021/11/22/Ajax/%E5%8E%9F%E7%94%9FAjax/"/>
    <url>/2021/11/22/Ajax/%E5%8E%9F%E7%94%9FAjax/</url>
    
    <content type="html"><![CDATA[<h1 id="原生Ajax"><a href="#原生Ajax" class="headerlink" title="原生Ajax"></a>原生Ajax</h1><p>Ajax 全称 Asynchronous JavaScript and XML(异步的 JavaScript 和 XML)，既是一个对象，也是一种方法模式 </p><p>AJAX 是一种用于创建快速动态网页的技术，通过在后台与服务器进行少量数据交换,Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新，传统的不使用 Ajax 的网页如果需要更新内容,必需重载整个网页</p><span id="more"></span><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="创建-Ajax-对象"><a href="#创建-Ajax-对象" class="headerlink" title="创建 Ajax 对象"></a>创建 Ajax 对象</h3><p>通过 <code>XMLHttpRequest()</code>类创建一个 Ajax 对象(此方法不兼容 IE6 以下浏览器)</p><pre><code class="hljs">    var Ajax=new XMLHttpRequest()</code></pre><p>在 IE6 以下浏览器通过 <code>ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)</code>创建一个 Ajax 对象</p><pre><code class="hljs">    var Ajax=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)</code></pre><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>通过 <code>open()</code> 方法，可以设置跟后台交互的一些行为,该方法有三个参数<br>1、method；2、url；3、boolean</p><p><code>method</code> 请求方式,一个包含具体请求方式的字符串 </p><ul><li>主要请求方式： ​ <ul><li>POST,建议在添加数据时使用 </li><li>GET,建议在查询数据时使用 ​ </li><li>PUT,建议在修改数据时使用 ​ </li><li>DELETE,建议在删除数据时使用</li></ul></li></ul><p><code>url</code>,要请求数据的具体地址</p><p><code>bool</code>,进行同步或异步传输,true 为异步,false 为同步</p><pre><code class="hljs">    Ajax.open(&quot;GET&quot;, &quot;http://localhost:8000&quot;, true)    </code></pre><p>设置需求</p><pre><code class="hljs">    // 如果想用GET的时候直接添加需求,可以在url后面加上?再写具体的需求,多个需求通过&amp;符号连接    var Ajax = new XMLHttpRequest()    Ajax.open(&quot;GET&quot;,&quot;https://www.baidu.com?user=zhangsan&amp;pwd=123456&quot;,true)            // 如果是POST请求,需要设置请求头信息,如:    // 表单格式请求头信息的写法        Ajax.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;); //url格式        // 或        Ajax.setRequestHeader(&quot;Content-Type&quot;,&quot;application/json&quot;)//json格式        //在下一步的send()方法中传入需求    Ajax.send(&quot;user=zhangsan&amp;pwd=123456&quot;)    // 如果想用GET的时候直接添加需求,可以在url后面加上?再写具体的需求,多个需求通过&amp;符号连接    Ajax.open(&quot;GET&quot;,&quot;https://www.baidu.com?user=zhangsan&amp;pwd=123456&quot;,true)            // 如果是POST请求,需要设置请求头信息,如:    // 表单格式请求头信息的写法        Ajax.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;) //url格式        // 或        Ajax.setRequestHeader(&quot;Content-Type&quot;,&quot;application/json&quot;)//json格式        //在下一步的send()方法中传入需求    Ajax.send(&quot;user=zhangsan&amp;pwd=123456&quot;)</code></pre><p><strong>GET 与 POST 区别</strong><br>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。<br>然而，在以下情况中，请使用 POST 请求：</p><ul><li>无法使用缓存文件（更新服务器上的文件或数据库）</li><li>向服务器发送大量数据（POST 没有数据量限制）</li><li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li></ul><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p>通过 <code>send()</code>方法正式发送请求</p><pre><code class="hljs">    Ajax.send()</code></pre><p>注: 如果请求方式是 POST 方式,添加的需求作为参数写入 <code>send()</code>方法中</p><pre><code class="hljs">    Ajax.send(&#39;a=100&amp;b=200&amp;c=300&#39;)</code></pre><h3 id="返回请求结果"><a href="#返回请求结果" class="headerlink" title="返回请求结果"></a>返回请求结果</h3><p>每当 <code>readyState</code> 改变时，就会触发 <code>onreadystatechange</code> 事件，因此可以给元素绑定<code>onreadystatechange</code>事件，来接受响应的事件<br><code>XMLHttpRequest</code> 对象有三个非常重要的属性：<code>onreadystatechange</code>、<code>readyState</code>、<code>status</code></p><p><img src="/images/Ajax/%E5%8E%9F%E7%94%9FAjax2.png" alt="原生Ajax2"></p><p><code>readyState</code>属性：</p><p><img src="/images/Ajax/%E5%8E%9F%E7%94%9FAjax.png" alt="原生Ajax1"></p><p>通过 <code>status</code>(http 的状态码)属性的值判断请求后的结果从而得到请求信息,一般该值为 200 到 300 直接和等于 304 时代表请求成功,值为 404 代表请求失败</p><p><code>response</code> 属性保留着后台返回到前端的数据</p><pre><code class="hljs">    Ajax.onreadystatechange = function () &#123;        if (Ajax.readyState === 4) &#123;            //确定http的状态码            if ((Ajax.status &gt;= 200 &amp;&amp; Ajax.status &lt; 300) || Ajax.status === 304) &#123;                console.log(Ajax.response);            &#125;        &#125;    &#125;</code></pre><h2 id="XmlHttpRequest-对象的主要方法与属性"><a href="#XmlHttpRequest-对象的主要方法与属性" class="headerlink" title="XmlHttpRequest 对象的主要方法与属性"></a>XmlHttpRequest 对象的主要方法与属性</h2><h3 id="XmlHttpRequest-对象的主要方法"><a href="#XmlHttpRequest-对象的主要方法" class="headerlink" title="XmlHttpRequest 对象的主要方法"></a>XmlHttpRequest 对象的主要方法</h3><ul><li><p><code>void open(String method,String url,Boolen async)</code>用于创建请求<br>  参数：</p><ul><li><code>method</code>： 请求方式（字符串类型），如：POST、GET、DELETE…</li><li><code>url</code>： 要请求的地址（字符串类型）</li><li><code>async</code>： 是否异步（布尔类型）</li></ul></li><li><p><code>void send(String body)</code>用于发送请求<br>  参数：</p><ul><li><code>body</code>： 要发送的数据（字符串类型）</li></ul></li><li><p><code>void setRequestHeader(String header,String value)</code> 用于设置请求头<br> 参数：</p><ul><li><code>header</code>： 请求头的 key（字符串类型）</li><li><code>vlaue</code>： 请求头的 value（字符串类型）</li></ul></li><li><p><code>String getAllResponseHeaders()</code> 获取所有响应头<br>  返回值：</p><ul><li>响应头数据（字符串类型）</li></ul></li><li><p><code>String getResponseHeader(String header)</code> 获取响应头中指定 header 的值<br>  参数：</p><ul><li><code>header</code>： 响应头的 key（字符串类型）<br>  返回值：</li><li>响应头中指定的 header 对应的值</li></ul></li><li><p><code>void abort()</code> 终止请求</p></li></ul><h3 id="XmlHttpRequest-对象的主要属性"><a href="#XmlHttpRequest-对象的主要属性" class="headerlink" title="XmlHttpRequest 对象的主要属性"></a>XmlHttpRequest 对象的主要属性</h3><ul><li><p><code>Number readyState</code> 状态值（整数）<br>  详细：</p><ul><li>0-未初始化，尚未调用 open()方法；</li><li>1-启动，调用了 open()方法，未调用 send()方法；</li><li>2-发送，已经调用了 send()方法，未接收到响应；</li><li>3-接收，已经接收到部分响应数据；</li><li>4-完成，已经接收到全部响应数据；</li></ul></li><li><p><code>Function onreadystatechange</code> 当 readyState 的值改变时自动触发执行其对应的函数（回调函数）  </p></li><li><p><code>String responseText</code>服务器返回的数据（字符串类型） </p></li><li><p><code>XmlDocument responseXML</code>服务器返回的数据（Xml 对象） </p></li><li><p><code>Number states</code> 状态码（整数），如：200、404… </p></li><li><p><code>String statesText</code>状态文本（字符串），如：OK、NotFound…</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>定义 XMLHttpRequest 对象</li><li>初始化 设置请求方法和URL （open() 方法）</li><li>发送请求 （send() 方法）</li><li>注册监听的回调函数</li><li>拿到返回值，对页面进行操作</li></ol>]]></content>
    
    
    <categories>
      
      <category>Ajax</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ajax</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node</title>
    <link href="/2021/11/18/node/node/"/>
    <url>/2021/11/18/node/node/</url>
    
    <content type="html"><![CDATA[<h2 id="node简介"><a href="#node简介" class="headerlink" title="node简介"></a>node简介</h2><p>Node是对ES标准一个实现，Node也是一个JS引擎，通过Node可以使js代码在服务器端执行，Node仅仅对ES标准进行了实现，所以在Node中不包含DOM 和 BOM</p><span id="more"></span><h2 id="node的模块化"><a href="#node的模块化" class="headerlink" title="node的模块化"></a>node的模块化</h2><p>在Node中，一个js文件就是一个模块</p><p>每一个js文件中的js代码都是独立运行在一个函数中而不是全局作用域，所以一个模块的中的变量和函数在其他模块中无法访问</p><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>模块就是一个js文件，在模块内部任何变量或其他对象都是私有的，不会暴露给外部模块。</p><p>在CommonJS模块化规范中，在模块内部定义了一个<code>module</code>对象，<code>module</code>对象内部存储了当前模块的基本信息，同时<code>module</code>对象中有一个属性名为<code>exports</code>，<code>exports</code>用来指定需要向外部暴露的内容。只需要将需要暴露的内容设置为<code>exports</code>或<code>exports</code>的属性，其他模块即可通过<code>require</code>来获取这些暴露的内容。</p><h4 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h4><p>使用 <code>require()</code> 方法，可以加载需要的内置模块、用户自定义模块、第三方模块进行使用。</p><p><strong>注意</strong>：使用 <code>require()</code> 方法加载其它模块时，会执行被加载模块中的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 加载内置 fs 模块</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br><span class="hljs-comment">// 加载自定义模块</span><br><span class="hljs-keyword">const</span> m = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./myModule.js&#x27;</span>)<br><br><span class="hljs-comment">// 加载第三方模块</span><br><span class="hljs-keyword">const</span> moment = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;moment&#x27;</span>)<br><br><span class="hljs-comment">// 通过解构赋值按需加载模块</span><br><span class="hljs-keyword">const</span> &#123; a, b &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./myModule.js&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="module-对象"><a href="#module-对象" class="headerlink" title="module 对象"></a>module 对象</h4><p>在每个 .js 自定义模块中都有一个 module 对象，它里面存储了和当前模块有关的信息，打印如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">module</span>)<br><br><span class="hljs-comment">// output</span><br><span class="hljs-title class_">Module</span> &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;.&#x27;</span>,<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;D:\\study\\nodejs\\moudle&#x27;</span>,<br>  <span class="hljs-attr">exports</span>: &#123;&#125;,<br>  <span class="hljs-attr">parent</span>: <span class="hljs-literal">null</span>,<br>  <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;D:\\study\\nodejs\\moudle\\myMoudle.js&#x27;</span>,<br>  <span class="hljs-attr">loaded</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">children</span>: [],<br>  <span class="hljs-attr">paths</span>: [<br>    <span class="hljs-string">&#x27;D:\\study\\nodejs\\moudle\\node_modules&#x27;</span>,<br>    <span class="hljs-string">&#x27;D:\\study\\nodejs\\node_modules&#x27;</span>,<br>    <span class="hljs-string">&#x27;D:\\study\\node_modules&#x27;</span>,<br>    <span class="hljs-string">&#x27;D:\\node_modules&#x27;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="module-exports对象"><a href="#module-exports对象" class="headerlink" title="module.exports对象"></a>module.exports对象</h4><p>在自定义模块中，可以使用 <code>module.exports</code> 对象，将模块内的成员共享出去，供外界使用。</p><p>外界用 <code>require()</code> 方法 导入自定义模块时，得到的就是 <code>module.exports</code> 所指向的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = <span class="hljs-number">10</span><br><span class="hljs-keyword">const</span> b = <span class="hljs-number">20</span><br><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;孙悟空&quot;</span> &#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">a</span> = a<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">b</span> = b<br><br><span class="hljs-comment">// const &#123;a, b&#125; = require(&quot;./m.js&quot;)</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = <span class="hljs-number">10</span><br><span class="hljs-keyword">const</span> b = <span class="hljs-number">20</span><br><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;孙悟空&quot;</span> &#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123; a, b, obj&#125;<br><br><span class="hljs-comment">// const &#123;a, b, obj&#125; = require(&quot;./m.js&quot;)</span><br></code></pre></td></tr></table></figure><p>默认情况下，Node.js会将以下内容视为CommonJS模块：</p><ol><li>使用<code>.cjs</code>为扩展名的文件</li><li>当前的<code>package.json</code>的<code>type</code>属性为<code>commonjs</code>时，扩展名为<code>.js</code>的文件</li><li>当前的<code>package.json</code>不包含<code>type</code>属性时，扩展名为<code>.js</code>的文件</li><li>文件的扩展名是<code>mjs、cjs、json、node、js</code>以外的值时（<code>type</code>不是<code>module</code>时）</li></ol><h4 id="exports-对象"><a href="#exports-对象" class="headerlink" title="exports 对象"></a>exports 对象</h4><p>由于 <code>module.exports</code> 单词写起来比较复杂，为了简化向外共享成员的代码，Node 提供了 <code>exports</code> 对象。</p><p> 默认情况 下 ， <code>exports</code> 和 <code>module.exports</code> 指向同一个对象 。最终共享的结果，还是以 <code>module.exports</code> 指向的对象为准</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> === <span class="hljs-built_in">exports</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">const <span class="hljs-selector-tag">a</span> = <span class="hljs-number">10</span><br>const <span class="hljs-selector-tag">b</span> = <span class="hljs-number">20</span><br>const obj = &#123; name: <span class="hljs-string">&quot;孙悟空&quot;</span> &#125;<br><br>exports<span class="hljs-selector-class">.a</span> = <span class="hljs-selector-tag">a</span><br>exports<span class="hljs-selector-class">.b</span> = <span class="hljs-selector-tag">b</span><br><br><span class="hljs-comment">// const &#123;a, b&#125; = require(&quot;./m.js&quot;)</span><br></code></pre></td></tr></table></figure><h4 id="exports-和-module-exports-的使用误区"><a href="#exports-和-module-exports-的使用误区" class="headerlink" title="exports 和 module.exports 的使用误区"></a>exports 和 module.exports 的使用误区</h4><p>时刻谨记，<code>require()</code> 模块时，得到的永远是 <code>module.exports</code> 指向的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">exports</span>.<span class="hljs-property">obj</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;孙悟空&#x27;</span> &#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-number">20</span>,<br>&#125;<br><br><span class="hljs-comment">// const m = require(&quot;./m.js&quot;)</span><br><span class="hljs-comment">// console.log(m) // &#123; a: 10, b: 20 &#125;</span><br></code></pre></td></tr></table></figure><p> <strong>注意：</strong>为了防止混乱，建议不要在同一个模块中同时使用 <code>exports</code> 和 <code>module.exports</code></p><h4 id="文件作为模块"><a href="#文件作为模块" class="headerlink" title="文件作为模块"></a>文件作为模块</h4><p>当我们加载一个自定义的文件模块时，模块的路径必须以<code>/、./</code>或<code>../</code>开头。如果不以这些开头，node会认为你要加载的是核心模块或<code>node_modules</code>中的模块。</p><p>当我们要加载的模块是一个文件模块时，CommonJS规范会先去寻找该文件，比如：<code>require(&quot;./m1&quot;)</code>时，会首先寻找名为m1的文件。如果这个文件没有找到，它会自动为文件添加扩展名然后再查询。扩展名的顺序为：<code>js、json、node</code>。</p><p>还是上边的例子，如果没有找到m1，则会按照顺序搜索<code>m1.js、m1.json、m1.node</code>哪个先找到则返回哪个，如果都没有找到则报错。</p><h4 id="文件夹作为模块"><a href="#文件夹作为模块" class="headerlink" title="文件夹作为模块"></a>文件夹作为模块</h4><p>当我们使用一个文件夹作为模块时，文件夹中必须有一个模块的主文件。如果文件夹中含有<code>package.json</code>文件且文件中设置<code>main</code>属性，则<code>main</code>属性指定的文件会成为主文件，导入模块时就是导入该文件。如果没有<code>package.json</code>，则node会按照<code>index.js</code>、<code>index.node</code>的顺序寻找主文件。</p><h4 id="Node-modules"><a href="#Node-modules" class="headerlink" title="Node_modules"></a>Node_modules</h4><p>如果我们加载的模块没有以<code>/、./</code>或<code>../</code>开头，且要加载的模块不是核心模块，node会自动去node_modules目录下去加载模块。</p><p>node会先去当前目录下的node_modules下去寻找模块，找到则使用，没找到则继续去上一层目录中寻找，以此类推，知道找到根目录下的node_modules为止。</p><p>比如，当前项目的目录为：<code>&#39;C:\Users\lilichao\Desktop\Node-Course\myProject\node_modules&#39;</code>，则模块查找顺序依次为：</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">‘<span class="hljs-name">C</span>:\Users\lilichao\Desktop\Node-Course\node_modules’,<br>‘<span class="hljs-name">C</span>:\Users\lilichao\Desktop\node_modules’,<br>‘<span class="hljs-name">C</span>:\Users\lilichao\node_modules’,<br>‘<span class="hljs-name">C</span>:\Users\node_modules’,<br>‘<span class="hljs-name">C</span>:\node_modules’<br></code></pre></td></tr></table></figure><h4 id="模块的包装"><a href="#模块的包装" class="headerlink" title="模块的包装"></a>模块的包装</h4><p>每一个CommonJS模块在执行时，外层都会被套上一个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span>, <span class="hljs-variable language_">module</span>, __filename, __dirname</span>) &#123;<br><span class="hljs-comment">// 模块代码会被放到这里</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>所以我们之所以能在CommonJS模块中使用<code>exports</code>、<code>require</code>并不是因为它们是全局变量。它们实际上以参数的形式传递进模块的。</p><p><code>exports</code>，用来设置模块向外部暴露的内容</p><p><code>require</code>，用来引入模块的方法</p><p><code>module</code>，当前模块的引用</p><p><code>__filename</code>，模块的路径</p><p><code>__dirname</code>，模块所在目录的路径</p><h3 id="ES模块化"><a href="#ES模块化" class="headerlink" title="ES模块化"></a>ES模块化</h3><p>2015年随着ES6标准的发布，ES的内置模块化系统也应运而生，并且在Node.js中同样也支持ES标准的模块化。</p><p>需要注意的是，Node.js默认并不支持ES模块化，如果需要使用可以采用两种方式。</p><p>方式一，直接将所有的<code>js</code>文件修改为<code>mjs</code>扩展名。</p><p>方式二，修改<code>package.json</code>中type属性为<code>module</code>。</p><h4 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 导出变量（命名导出）</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> name1, name2, …, nameN; <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> name1 = …, name2 = …, …, nameN; <br><br><span class="hljs-comment">// 导出函数（命名导出）</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">functionName</span>(<span class="hljs-params"></span>)&#123;...&#125;<br><br><span class="hljs-comment">// 导出类（命名导出）</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span> &#123;...&#125;<br><br><span class="hljs-comment">// 导出一组</span><br><span class="hljs-keyword">export</span> &#123; name1, name2, …, nameN &#125;<br><br><span class="hljs-comment">// 重命名导出</span><br><span class="hljs-keyword">export</span> &#123; variable1 <span class="hljs-keyword">as</span> name1, variable2 <span class="hljs-keyword">as</span> name2, …, nameN &#125;<br><br><span class="hljs-comment">// 解构赋值后导出</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> &#123; name1, <span class="hljs-attr">name2</span>: bar &#125; = o<br><br><span class="hljs-comment">// 默认导出</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> expression<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">…</span>) &#123; … &#125; <span class="hljs-comment">// also class, function*</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">name1</span>(<span class="hljs-params">…</span>) &#123; … &#125; <span class="hljs-comment">// also class, function*</span><br><span class="hljs-keyword">export</span> &#123; name1 <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span>, … &#125;;<br><br><span class="hljs-comment">// 聚合模块</span><br><span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> …; <span class="hljs-comment">// 将其他模块中的全部内容导出（除了default）</span><br><span class="hljs-keyword">export</span> * <span class="hljs-keyword">as</span> name1 <span class="hljs-keyword">from</span> …; <span class="hljs-comment">// ECMAScript® 2O20 将其他模块中的全部内容以指定别名导出</span><br><span class="hljs-keyword">export</span> &#123; name1, name2, …, nameN &#125; <span class="hljs-keyword">from</span> …; <span class="hljs-comment">// 将其他模块中的指定内容导出</span><br><span class="hljs-keyword">export</span> &#123; import1 <span class="hljs-keyword">as</span> name1, import2 <span class="hljs-keyword">as</span> name2, …, nameN &#125; <span class="hljs-keyword">from</span> …; <span class="hljs-comment">// 将其他模块中的指定内容重命名导出</span><br><span class="hljs-keyword">export</span> &#123; <span class="hljs-keyword">default</span>, … &#125; <span class="hljs-keyword">from</span> …; <br></code></pre></td></tr></table></figure><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-comment">// 引入默认导出</span><br><span class="hljs-keyword">import</span> defaultExport <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span><br><br><span class="hljs-comment">// 将所有模块导入到指定命名空间中</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> name <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span><br><br><span class="hljs-comment">// 引入模块中的指定内容</span><br><span class="hljs-keyword">import</span> &#123; export1 &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span><br><span class="hljs-keyword">import</span> &#123; export1 , export2 &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span><br><br><span class="hljs-comment">// 以指定别名引入模块中的指定内容</span><br><span class="hljs-keyword">import</span> &#123; export1 <span class="hljs-keyword">as</span> alias1 &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span><br><span class="hljs-keyword">import</span> &#123; export1 , export2 <span class="hljs-keyword">as</span> alias2 , [...] &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span><br><br><span class="hljs-comment">// 引入默认和其他内容</span><br><span class="hljs-keyword">import</span> defaultExport, &#123; export1 [ , [...] ] &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span><br><span class="hljs-keyword">import</span> defaultExport, * <span class="hljs-keyword">as</span> name <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;module-name&quot;</span><br><br><span class="hljs-comment">// 引入模块</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;module-name&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>less</title>
    <link href="/2021/11/15/less/less/"/>
    <url>/2021/11/15/less/less/</url>
    
    <content type="html"><![CDATA[<h1 id="less"><a href="#less" class="headerlink" title="less"></a>less</h1><p><strong>less 是一种动态样式语言,属于 CSS 预处理器的范畴,它拓展了 CSS 语言</strong>,其余的 CSS 预处理器有 sass 和 stylus 等 less 增加了变量,MIxin,函数等特性,使 CSS 更易维护和扩展,less 既可以在客户端上运行,也可以借助 node.js 在服务端 运行</p><span id="more"></span><h2 id="less-的注释"><a href="#less-的注释" class="headerlink" title="less 的注释"></a>less 的注释</h2><p>less 中的注释和 CSS 一样有两种单行注释 <code>//</code>，多行注释 <code>/**/</code></p><p>区别：以 <code>//</code> 开头的注释不会被编译到 CSS 文件中，而通过 <code>/**/</code> 包裹的注释才会被编译在 CSS 文件中</p><h2 id="less-的变量"><a href="#less-的变量" class="headerlink" title="less 的变量"></a>less 的变量</h2><ul><li>less 中使用<code>@</code>来申明和使用一个变量，所有变量声明方法相同</li></ul><p>具体用法为: <code>@变量名:属性值</code></p><pre><code class="hljs">    @pink:pink //在以后的使用中就可以用@pink 来代替 pink</code></pre><p>变量作为<strong>普通属性值</strong>使用，直接用这个变量:<code>@变量名</code><br>变量作为<strong>选择器或者属性名</strong>来使用，需要在变量两边加上{}，<code>&#123;selector&#125;</code><br>变量作为<code> url</code>，使用是也需要在两边加上{}: <code>&#123;url&#125;</code></p><p>变量的加载会有延迟效果,当整个文件的所有东西被加载完时才会将变量赋值给对应的属性 </p><p>变量运用的时候会现在自身的作用域里面找到是否定义了该变量,如果定义了就直接用自身作用域中的,如果没有才会在外层逐层寻找,如果在最外层都没有找到对应的变量就会报错</p><pre><code class="hljs">    @var: 0;        .class &#123;        @var: 1;        .brass &#123;            @var: 2;            width: @var;            @var: 3;        &#125;        height: @var;    &#125;        /*          最终的结果为height:1;width:3;          变量在最后赋完所有值才会赋值给属性,            而且这个赋值也是只针对自身的作用域      */</code></pre><h2 id="less-的导入"><a href="#less-的导入" class="headerlink" title="less 的导入"></a>less 的导入</h2><p>在 less 中使用@import 关键字能够将需要的文件中的代码导入到当前的 less 文件中</p><ul><li><p>导入 less 文件可一直接导入</p><pre><code class="hljs">  @import &quot;a.less&quot;;</code></pre></li><li><p>导入 CSS 文件时需要申明这是 CSS 文件</p><pre><code class="hljs">  @import (CSS) &quot;b.css&quot;;</code></pre></li></ul><h2 id="嵌套规则"><a href="#嵌套规则" class="headerlink" title="嵌套规则"></a>嵌套规则</h2><h3 id="基本嵌套规则"><a href="#基本嵌套规则" class="headerlink" title="基本嵌套规则"></a>基本嵌套规则</h3><ul><li><p>less 中可以在父选择器中包含有子选择器,在转换为 CSS 文件的时候会自动用空格来隔开</p><pre><code class="hljs">  .father &#123;            .child &#123;        &#125;  &#125;    /*       通过上方的写法可以分别对父元素和子元素进行样式设置     */</code></pre></li></ul><h3 id="符号的使用"><a href="#符号的使用" class="headerlink" title="&amp;符号的使用"></a>&amp;符号的使用</h3><p><strong>&amp;符号能取消默认的嵌套关系的中的空格</strong>，从而从父子关系变成兄弟关系，这个兄弟关系是本身拓展出的一些兄弟关系,如伪类选择器等，可以理解为 &amp; 符号就是这个选择器本身</p><pre><code class="hljs">    .father &#123;            .child &#123;            background-color: red;                &amp;:hover &#123;                background-color: pink;            &#125;        &#125;    &#125;    //相当于    .father .child &#123;      background-color: red;    &#125;    .father .child:hover &#123;      background-color: pink;    &#125;</code></pre><h2 id="less-的运算"><a href="#less-的运算" class="headerlink" title="less 的运算"></a>less 的运算</h2><p>在 less 中可以进行加减乘除的运算</p><p>注意:在 less 的计算中计算的双方只需要一方带单位,最后再计算的时候单位会保留下来加在新值的后面</p><pre><code class="hljs">    .box &#123;      widht: (100+100px);    &#125;</code></pre><h2 id="less-的混合"><a href="#less-的混合" class="headerlink" title="less 的混合"></a>less 的混合</h2><p><strong>混合就是将一系列属性从一个规则集引入到另外一个规则集的方式</strong>，相当于直接复制</p><h3 id="普通混合"><a href="#普通混合" class="headerlink" title="普通混合"></a>普通混合</h3><p>把样式中共同的代码单独提出来在最上方,单独的用一个类名来定义,然后在下面输入的时候通过 <code>.类名/;</code> 来调用</p><pre><code class="hljs">    .mix &#123;        //不加()是普通混合,会被编译到CSS文件中        width: 100px;        height: 100px;        background-color: red;    &#125;        .father &#123;        width: 200px;        height: 200px;            .child1 &#123;            .mix; //调用混合样式        &#125;            .child2 &#123;            .mix;        &#125;    &#125;</code></pre><h3 id="不带输出混合"><a href="#不带输出混合" class="headerlink" title="不带输出混合"></a>不带输出混合</h3><p>不带输出混合与普通混合最大的区别就是：不带输出混合不会编译到 css 文件中，而普通混合则会</p><pre><code class="hljs">    .mix() &#123;        //不加()是普通混合,会被编译到CSS文件中        width: 100px;        height: 100px;        background-color: red;    &#125;        .father &#123;        width: 200px;        height: 200px;            .child1 &#123;            .mix(); //调用混合样式        &#125;            .child2 &#123;            .mix();        &#125;    &#125;</code></pre><h3 id="带参数的混合"><a href="#带参数的混合" class="headerlink" title="带参数的混合"></a>带参数的混合</h3><p>混合的参数也是通过变量使用的形式来定义的，混合中加参数的用法和函数类似，为了方便记忆可以理解为函数，但是不是函数，同时这个参数还可以有默认的值，默认值的定义也是和变量的定义相同</p><pre><code class="hljs">    .mix(@w: 10px, @h: 10px, @c: pink) &#123;        width: @w;        height: @h;        background-color: @c;    &#125;        .father &#123;        width: 200px;        height: 200px;            .child1 &#123;            .mix(100px, 100px, red);        &#125;            .child2 &#123;            .mix(50px, 50px, black);        &#125;    &#125;</code></pre><p>如果想对上述单个属性赋值，而其他属性使用默认值的话，可使用命名参数混合</p><h3 id="命名参数混合"><a href="#命名参数混合" class="headerlink" title="命名参数混合"></a>命名参数混合</h3><p>在实参传递给形参值的时候可以不用按照顺序进行传递，而是直接通过参数的指定进行传参，这样就能够实现当只想传递某些参数而不是所有参数的时候参数的值不产生混乱</p><p>实参传入命名参数的时候和变量定义的时候是一样的</p><pre><code class="hljs">    .mix(@w: 10px, @h: 10px, @c: pink) &#123;        width: @w;        height: @h;        background-color: @c;    &#125;        .father &#123;        width: 200px;        height: 200px;            .child1 &#123;            .mix(100px, 100px, red);        &#125;            .child2 &#123;            .mix(@c:black);        &#125;    &#125;</code></pre><h3 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h3><p>用一些专门的标识符放在形参的首位用做匹配，注意<strong>这个是标识符不用@符号</strong>，当使用的时候会根据传入的第一个参数，匹配到那个，就使用哪一个样式</p><pre><code class="hljs">    .float(l, @w) &#123;        float: left;        width: @w;    &#125;        .float(r, @w) &#123;        float: right;        width: @w;    &#125;        .box1 &#123;        height: 200px;        background: green;        .float(l, 200px);    &#125;        .box2 &#123;        width: 300px;        height: 200px;        background: green;        .float(r, 200px);    &#125;</code></pre><h3 id="arguments-变量"><a href="#arguments-变量" class="headerlink" title="arguments 变量"></a>arguments 变量</h3><p><strong>arguments 相当于是类中所有实参的集合</strong>，其作用和 js 中的 arguments 类似<br>这个变量是 less 已经设置了的,可以直接调用它来使用,调用它的时候它包含了所有传入的实参,同时每个实参是通过空格隔开的</p><pre><code class="hljs">    .border(@size,@style,@color) &#123;      border: @arguments;    &#125;    div &#123;      width: 200px;      height: 200px;      .border(1px, solid, #000);    &#125;</code></pre><p>注意:和 js 中不一样的是这个属性虽然保留着所有实参但是在命名类的时候还是需要写入对应的形参，不然会出现报错</p><h2 id="less-的继承"><a href="#less-的继承" class="headerlink" title="less 的继承"></a>less 的继承</h2><p>less 的继承性能上高于 less 的混合,但是灵活性弱于混合,继承不支持参数的形式,同时后面也不加(),继承的类是需要被编译到 CSS 文件中的</p><p>less 的继承用关键词 <code>&amp;:extend()</code> 函数来实现，下面是一种用法</p><pre><code class="hljs">    .jicheng&#123;        width: 100px;        height: 100px;        background: red;    &#125;    .box:extend(.jicheng)&#123;        border: solid 1px black;    &#125;    // 相当于    .jicheng,    .box &#123;      width: 100px;      height: 100px;      background: red;    &#125;    .box &#123;      border: solid 1px black;    &#125;</code></pre><p>同时也可以继承所有状态（如伪类选择器），<code>name:extend（继承类名 all）&#123;&#125;</code></p><pre><code class="hljs">    .jicheng&#123;        width: 100px;        height: 100px;        background: red;    &#125;    .jicheng:hover&#123;        background: black;    &#125;    .box:extend(.jicheng)&#123;        border: solid 1px black;    &#125;    .box2:extend(.jicheng all)&#123;        border: solid 1px black;    &#125;    //相当于    .jicheng,    .box,    .box2 &#123;      width: 100px;      height: 100px;      background: red;    &#125;    .jicheng:hover,    .box2:hover &#123;      background: black;    &#125;    .box &#123;      border: solid 1px black;    &#125;    .box2 &#123;      border: solid 1px black;    &#125;</code></pre><h2 id="less-的避免编译"><a href="#less-的避免编译" class="headerlink" title="less 的避免编译"></a>less 的避免编译</h2><p>在 less 中如果想要一些值不被运算想要原封不动的变成 CSS 文件,可以用 <code>~&quot;值&quot;</code>的方式直接将值原封传递给 CSS 文件</p><pre><code class="hljs">    * &#123;      margin: ~&quot;calc(100px + 100)&quot;; //calc()是CSS中本来就有的计算形式的函数    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>less</category>
      
    </categories>
    
    
    <tags>
      
      <tag>less</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Symbol</title>
    <link href="/2021/11/11/ES6/Symbol/"/>
    <url>/2021/11/11/ES6/Symbol/</url>
    
    <content type="html"><![CDATA[<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。如在对象中添加一个方法，这个方法名有可能导致重名，引起冲突</p><p>ES6 引入了一种新的原始数据类型 <code>Symbol</code>，表示独一无二的值。它是 JavaScript 语言的第七种数据类型</p><p>对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 <code>Symbol</code> 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突</p><span id="more"></span><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>声明方式:</p><pre><code class="hljs">    let s = Symbol()    console.log(s, typeof s) // Symbol() &#39;symbol&#39;</code></pre><p><code>Symbol</code> 函数前不能使用 <code>new</code> 命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 <code>Symbol</code> 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型</p><p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 <code>Symbol</code> 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分</p><pre><code class="hljs">    let s1 = Symbol(&quot;s1&quot;);    let s2 = Symbol(&quot;s2&quot;);    console.log(s1) // Symbol(s1)    console.log(s2) // Symbol(s2)    console.log(s1.toString()) // &quot;Symbol(s1)&quot;    console.log(s2.toString()) // &quot;Symbol(s2)&quot;</code></pre><p>如果 <code>Symbol</code> 的参数是一个对象，就会调用该对象的<code>toString()</code>方法，将其转为字符串，然后才生成一个 <code>Symbol</code> 值</p><pre><code class="hljs">    const obj = &#123;        name: &quot;obj&quot;,        toString: function() &#123;            return this.name        &#125;    &#125;    let s = Symbol(obj)    console.log(s) //Symbol(obj)</code></pre><p>注，<code>Symbol</code>函数的参数只是表示对当前 <code>Symbol</code> 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的</p><pre><code class="hljs">    // 没有参数的情况    let s1 = Symbol()    let s2 = Symbol()        s1 === s2 // false        // 有参数的情况    let s1 = Symbol(&quot;s&quot;)    let s2 = Symbol(&quot;s&quot;)        s1 === s2 // false</code></pre><p><code>Symbol</code> 值不能与其他类型的值进行运算和比较，会报错</p><pre><code class="hljs">    let s = Symbol(&quot;s&quot;)    let result = s + 100    // TypeError: Cannot convert a Symbol value to a number</code></pre><h2 id="Symbol-for"><a href="#Symbol-for" class="headerlink" title="Symbol.for()"></a>Symbol.for()</h2><p>有时，我们希望重新使用同一个 Symbol 值，<code>Symbol.for()</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 <code>Symbol</code> 值。如果有，就返回这个 <code>Symbol</code> 值，否则就新建并返回一个以该字符串为名称的 <code>Symbol</code> 值</p><pre><code class="hljs">    Symbol.for(&quot;foo&quot;) // 创建一个 symbol 并放入 symbol 注册表中，键为 &quot;foo&quot;    Symbol.for(&quot;foo&quot;) // 从 symbol 注册表中读取键为&quot;foo&quot;的 symbol    Symbol.for(&quot;foo&quot;) === Symbol.for(&quot;foo&quot;) // true    Symbol(&quot;bar&quot;) === Symbol(&quot;bar&quot;) // false，Symbol() 函数每次都会返回新的一个 symbol        var sym = Symbol.for(&quot;mario&quot;)    sym.toString()    // &quot;Symbol(mario)&quot;，mario 既是该 symbol 在 symbol 注册表中的键名，又是该 symbol 自身的描述字符串</code></pre><p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的 <code>Symbol</code>。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。<code>Symbol.for()</code>不会每次调用就返回一个新的 <code>Symbol</code> 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值</p><h2 id="Symbol-keyFor"><a href="#Symbol-keyFor" class="headerlink" title="Symbol.keyFor()"></a>Symbol.keyFor()</h2><p><code>Symbol.keyFor()</code>方法返回一个已登记的 <code>Symbol</code> 类型值的 key</p><pre><code class="hljs">    let s1 = Symbol.for(&quot;foo&quot;)    Symbol.keyFor(s1) // &quot;foo&quot;        let s2 = Symbol(&quot;foo&quot;)    Symbol.keyFor(s2) // undefined</code></pre><p>变量<code>s2</code>属于未登记的 <code>Symbol</code> 值，所以返回<code>undefined</code></p><p>需要注意的是，<code>Symbol.for()</code>为 Symbol 值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker 中取到同一个值</p><pre><code class="hljs">    iframe = document.createElement(&quot;iframe&quot;)    iframe.src = String(window.location)    document.body.appendChild(iframe)        iframe.contentWindow.Symbol.for(&quot;foo&quot;) === Symbol.for(&quot;foo&quot;)// true</code></pre><h2 id="内置的-Symbol-值"><a href="#内置的-Symbol-值" class="headerlink" title="内置的 Symbol 值"></a>内置的 Symbol 值</h2><p>除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法</p><h3 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a>Symbol.hasInstance</h3><p>对象的<code>Symbol.hasInstance</code>属性，指向一个内部方法。当其他对象使用<code>instanceof</code>运算符，判断是否为该对象的实例时，会调用这个方法。比如，<code>foo instanceof Foo</code>在语言内部，实际调用的是<code>Foo[Symbol.hasInstance](foo)</code></p><pre><code class="hljs">    class MyClass &#123;        [Symbol.hasInstance](foo) &#123;            return foo instanceof Array;        &#125;    &#125;    [1, 2, 3] instanceof new MyClass(); // true</code></pre><p>上面代码中，<code>MyClass</code>是一个类，<code>new MyClass()</code>会返回一个实例。该实例的<code>Symbol.hasInstance()</code>方法，会在进行<code>instanceof</code>运算时自动调用，判断左侧的运算子是否为<code>Array</code>的实例</p><h3 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h3><p>对象的<code>Symbol.isConcatSpreadable</code>属性等于一个布尔值，表示该对象用于<code>Array.prototype.concat()</code>时，是否可以展开</p><pre><code class="hljs">    let arr1 = [&quot;c&quot;, &quot;d&quot;];    [&quot;a&quot;, &quot;b&quot;].concat(arr1, &quot;e&quot;); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]    arr1[Symbol.isConcatSpreadable]; // undefined    let arr2 = [&quot;c&quot;, &quot;d&quot;];    arr2[Symbol.isConcatSpreadable] = false;    [&quot;a&quot;, &quot;b&quot;].concat(arr2, &quot;e&quot;); // [&#39;a&#39;, &#39;b&#39;, [&#39;c&#39;,&#39;d&#39;], &#39;e&#39;]</code></pre><p>上面代码说明，数组的默认行为是可以展开，<code>Symbol.isConcatSpreadable</code>默认等于<code>undefined</code>。该属性等于<code>true</code>时，也有展开的效果</p><p>类似数组的对象正好相反，默认不展开。它的<code>Symbol.isConcatSpreadable</code>属性设为<code>true</code>，才可以展开</p><pre><code class="hljs">    let obj = &#123;        length: 2,        0: &quot;c&quot;,        1: &quot;d&quot;    &#125;;    [&quot;a&quot;, &quot;b&quot;].concat(obj, &quot;e&quot;); // [&#39;a&#39;, &#39;b&#39;, obj, &#39;e&#39;]    obj[Symbol.isConcatSpreadable] = true;    [&quot;a&quot;, &quot;b&quot;].concat(obj, &quot;e&quot;); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</code></pre><h3 id="Symbol-species"><a href="#Symbol-species" class="headerlink" title="Symbol.species"></a>Symbol.species</h3><p>对象的<code>Symbol.species</code>属性，指向一个构造函数。创建衍生对象时，会使用该属性</p><pre><code class="hljs">    class MyArray extends Array &#123;&#125;    const a = new MyArray(1, 2, 3);    const b = a.map((x) =&gt; x);    const c = a.filter((x) =&gt; x &gt; 1);    b instanceof MyArray; // true    c instanceof MyArray; // true</code></pre><p>上面代码中，子类<code>MyArray</code>继承了父类<code>Array</code>，a是<code>MyArray</code>的实例，b和c是a的衍生对象。您可能会认为，b和c都是调用数组方法生成的，所以应该是数组(<code>Array</code>的实例)，但实际上它们也是<code>MyArray</code>的实例</p><h3 id="Symbol-match"><a href="#Symbol-match" class="headerlink" title="Symbol.match"></a>Symbol.match</h3><p>对象的<code>Symbol.match</code>属性，指向一个函数。当执行<code>str.match(myObject)</code>时，如果该属性存在，会调用它，返回该方法的返回值</p><pre><code class="hljs">    String.prototype.match(regexp);    // 等同于    regexp[Symbol.match](this);    class MyMatcher &#123;        [Symbol.match](string) &#123;            return &quot;hello world&quot;.indexOf(string);        &#125;    &#125;    &quot;e&quot;.match(new MyMatcher()); // 1</code></pre><h3 id="Symbol-replace"><a href="#Symbol-replace" class="headerlink" title="Symbol.replace"></a>Symbol.replace</h3><p>对象的<code>Symbol.replace</code>属性，指向一个方法，当该对象被<code>String.prototype.replace</code>方法调用时，会返回该方法的返回值</p><pre><code class="hljs">    String.prototype.replace(searchValue, replaceValue);    // 等同于    searchValue[Symbol.replace](this, replaceValue);</code></pre><p>例：</p><pre><code class="hljs">    const x = &#123;&#125;;    x[Symbol.replace] = (...s) =&gt; console.log(s);    &quot;Hello&quot;.replace(x, &quot;World&quot;); // [&quot;Hello&quot;, &quot;World&quot;]</code></pre><p><code>Symbol.replace</code>方法会收到两个参数，第一个参数是<code>replace</code>方法正在作用的对象，上面例子是<code>Hello</code>，第二个参数是替换后的值，上面例子是<code>World</code></p><h3 id="Symbol-search"><a href="#Symbol-search" class="headerlink" title="Symbol.search"></a>Symbol.search</h3><p>对象的<code>Symbol.search</code>属性，指向一个方法，当该对象被<code>String.prototype.search</code>方法调用时，会返回该方法的返回值</p><pre><code class="hljs">    String.prototype.search(regexp);    // 等同于    regexp[Symbol.search](this);    class MySearch &#123;        constructor(value) &#123;                this.value = value;            &#125;            [Symbol.search](string) &#123;                return string.indexOf(this.value);            &#125;    &#125;    &quot;foobar&quot;.search(new MySearch(&quot;foo&quot;)); // 0</code></pre><h3 id="Symbol-split"><a href="#Symbol-split" class="headerlink" title="Symbol.split"></a>Symbol.split</h3><p>对象的<code>Symbol.split</code>属性，指向一个方法，当该对象被<code>String.prototype.split</code>方法调用时，会返回该方法的返回值</p><pre><code class="hljs">    String.prototype.split(separator, limit);        separator[Symbol.split](this, limit);</code></pre><p>例：</p><pre><code class="hljs">    class MySplitter &#123;        constructor(value) &#123;                this.value = value;            &#125;            [Symbol.split](string) &#123;                let index = string.indexOf(this.value);                if (index === -1) &#123;                    return string;                &#125;                return [string.substr(0, index), string.substr(index + this.value.length)];            &#125;    &#125;    &quot;foobar&quot;.split(new MySplitter(&quot;foo&quot;));    // [&#39;&#39;, &#39;bar&#39;]    &quot;foobar&quot;.split(new MySplitter(&quot;bar&quot;));    // [&#39;foo&#39;, &#39;&#39;]    &quot;foobar&quot;.split(new MySplitter(&quot;baz&quot;));    // &#39;foobar&#39;</code></pre><p>上面方法使用<code>Symbol.split</code>方法，重新定义了字符串对象的split方法的行为</p><h3 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h3><p>对象的<code>Symbol.iterator</code>属性，指向该对象的默认遍历器方法</p><pre><code class="hljs">    const myIterable = &#123;&#125;;    myIterable[Symbol.iterator] = function * () &#123;        yield 1;        yield 2;        yield 3;    &#125;;    [...myIterable]; // [1, 2, 3]</code></pre><p>对象进行<code>for...of</code>循环时，会调用<code>Symbol.iterator</code>方法，返回该对象的默认遍历器</p><pre><code class="hljs">    class Collection &#123;        *[Symbol.iterator]() &#123;            let i = 0;            while (this[i] !== undefined) &#123;                yield this[i];                ++i;            &#125;        &#125;    &#125;    let myCollection = new Collection();    myCollection[0] = 1;    myCollection[1] = 2;    for (let value of myCollection) &#123;        console.log(value);    &#125;    // 1    // 2</code></pre><h3 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h3><p>对象的<code>Symbol.toPrimitive</code>属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。<br> <code>Symbol.toPrimitive</code>被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。 </p><ul><li><p>Number: 该场合需要转成数值 </p></li><li><p>String: 该场合需要转成字符串 </p></li><li><p>Default: 该场合可以转成数值，也可以转成字符串</p><pre><code class="hljs">  let obj = &#123;      [Symbol.toPrimitive](hint) &#123;          switch (hint) &#123;              case &quot;number&quot;:                  return 123;              case &quot;string&quot;:                  return &quot;str&quot;;              case &quot;default&quot;:                  return &quot;default&quot;;              default:                  throw new Error();          &#125;      &#125;,  &#125;;  2 * obj; // 246  3 + obj; // &#39;3default&#39;  obj == &quot;default&quot;; // true  String(obj); // &#39;str&#39;</code></pre></li></ul><h3 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a>Symbol.toStringTag</h3><p>对象的<code>Symbol.toStringTag</code>属性，指向一个方法。在该对象上面调用<code>Object.prototype.toString</code>方法时，如果这个属性存在，它的返回值会出现在<code>toString()</code>方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制<code>[object Object]</code>或<code>[object Array]</code>中<code>object</code>后面的那个字符串</p><pre><code class="hljs">    // 例一    (&#123;        [Symbol.toStringTag]: &quot;Foo&quot;    &#125;.toString());    // &quot;[object Foo]&quot;    // 例二    class Collection &#123;        get[Symbol.toStringTag]() &#123;            return &quot;xxx&quot;;        &#125;    &#125;    let x = new Collection();    Object.prototype.toString.call(x); // &quot;[object xxx]&quot;</code></pre><p>ES6 新增内置对象的<code>Symbol.toStringTag</code>属性值如下。 </p><ul><li><code>JSON[Symbol.toStringTag]</code>: ‘JSON’ </li><li><code>Math[Symbol.toStringTag]</code>: ‘Math’ </li><li>Module 对象 <code>M[Symbol.toStringTag]</code>: ‘Module’ </li><li><code>ArrayBuffer.prototype[Symbol.toStringTag]</code>: ‘ArrayBuffer’ </li><li><code>DataView.prototype[Symbol.toStringTag]</code>: ‘DataView’ </li><li><code>Map.prototype[Symbol.toStringTag]</code>: ‘Map’ </li><li><code>Promise.prototype[Symbol.toStringTag]</code>: ‘Promise’ </li><li><code>Set.prototype[Symbol.toStringTag]</code>: ‘Set’ </li><li><code>%TypedArray%.prototype[Symbol.toStringTag]</code>: ‘Uint8Array’等 </li><li><code>WeakMap.prototype[Symbol.toStringTag]</code>: ‘WeakMap’ </li><li><code>WeakSet.prototype[Symbol.toStringTag]</code>: ‘WeakSet’ </li><li><code>%MapIteratorPrototype%[Symbol.toStringTag]</code>: ‘Map Iterator’ </li><li><code>%SetIteratorPrototype%[Symbol.toStringTag]</code>: ‘Set Iterator’ </li><li><code>%StringIteratorPrototype%[Symbol.toStringTag]</code>: ‘String Iterator’ </li><li><code>Symbol.prototype[Symbol.toStringTag]</code>: ‘Symbol’ </li><li><code>Generator.prototype[Symbol.toStringTag]</code>: ‘Generator’ </li><li><code>GeneratorFunction.prototype[Symbol.toStringTag]</code>: ‘GeneratorFunction</li></ul><h3 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a>Symbol.unscopables</h3><p>对象的<code>Symbol.unscopables</code>属性，指向一个对象。该对象指定了使用<code>with</code>关键字时，哪些属性会被<code>with</code>环境排除</p><pre><code class="hljs">    Array.prototype[Symbol.unscopables];    // &#123;    //   copyWithin: true,    //   entries: true,    //   fill: true,    //   find: true,    //   findIndex: true,    //   includes: true,    //   keys: true    // &#125;    Object.keys(Array.prototype[Symbol.unscopables]);    // [&#39;copyWithin&#39;, &#39;entries&#39;, &#39;fill&#39;, &#39;find&#39;, &#39;findIndex&#39;, &#39;includes&#39;, &#39;keys&#39;]</code></pre><p>上面代码说明，数组有 7 个属性，会被with命令排除</p><pre><code class="hljs">    // 没有 unscopables 时    class MyClass &#123;        foo() &#123;            return 1;        &#125;    &#125;    var foo = function () &#123;        return 2;    &#125;;    with(MyClass.prototype) &#123;        foo(); // 1    &#125;    // 有 unscopables 时    class MyClass &#123;        foo() &#123;            return 1;        &#125;        get[Symbol.unscopables]() &#123;            return &#123;                foo: true            &#125;;        &#125;    &#125;    var foo = function () &#123;        return 2;    &#125;;    with(MyClass.prototype) &#123;        foo(); // 2    &#125;</code></pre><p>上面代码通过指定<code>Symbol.unscopables</code>属性，使得<code>with</code>语法块不会在当前作用域寻找<code>foo</code>属性，即<code>foo</code>将指向外层作用域的变量</p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数的扩展</title>
    <link href="/2021/11/08/ES6/%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <url>/2021/11/08/ES6/%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h1 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h1><h2 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h2><p>ES6 允许给函数参数赋值初始值</p><span id="more"></span><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>通过给形参赋初始值，具有默认值的参数, 一般位置要靠后(潜规则)，<strong>只有当传入的参数的值为<code>undefined</code>时才会使用默认值</strong></p><pre><code class="hljs">    function log(x, y = &quot;World&quot;) &#123;      console.log(x, y)    &#125;        log(&quot;Hello&quot;) // Hello World    log(&quot;Hello&quot;, &quot;China&quot;) // Hello China    log(&quot;Hello&quot;, &quot;&quot;) // Hello</code></pre><p>使用参数默认值时，函数不能有同名参数</p><pre><code class="hljs">    // 不报错，但是先传入的同名参数会被后面覆盖    function fun(x, x, y) &#123;        // ...    &#125;    // 报错    function fun(x, x, y = 1) &#123;        // ...    &#125;    // SyntaxError: Duplicate parameter name not allowed in this context</code></pre><h3 id="与解构赋值默认值结合使用"><a href="#与解构赋值默认值结合使用" class="headerlink" title="与解构赋值默认值结合使用"></a>与解构赋值默认值结合使用</h3><p>参数默认值可以与解构赋值的默认值，结合起来使用</p><pre><code class="hljs">    function fun(&#123; x, y = 5 &#125;) &#123;      console.log(x, y);    &#125;        fun(&#123;&#125;); // undefined 5    fun(&#123; x: 1 &#125;); // 1 5    fun(&#123; x: 1, y: 2 &#125;); // 1 2    fun(); // TypeError: Cannot read property &#39;x&#39; of undefined</code></pre><p>上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值</p><p>只有当函数<code>fun</code>的参数是一个对象时，变量<code>x</code>和<code>y</code>才会通过解构赋值生成。如果函数<code>fun</code>调用时没提供参数，变量<code>x</code>和<code>y</code>就不会生成，从而报错</p><pre><code class="hljs">    function fun(&#123; x, y = 5 &#125; = &#123;&#125;) &#123;      console.log(x, y)    &#125;        fun() // undefined 5</code></pre><p>上面代码指定，如果没有提供参数，函数<code>fun</code>的参数默认为一个空对象</p><p>例：</p><pre><code class="hljs">    function fetch(url, &#123; body = &quot;&quot;, method = &quot;GET&quot;, headers = &#123;&#125; &#125;) &#123;      console.log(method);    &#125;        fetch(&quot;https://example.com&quot;, &#123;&#125;);    // &quot;GET&quot;        fetch(&quot;https://example.com&quot;);    // 报错</code></pre><p>上面代码中，如果函数<code>fetch</code>的第二个参数是一个对象，就可以为它的三个属性设置默认值。<br>这种写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。</p><pre><code class="hljs">    function fetch(url, &#123; body = &quot;&quot;, method = &quot;GET&quot;, headers = &#123;&#125; &#125; = &#123;&#125;) &#123;      console.log(method);    &#125;        fetch(&quot;https://example.com&quot;);    // &quot;GET&quot;</code></pre><p>上面代码中，函数<code>fetch</code>没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量<code>method</code>才会取到默认值<code>GET</code></p><p>问：以下代码有何区别</p><pre><code class="hljs">    // 写法一    function m1(&#123; x = 0, y = 0 &#125; = &#123;&#125;) &#123;      return [x, y]    &#125;        // 写法二    function m2(&#123; x, y &#125; = &#123; x: 0, y: 0 &#125;) &#123;      return [x, y]    &#125;</code></pre><p>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值<br>写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值</p><pre><code class="hljs">    // 函数没有参数的情况    m1() // [0, 0]    m2() // [0, 0]        // x 和 y 都有值的情况    m1(&#123; x: 3, y: 8 &#125;) // [3, 8]    m2(&#123; x: 3, y: 8 &#125;) // [3, 8]        // x 有值，y 无值的情况    m1(&#123; x: 3 &#125;) // [3, 0]    m2(&#123; x: 3 &#125;) // [3, undefined]        // x 和 y 都无值的情况    m1(&#123;&#125;) // [0, 0];    m2(&#123;&#125;) // [undefined, undefined]</code></pre><h3 id="函数的-length-属性"><a href="#函数的-length-属性" class="headerlink" title="函数的 length 属性"></a>函数的 length 属性</h3><p>指定了默认值以后，函数的<code>length</code>属性，将返回没有指定默认值的参数个数</p><pre><code class="hljs">    (function (a) &#123;&#125;).length // 1    (function (a = 5) &#123;&#125;).length // 0    (function (a, b, c = 5) &#123;&#125;).length // 2</code></pre><p>因为<code>length</code>属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了</p><p>如果设置了默认值的参数不是尾参数，那么<code>length</code>属性也不再计入后面的参数了</p><pre><code class="hljs">    (function (a, b = 1, c) &#123;&#125;).length  // 1</code></pre><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域(context)。等到初始化结束，这个作用域就会消失</p><pre><code class="hljs">    let x = 1        function fun(x, y = x) &#123;      console.log(y)    &#125;        fun(2) // 2</code></pre><p>上面代码中，参数<code>y</code>的默认值等于<code>x</code>，调用<code>fun()</code>时，此时形成了封闭的作用域，默认值<code>x</code>指向第一个参数<code>x</code>，也就是2</p><pre><code class="hljs">    let x = 1    function fun(y = x) &#123;        let x = 3        console.log(y)    &#125;    fun() // 1</code></pre><p>上面代码中，函数f调用时，参数<code>y = x</code>形成一个单独的作用域。这个作用域里面，变量<code>x</code>本身没有定义，所以指向外层的全局变量<code>x</code>。函数调用时，函数体内部的局部变量<code>x</code>影响不到默认值变量<code>x</code>。 </p><p>如果此时，全局变量<code>x</code>不存在，就会报错</p><h2 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h2><p>ES6 引入 <code>rest</code> 参数(形式为…变量名)，用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了。<br><code>rest</code> 参数搭配的变量是一个数组，该变量将多余的参数放入数组中</p><pre><code class="hljs">    // ES5 获取实参的方式    function fun()&#123;        console.log(arguments)    &#125;    fun(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)    // rest 参数    function fun(x, ...args)&#123;        console.log(args);// filter some every map     &#125;    fun(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) // b c</code></pre><p><code>rest</code> 参数必须要放到参数最后，否则会报错</p><pre><code class="hljs">    function fun(a, ...args, b) &#123;&#125;    // SyntaxError: Rest parameter must be last formal parameter</code></pre><p>函数的<code>length</code>属性，不包括 <code>rest</code> 参数</p><pre><code class="hljs">    (function (...args) &#123;&#125;).length // 0    (function (a, b, ...args) &#123;&#125;).length // 2</code></pre><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>ES6 允许使用“箭头”(<code>=&gt;</code>)定义函数</p><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><pre><code class="hljs">    let fun = function (a) &#123;        return a * a    &#125;    // 等价于    let fun = (a) =&gt; &#123;        return a * a    &#125;</code></pre><p>如果箭头函数当形参有且只有一个的时候，可以省略<code>()</code><br>当代码体只有一条语句的时候, 可以省略<code>&#123;&#125;</code>，但此时 <code>return</code> 必须省略，<code>return</code> 返回该条语句执行结果</p><pre><code class="hljs">    let fun = (a) =&gt; &#123;        return a * a    &#125;    //等价于    let fun = a =&gt; a * a</code></pre><p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错</p><pre><code class="hljs">    // 报错    let getTempItem = id =&gt; &#123; id: id, name: &quot;Temp&quot; &#125;        // 不报错    let getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;)</code></pre><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p><code>this</code> 是静态的. <code>this</code> 始终指向函数声明时所在作用域下的 <code>this</code> 的值</p><pre><code class="hljs"> function getName() &#123;     console.log(this.name) &#125; let getName2 = () =&gt; &#123;     console.log(this.name) &#125; window.name = &quot;window&quot; const obj = &#123;     name: &quot;obj&quot; &#125;  // 直接调用 getName() //window  getName2() //window // call 方法调用 getName.call(obj) //obj getName2.call(obj) //window</code></pre><p> 上面代码中都是定义在全局作用域中，而箭头函数<code>getName2()</code> this始终指向全局作用域，不随 <code>call()</code> 的调用而改变</p><p> 如在回调函数中使用<br> let div &#x3D; document.getElementById(“test-div”)<br> div.onclick &#x3D; function () {<br>     &#x2F;&#x2F; setTimeout(function () {<br>     &#x2F;&#x2F;     console.log(this) &#x2F;&#x2F; 此时this是window<br>     &#x2F;&#x2F;     this.style.background &#x3D; “red”<br>     &#x2F;&#x2F; },2000)<br><br>     setTimeout(() &#x3D;&gt; {<br>         &#x2F;&#x2F; 此时this是外部作用域div<br>         this.style.background &#x3D; “red”<br>     }, 2000)<br> }</p></li><li><p>不能作为构造实例化对象,也就是说，不可以使用new命令，否则会抛出一个错误</p><pre><code class="hljs">  let Person = (name, age) =&gt; &#123;      this.name = name      this.age = age  &#125;  let me = new Person(&#39;tom&#39;,30)   //Uncaught TypeError: Person is not a constructor  console.log(me)</code></pre></li><li><p>不能使用 <code>arguments</code> 变量,该对象在函数体内不存在。如果要用，可以用 <code>rest</code> 参数代替</p><pre><code class="hljs">  let fun = () =&gt; &#123;      console.log(arguments);  &#125;  fun(1, 2)  // ReferenceError: arguments is not defined</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变量解构赋值</title>
    <link href="/2021/11/06/ES6/%E5%8F%98%E9%87%8F%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <url>/2021/11/06/ES6/%E5%8F%98%E9%87%8F%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h1><p>ES6 允许按照一定模式从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。</p><span id="more"></span><h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><pre><code class="hljs">    const ARR = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]    let [a, b, c] = ARR    //等价于 let [a, b, c] = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]    console.log(a, b, c) // 1 2 3 </code></pre><p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p><p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</p><p>下面是一些使用嵌套数组进行解构的例子</p><pre><code class="hljs">    let [, , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]    console.log(third) // &quot;baz&quot;    let [x, , y] = [1, 2, 3]    console.log(x) // 1    console.log(y) // 3        // ...x 为匹配剩余项    let [head, ...tail] = [1, 2, 3, 4]    console.log(head) // 1    console.log(tail) // [2, 3, 4]    let [x, y, ...z] = [&quot;a&quot;]    console.log(x) // &quot;a&quot;    console.log(y) // undefined    console.log(z) // []</code></pre><p>如果解构不成功，变量的值就等于undefined。</p><pre><code class="hljs">    let [foo] = []    let [bar, foo] = [1]    // foo的值都为undefined</code></pre><p>解构赋值允许指定默认值。 </p><pre><code class="hljs">    let [foo = true] = []    console.log(foo) // true        let [x, y = &quot;b&quot;] = [&quot;a&quot;]; // x=&#39;a&#39;, y=&#39;b&#39;    let [x, y = &quot;b&quot;] = [&quot;a&quot;, undefined]; // x=&#39;a&#39;, y=&#39;b&#39;</code></pre><p>注意，ES6 内部使用严格相等运算符(&#x3D;&#x3D;&#x3D;)，判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。 </p><pre><code class="hljs">    let [x = 1] = [undefined]    console.log(x) // 1        let [y = 1] = [null];    console.log(y) // null</code></pre><h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><pre><code class="hljs">    const obj = &#123;        name: &quot;tom&quot;,        age: 18,        fun: function () &#123;            console.log(&quot;i am tom&quot;)        &#125;    &#125;    let &#123;name, age, fun&#125; = obj    console.log(name, age, fun) // tom 18 function()    fun() // i am tom</code></pre><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值，否则为undefined</p><pre><code class="hljs">    let &#123;age, sex&#125; = obj    console.log(age, sex) //18 undefined</code></pre><p>如果变量名与属性名不一致，必须写成下面这样:</p><pre><code class="hljs">    let &#123; foo: baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;    console.log(baz) // aaa    console.log(foo) //Uncaught ReferenceError: foo is not defined</code></pre><p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量，即 <code>foo</code> 是匹配的模式， <code>baz</code> 才是变量。真正被赋值的是变量 <code>baz</code> ，而不是模式 <code>foo</code></p><p>对象的解构也可以指定默认值,默认值生效的条件是，对象的属性值严格等于<code>undefined</code></p><pre><code class="hljs">    let &#123; x = 3 &#125; = &#123;&#125;    console.log(x) // 3        let &#123; x, y = 5 &#125; = &#123; x: 1 &#125;    console.log(x) // 1    console.log(y) // 5        let &#123; x: y = 3 &#125; = &#123; x: 5 &#125;    console.log(y) // 5</code></pre><p>如果解构失败，变量的值等于undefined。</p><pre><code class="hljs">    let &#123; foo &#125; = &#123; bar: &quot;baz&quot; &#125;    console.log(foo) // undefined</code></pre><h2 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h2><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象</p><pre><code class="hljs">    let [a, b, c, d, e] = &quot;hello&quot;    console.log(a, b, c, d, e) // h e l l o</code></pre><p>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</p><pre><code class="hljs">    let &#123;length&#125; = &quot;hello    console.log(length) //5</code></pre><h2 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h2><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p><pre><code class="hljs">    let &#123;toString: s&#125; = 123    s === Number.prototype.toString // true        let &#123;toString: s&#125; = true    s === Boolean.prototype.toString // true</code></pre><p>上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。</p><p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</p><pre><code class="hljs">    let &#123; prop: x &#125; = undefined // TypeError    let &#123; prop: y &#125; = null // TypeError</code></pre><h2 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h2><p>函数的参数也可以使用解构赋值</p><pre><code class="hljs">    function add([x, y])&#123;      return x + y    &#125;        add([1, 2]) // 3        [[1, 2], [3, 4]].map(([a, b]) =&gt; a + b)// [ 3, 7 ]</code></pre><p>上面代码中，函数<code>add()</code>的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量<code>x</code>和<code>y</code>。对于函数内部的代码来说，它们能感受到的参数就是<code>x</code>和<code>y</code></p><p>函数参数的解构也可以使用默认值</p><pre><code class="hljs">    function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;      return [x, y]    &#125;        move(&#123;x: 3, y: 8&#125;);// [3, 8]    move(&#123;x: 3&#125;) // [3, 0]    move(&#123;&#125;) // [0, 0]    move() // [0, 0]</code></pre><p>下面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果<code>undefined</code>就会触发函数参数的默认值</p><pre><code class="hljs">    function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;      return [x, y]    &#125;        move(&#123;x: 3, y: 8&#125;) // [3, 8]    move(&#123;x: 3&#125;) // [3, undefined]    move(&#123;&#125;) // [undefined, undefined]    move() // [0, 0]        [1, undefined, 3].map((x = &#39;yes&#39;) =&gt; x)// [ 1, &#39;yes&#39;, 3 ]</code></pre>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>let与const</title>
    <link href="/2021/10/30/ES6/let%E4%B8%8Econst/"/>
    <url>/2021/10/30/ES6/let%E4%B8%8Econst/</url>
    
    <content type="html"><![CDATA[<h1 id="let与conset"><a href="#let与conset" class="headerlink" title="let与conset"></a>let与conset</h1><p>在ES6中引入了变量声明的两种方式，let 与 conset </p><ul><li>let 用来声明变量</li><li>conset 用来声明常量<span id="more"></span></li></ul><h2 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</p><pre><code class="hljs">    &#123;        let a = 10        var b = 1    &#125;    a // ReferenceError: a is not defined.    b // 1</code></pre><p>上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。</p><p>例：通过定时器每秒打印0-4</p><pre><code class="hljs">    for(var i = 0; i &lt; 5; i++)&#123;        setTimeout(function()&#123;            alert(i)        &#125;,1000)    &#125;    // 5 5 5 5 5 </code></pre><p>因为ES5之前没有块级作用域的概念，所以循环定时器、回调函数执行时的 i 定义在<code>window</code>中，当回调函数执行时，会向上级作用域中寻找到<code>window.i </code>此时 <code>i === 5</code>，故</p><pre><code class="hljs">    for(let i = 0; i &lt; 5; i++)&#123;        setTimeout(function()&#123;            alert(i)        &#125;,1000)    &#125;    // 0 1 2 3 4</code></pre><p>在块级作用域中，使用<code>let</code>定义 i , 相当于在每个块级作用域中定义了一个i，回调函数不必在全局作用域中寻找i的值</p><pre><code class="hljs">        for (let i = 0; i &lt; 5; i++) &#123;            setTimeout(function () &#123;                alert(i)            &#125;, 1000)        &#125;         &#123;            let i = 0            setTimeout(function () &#123;                alert(i)            &#125;, 1000)        &#125;         &#123;            let i = 1            setTimeout(function () &#123;                alert(i)            &#125;, 1000)        &#125;</code></pre><h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><p>var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。<br>而let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p><pre><code class="hljs">    // var 的情况    console.log(foo) // 输出undefined    var foo = 2    // let 的情况    console.log(bar) // 报错ReferenceError    let bar = 2</code></pre><h3 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h3><p><code>let</code> 不允许在相同作用域内，重复声明同一个变量。<code>var</code>可以</p><pre><code class="hljs">    // 报错    function fun1() &#123;        let a = 10        var a = 1    &#125;    // 报错    function fuc2() &#123;        let a = 10        let a = 1    &#125;    // 正常    function fu() &#123;        var a = 10        var a = 1    &#125;</code></pre><h2 id="conset命令"><a href="#conset命令" class="headerlink" title="conset命令"></a>conset命令</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>const</code> 声明一个只读的常量。一旦声明，常量的值就不能改变，一般用 <code>conset</code> 声明的常量用大写表示</p><pre><code class="hljs">    const PI = 3.1415    PI // 3.1415        PI = 3    // TypeError: Assignment to constant variable.</code></pre><p>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值</p><pre><code class="hljs">    const ITEM    // SyntaxError: Missing initializer in const declaration</code></pre><p>const的作用域与let命令相同: 只在声明所在的块级作用域内有效。</p><pre><code class="hljs">    if (true) &#123;      const MAX = 5    &#125;    console.log(MAX) //ReferenceError: MAX is not defined</code></pre><h3 id="conset的本质"><a href="#conset的本质" class="headerlink" title="conset的本质"></a>conset的本质</h3><ul><li><p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动</p></li><li><p>对于<strong>简单类型的数据</strong>(数值、字符串、布尔值)，值就保存在变量指向的那个内存地址，因此等同于常量</p></li><li><p>对于<strong>复合类型的数据</strong>(主要是对象和数组)，变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的(即总是指向另一个固定的地址)，至于它指向的数据结构是不是可变的，就完全不能控制了</p><pre><code class="hljs">  const ARR = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;]  ARR.push(&quot;5&quot;)  console.log(ARR) //[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;]  ARR = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] //TypeError: Assignment to constant variable.</code></pre></li></ul><p>对于数组和对象的元素修改, 不算做对常量的修改, 不会报错，因为conset 只能<strong>确保对象所指向的地址不能改变</strong>，而地址的内容就无法保证了</p><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><h3 id="为什么需要块级作用域"><a href="#为什么需要块级作用域" class="headerlink" title="为什么需要块级作用域"></a>为什么需要块级作用域</h3><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p><ul><li><p>第一种场景，内层变量可能会覆盖外层变量。</p><pre><code class="hljs">  var tmp = new Date()  function fun() &#123;      console.log(tmp)      if (false) &#123;          var tmp = &quot;hello world&quot;      &#125;  &#125;  fun(); // undefined</code></pre><p>  上面代码的原意是，if代码块的外部使用外层的 <code>tmp</code> 变量，内部使用内层的 <code>tmp</code> 变量。但是，函数<code>fun()</code>执行后，输出结果为 <code>undefined</code>，原因在于变量提升，导致内层的 <code>tmp</code> 变量覆盖了外层的 <code>tmp</code> 变量。 </p></li><li><p>第二种场景，用来计数的循环变量泄露为全局变量。</p><pre><code class="hljs">  for(var i = 0; i &lt; 5; i++)&#123;      setTimeout(function()&#123;          alert(i)      &#125;,1000)  &#125;  // 5 5 5 5 5 </code></pre><p>  上面代码中i定义为全局变量，导致回调函数执行时，使用的是全局作用域中的 i</p></li></ul><h3 id="ES6-的块级作用域"><a href="#ES6-的块级作用域" class="headerlink" title="ES6 的块级作用域"></a>ES6 的块级作用域</h3><p>用let命令新增了块级作用域，外层作用域无法获取到内层作用域，内层作用域能获取到外层作用域声明的变量</p><pre><code class="hljs">     &#123;        let a = &quot;aa&quot;         &#123;            console.log(a) // aa        &#125;    &#125;    &#123;        console.log(b)  // ReferrenceError        &#123;            let b = &quot;bb&quot;         &#125;    &#125;</code></pre><p>同时内层作用域可以定义外层作用域的同名变量</p><pre><code class="hljs">  &#123;    let a = &quot;Hello World&quot;    &#123;      let a = &quot;Hello World&quot;    &#125;  &#125;</code></pre><h3 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h3><p>运行环境：ES6浏览器。</p><p>可实现的行为：</p><ol><li><p>允许在块级作用域内声明函数</p></li><li><p>函数声明类似于var， 即会提升到全局作用域或函数作用域的头部</p></li><li><p>函数声明还会提升到所有块级作用域的头部</p><pre><code class="hljs"> function func() &#123;     console.log(&#39;outside&#39;) &#125; (function () &#123;     // var Func = undefined;     if (false) &#123;         function func() &#123;             console.log(&#39;inside&#39;)         &#125;     &#125;     func() //Uncaught TypeError: func is not a function &#125;)() //报错</code></pre></li></ol><p>考虑到环境导致的差异太大，应该避免在块级作用域中声明函数，如果需要，应该写成函数表达式的形式，而不是函数声明语句</p><p>ES6的块级作用域允许声明函数的规则只在使用大括号的情况下成立：</p><pre><code class="hljs">    &#39;use strict&#39;    if (true) &#123;        function Func1() &#123;&#125; // 不报错      &#125;    if (true)        function Func2() &#123;&#125; // 报错        // In strict mode code, functions can only be declared              at top level or inside a block.</code></pre>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6简介</title>
    <link href="/2021/10/30/ES6/ES6%E7%AE%80%E4%BB%8B/"/>
    <url>/2021/10/30/ES6/ES6%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="ES6简介"><a href="#ES6简介" class="headerlink" title="ES6简介"></a>ES6简介</h1><p>ECMAScript 6.0(以下简称 ES6)是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p><span id="more"></span><h2 id="ECMAScript-和-JavaScript-的关系"><a href="#ECMAScript-和-JavaScript-的关系" class="headerlink" title="ECMAScript 和 JavaScript 的关系"></a>ECMAScript 和 JavaScript 的关系</h2><p>一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？<br>要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件(ECMA-262)的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。 </p><p>该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。</p><p>因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现(另外的 ECMAScript 方言还有 Jscript 和 ActionScript)。日常场合，这两个词是可以互换的。</p><h2 id="ES6-与-ECMAScript-2015-的关系"><a href="#ES6-与-ECMAScript-2015-的关系" class="headerlink" title="ES6 与 ECMAScript 2015 的关系"></a>ES6 与 ECMAScript 2015 的关系</h2><p>ECMAScript 2015(简称 ES2015)这个词，也是经常可以看到的。它与 ES6 是什么关系呢？ </p><p>2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。 </p><p>但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。常规的做法是先发布 6.0 版，过一段时间再发 6.1 版，然后是 6.2 版、6.3 版等等。<br>但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程: 任何人在任何时候，都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。 </p><p>标准委员会最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的 6 月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。 </p><p>ES6 的第一个版本，就这样在 2015 年 6 月发布了，正式名称就是《ECMAScript 2015 标准》(简称 ES2015)。2016 年 6 月，小幅修订的《ECMAScript 2016 标准》(简称 ES2016)如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小(只新增了数组实例的includes方法和指数运算符)，基本上是同一个标准。根据计划，2017 年 6 月发布 ES2017 标准。<br>因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。</p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery轮播图</title>
    <link href="/2021/10/26/%E5%AE%9E%E6%88%98/jQuery%E8%BD%AE%E6%92%AD%E5%9B%BE/"/>
    <url>/2021/10/26/%E5%AE%9E%E6%88%98/jQuery%E8%BD%AE%E6%92%AD%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="jQuery实现轮播图"><a href="#jQuery实现轮播图" class="headerlink" title="jQuery实现轮播图"></a>jQuery实现轮播图</h1><p> 功能说明:</p><ol><li>点击向右(左)的图标, 平滑切换到下(上)一页</li><li>无限循环切换: 第一页的上一页为最后页, 最后一页的下一页是第一页</li><li>每隔3s自动滑动到下一页</li><li>当鼠标进入图片区域时, 自动切换停止, 当鼠标离开后,又开始自动切换</li><li>切换页面时, 下面的圆点也同步更新</li><li>点击圆点图标切换到对应的页</li></ol><p> bug: 快速点击时, 翻页不正常</p><span id="more"></span><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><pre><code class="hljs">    // html 部分    &lt;div id=&quot;container&quot;&gt;        &lt;div id=&quot;list&quot; style=&quot;left: -600px;&quot;&gt;            &lt;img src=&quot;img/5.jpg&quot; alt=&quot;5&quot; /&gt;            &lt;img src=&quot;img/1.jpg&quot; alt=&quot;1&quot; /&gt;            &lt;img src=&quot;img/2.jpg&quot; alt=&quot;2&quot; /&gt;            &lt;img src=&quot;img/3.jpg&quot; alt=&quot;3&quot; /&gt;            &lt;img src=&quot;img/4.jpg&quot; alt=&quot;4&quot; /&gt;            &lt;img src=&quot;img/5.jpg&quot; alt=&quot;5&quot; /&gt;            &lt;img src=&quot;img/1.jpg&quot; alt=&quot;1&quot; /&gt;        &lt;/div&gt;        &lt;div id=&quot;pointsDiv&quot;&gt;            &lt;span index=&quot;1&quot; class=&quot;on&quot;&gt;&lt;/span&gt;            &lt;span index=&quot;2&quot;&gt;&lt;/span&gt;            &lt;span index=&quot;3&quot;&gt;&lt;/span&gt;            &lt;span index=&quot;4&quot;&gt;&lt;/span&gt;            &lt;span index=&quot;5&quot;&gt;&lt;/span&gt;        &lt;/div&gt;        &lt;a href=&quot;javascript:;&quot; id=&quot;prev&quot; class=&quot;arrow&quot;&gt;&amp;lt;&lt;/a&gt;        &lt;a href=&quot;javascript:;&quot; id=&quot;next&quot; class=&quot;arrow&quot;&gt;&amp;gt;&lt;/a&gt;    &lt;/div&gt;  // js 部分    $(function () &#123;        var $container = $(&#39;#container&#39;)    //获取整个轮播图外部div        var $list = $(&#39;#list&#39;)  //获取图片列表div        var $points = $(&#39;#pointsDiv&gt;span&#39;)  // 获取圆点sapn        var $prev = $(&#39;#prev&#39;)  // 获取上一张按钮        var $next = $(&#39;#next&#39;)  // 获取下一张按钮        var PAGE_WIDTH = 600 //一页的宽度        var TIME = 400 // 翻页的持续时间        var ITEM_TIME = 20 // 单元移动的间隔时间        var imgCount = $points.length   //img张数        var index = 0 //当前下标        var moving = false // 标识是否正在翻页(默认没有)        // 1. 点击向右(左)的图标, 平滑切换到下(上)一页        $next.click(function () &#123;            // 平滑翻到下一页            nextPage(true)        &#125;)        $prev.click(function () &#123;            // 平滑翻到上一页            nextPage(false)        &#125;)        // 3. 每隔3s自动滑动到下一页        var intervalId = setInterval(function () &#123;            nextPage(true)        &#125;, 1000)        // 4. 当鼠标进入图片区域时, 自动切换停止, 当鼠标离开后,又开始自动切换        $container.hover(function () &#123;            // 清除定时器            clearInterval(intervalId)        &#125;, function () &#123;            intervalId = setInterval(function () &#123;                nextPage(true)            &#125;, 1000)        &#125;)        // 6. 点击圆点图标切换到对应的页        $points.click(function () &#123;            // 目标页的下标            var targetIndex = $(this).index()            // 只有当点击的不是当前页的圆点时才翻页            if (targetIndex != index) &#123;                nextPage(targetIndex)            &#125;        &#125;)        /**         * 平滑翻页         * @param next         * true: 下一页         * false: 上一页         * 数值: 指定下标页         */        function nextPage(next) &#123;            /*              总的时间: TIME=400              单元移动的间隔时间: ITEM_TIME = 20              总的偏移量: offset              单元移动的偏移量: itemOffset = offset/(TIME/ITEM_TIME)              启动循环定时器不断更新$list的left, 到达目标处停止停止定时器             */            //如果正在翻页, 直接结束            if (moving) &#123; //已经正在翻页中                return            &#125;            moving = true // 标识正在翻页            // 总的偏移量: offset            var offset = 0            // 计算offset            if (typeof next === &#39;boolean&#39;) &#123;                offset = next ? -PAGE_WIDTH : PAGE_WIDTH            &#125; else &#123;                offset = -(next - index) * PAGE_WIDTH            &#125;            // 计算单元移动的偏移量: itemOffset            var itemOffset = offset / (TIME / ITEM_TIME)            // 得到当前的left值            var currLeft = $list.position().left            // 计算出目标处的left值            var targetLeft = currLeft + offset            // 启动循环定时器不断更新$list的left, 到达目标处停止停止定时器            var intervalId = setInterval(function () &#123;                // 计算出最新的currLeft                currLeft += itemOffset                if (currLeft === targetLeft) &#123; // 到达目标位置                    // 清除定时器                    clearInterval(intervalId)                    // 标识翻页停止                    moving = false                    // 如果到达了最右边的图片(1.jpg), 跳转到最左边的第2张图片(1.jpg)                    if (currLeft === -(imgCount + 1) * PAGE_WIDTH) &#123;                        currLeft = -PAGE_WIDTH                    &#125; else if (currLeft === 0) &#123;                        // 如果到达了最左边的图片(5.jpg), 跳转到最右边的第2张图片(5.jpg)                        currLeft = -imgCount * PAGE_WIDTH                    &#125;                &#125;                // 设置left                $list.css(&#39;left&#39;, currLeft)                // console.log(currLeft)            &#125;, ITEM_TIME)                        // 更新圆点            updatePoints(next)        &#125;        /**         * 更新圆点         * @param next         */        function updatePoints(next) &#123;            // 计算出目标圆点的下标targetIndex            var targetIndex = 0            if (typeof next === &#39;boolean&#39;) &#123;                if (next) &#123;                    targetIndex = index + 1 // [0, imgCount-1]                    if (targetIndex === imgCount) &#123; // 此时看到的是1.jpg--&gt;第1个圆点                        targetIndex = 0                    &#125;                &#125; else &#123;                    targetIndex = index - 1                    if (targetIndex === -1) &#123; // 此时看到的是5.jpg--&gt;第5个圆点                        targetIndex = imgCount - 1                    &#125;                &#125;            &#125; else &#123;                targetIndex = next            &#125;            // 将当前index的&lt;span&gt;的class移除            // $points.eq(index).removeClass(&#39;on&#39;)            $points[index].className = &#39;&#39;            // 给目标圆点添加class=&#39;on&#39;            // $points.eq(targetIndex).addClass(&#39;on&#39;)            $points[targetIndex].className = &#39;on&#39;            // 将index更新为targetIndex            index = targetIndex        &#125;    &#125;)</code></pre><h2 id="知识要点"><a href="#知识要点" class="headerlink" title="知识要点"></a>知识要点</h2><ul><li><p>上段代码中图片切换通过<code>nextPage(next)</code> 函数实现，这样的好处是方便调用，如点击切换，以及循环定时器自调用中。同时圆点的更新和图片切换同时执行。</p></li><li><p><code>nextPage(next)</code> 函数</p><ol><li><p>整体思路<br> 轮播图实际上是图片的分段移动，通过不断调用循环定时器让图片分段移动，故总偏移量为一张或多张图片宽度，每段时间间隔移动一点距离，到达指定位置后就清除定时器</p></li><li><p>next 参数的设置<br> next 参数有三个值，ture：下一页 ，false ：上一页 ，数值：指定下标页</p><pre><code class="hljs"> if (typeof next === &#39;boolean&#39;) &#123;     //点击上下页按钮时触发     offset = next ? -PAGE_WIDTH : PAGE_WIDTH &#125; else &#123;     // 点击圆点跳转指定页触发     offset = -(next - index) * PAGE_WIDTH &#125;</code></pre></li><li><p>如何解决图片循环展示问题</p><pre><code class="hljs"> // 如果到达了最右边的图片(1.jpg), 跳转到最左边的第2张图片(1.jpg) if (currLeft === -(imgCount + 1) * PAGE_WIDTH) &#123;     currLeft = -PAGE_WIDTH &#125; else if (currLeft === 0) &#123;     // 如果到达了最左边的图片(5.jpg), 跳转到最右边的第2张图片(5.jpg)     currLeft = -imgCount * PAGE_WIDTH &#125;</code></pre><p> 如下图所示，当图片的<code>left === -600*5</code> 时，此时为循环展示的最后一张图片，此时将图片切换到列表第一张图片，以达到无缝切换，第一张同理</p><p> <img src="/images/jQuery/jQuery%E8%BD%AE%E6%92%AD%E5%9B%BE1.png" alt="jQuery轮播图1.png"></p></li><li><p>如何解决快速点击时, 翻页不正常<br> 产生原因：同时执行了多个循环定时器，导致图片div的left属性设置不正常<br> 解决办法：通过设置标识符判断循环定时器是否在执行，如果在执行则停止当前正在执行的定时器，开启新的定时器<br> 注：在执行<code>nextPage(next)</code> 时 <code>moving</code> 设置为 <code>true</code>，清除定时器时 <code>moving</code> 设置为 <code>false</code> </p><pre><code class="hljs"> var moving = false //默认没有反页 nextPage(next)&#123;     if (moving) &#123; //如果正在翻页中         return     &#125;     moving = true // 标识正在翻页          // 设置定时器     var intervalId = setInterval(function () &#123;             // 。。。                  // 到达目标位置     if (currLeft === targetLeft) &#123;      // 清除定时器     clearInterval(intervalId)          // 标识翻页停止     moving = false                  // 。。。              &#125;     &#125;, ITEM_TIME) &#125;</code></pre></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>DOM</tag>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery插件</title>
    <link href="/2021/10/24/jQuery/jQuery%E6%8F%92%E4%BB%B6/"/>
    <url>/2021/10/24/jQuery/jQuery%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="jQuery插件"><a href="#jQuery插件" class="headerlink" title="jQuery插件"></a>jQuery插件</h1><ul><li>我们可以扩展 jQuery 来实现自定义方法。这种方式也称为编写 jQuery 插件。</li><li>在使用jQuery插件时，应该先引入jQuery库文件，然后在引用jQuery插件<span id="more"></span></li></ul><h2 id="扩展jQuery的工具方法"><a href="#扩展jQuery的工具方法" class="headerlink" title="扩展jQuery的工具方法"></a>扩展jQuery的工具方法</h2><p>扩展jQuery的工具方法，<code>$.extend(object)</code><br>用来在jQuery命名空间上增加新函数：</p><pre><code class="hljs">    //min方法返回一个较小值，max返回一个较大值    $.extend(&#123;        min: function (a, b) &#123;            return a &lt; b ? a : b        &#125;,        max: function (a, b) &#123;            return a &gt; b ? a : b        &#125;    &#125;)    //使用    $.min(3, 5) //3    $.max(3, 5) //5    </code></pre><h2 id="扩展jQuery对象的方法"><a href="#扩展jQuery对象的方法" class="headerlink" title="扩展jQuery对象的方法"></a>扩展jQuery对象的方法</h2><p>扩展jQuery对象的方法，<code>$.fn.extend(object)</code><br>扩展 jQuery 对象来提供新的方法</p><pre><code class="hljs">    $.fn.extend(&#123;    // checkAll() : 全选    checkAll: function () &#123;        this.prop(&#39;checked&#39;, true) // this是jQuery对象        return this // this是jQuery对象    &#125;,    // unCheckAll() : 全不选    unCheckAll: function () &#123;        this.prop(&#39;checked&#39;, false)        return this    &#125;,    // reverseCheck() : 全反选    reverseCheck: function () &#123;        // this是jQuery对象        this.each(function () &#123;            // this是dom元素            this.checked = !this.checked        &#125;)        return this    &#125;    &#125;)    // 使用, 全选复选框，并将复选框的value更改为111    $(&#39;:checkbox[name=items]&#39;).checkAll().attr(&quot;value&quot;, &quot;111&quot;)</code></pre><ul><li>注：插件函数最后要 <code>return this</code> 以支持链式调用；</li></ul><h2 id="多库共存"><a href="#多库共存" class="headerlink" title="多库共存"></a>多库共存</h2><ul><li><p>问题 : 如果有2个库都有$, 就存在冲突</p></li><li><p>解决 : jQuery库可以释放$的使用权, 让另一个库可以正常使用, 此时jQuery库只能使用jQuery了</p></li><li><p>API : <code>jQuery.noConflict()</code></p><pre><code class="hljs">  //自定义js文件  (function () &#123;    window.$ = function () &#123;      console.log(&#39;my lib $()...&#39;)    &#125;  &#125;)()  //调用  // 释放$的使用权  jQuery.noConflict()  // 调用myLib中的$  $()  // 要想使用jQuery的功能, 只能使用jQuery  jQuery(function () &#123;      console.log(&#39;文档加载完成&#39;)  &#125;)</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>jQuery</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery动画</title>
    <link href="/2021/10/24/jQuery/jQuery%E5%8A%A8%E7%94%BB/"/>
    <url>/2021/10/24/jQuery/jQuery%E5%8A%A8%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="jQuery动画"><a href="#jQuery动画" class="headerlink" title="jQuery动画"></a>jQuery动画</h1><h2 id="slideUp-slideDown"><a href="#slideUp-slideDown" class="headerlink" title="slideUp &#x2F; slideDown"></a>slideUp &#x2F; slideDown</h2><p><strong>滑动动画</strong>: 通过不断改变元素的高度(height)实现</p><ul><li><code>slideDown()</code>: 带动画的展开</li><li><code>slideUp()</code>: 带动画的收缩</li><li><code>slideToggle()</code>: 带动画的切换展开&#x2F;收缩<span id="more"></span><pre><code class="hljs">  const div = $(&quot;#test-slide&quot;);    div.slideUp(3000); // 在3秒钟内逐渐向上消失</code></pre></li></ul><p>时间以毫秒为单位，但也可以是 ‘slow(600)’，’normal(400)’，’fast(200)’ 这些字符串，无参调用就是’normal’</p><pre><code class="hljs">    const div = $(&quot;#test-show-hide&quot;);        div.slideDown(&quot;slow&quot;); // 在600ms内逐渐滑出</code></pre><h2 id="fadeIn-fadeOut"><a href="#fadeIn-fadeOut" class="headerlink" title="fadeIn &#x2F; fadeOut"></a>fadeIn &#x2F; fadeOut</h2><p><strong>淡入淡出</strong>: 不断改变元素的透明度(opacity)来实现的</p><ul><li><p><code>fadeIn()</code>: 带动画的显示</p></li><li><p><code>fadeOut()</code>: 带动画隐藏</p></li><li><p><code>fadeToggle()</code>: 带动画切换显示&#x2F;隐藏</p><pre><code class="hljs">  const div = $(&#39;#test-fade&#39;);    div.fadeOut(&#39;slow&#39;); // 在 0.6 秒内淡出  fadeOut(&#39;slow&#39;)  fadeIn(&#39;slow&#39;)  fadeToggle(&#39;slow&#39;)</code></pre></li></ul><h2 id="show-hide"><a href="#show-hide" class="headerlink" title="show &#x2F; hide"></a>show &#x2F; hide</h2><p><strong>显示隐藏</strong>，默认没有动画, 动画通过改变(opacity&#x2F;height&#x2F;width)</p><ul><li><p><code>show()</code>: (不)带动画的显示</p></li><li><p><code>hide()</code>: (不)带动画的隐藏</p></li><li><p><code>toggle()</code>: (不)带动画的切换显示&#x2F;隐藏</p><pre><code class="hljs">  const div = $(&quot;#test-show-hide&quot;);    div.hide(3000); // 在3秒钟内逐渐消失    div.show(&quot;slow&quot;); // 在600ms内逐渐显示</code></pre></li></ul><h2 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h2><p>jQuery动画本质 : 在指定时间内不断改变元素样式值来实现的</p><ul><li><code>animate()</code>: 自定义动画效果的动画</li><li><code>stop()</code>: 停止动画</li></ul><p><code>animate()</code>，它可以实现任意动画效果，我们需要传入的参数就是 DOM 元素<strong>最终的 CSS 状态</strong>和<strong>时间</strong>，jQuery 在时间段内不断调整 CSS 直到达到我们设定的值:</p><pre><code class="hljs">    const $div = $(&quot;#test-animate&quot;);    //3s内透明度变为0.25，宽高变为256px    $div.animate(      &#123;        opacity: 0.25,        width: &quot;256px&quot;,        height: 256, //此处也可不写单位，传入数值256，单位默认为px       &#125;,3000)</code></pre><p>通过链式调用能做到动画实现的先后顺序</p><pre><code class="hljs">    const $div = $(&quot;#test-animate&quot;)    //宽度先变为200px，高度再变为200px    $div.animate(&#123;        width: 200      &#125;, 1000)      .animate(&#123;        height: 200      &#125;, 1000)</code></pre><p><code>animate()</code> 还可以再传入一个回调函数，当动画结束时，该函数将被调用</p><pre><code class="hljs">    const $div = $(&quot;#test-animate&quot;);        $div.animate(      &#123;        opacity: 0.25,        width: 256,        height: 256      &#125;,      3000,      function () &#123;        console.log(&quot;动画已结束&quot;)        // 恢复至初始状态:        $(this).css(&quot;opacity&quot;, &quot;1.0&quot;)            .css(&quot;width&quot;, &quot;128px&quot;)            .css(&quot;height&quot;, &quot;128px&quot;)      &#125;)</code></pre>]]></content>
    
    
    <categories>
      
      <category>jQuery</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery事件</title>
    <link href="/2021/10/21/jQuery/jQuery%E4%BA%8B%E4%BB%B6/"/>
    <url>/2021/10/21/jQuery/jQuery%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="jQuery事件"><a href="#jQuery事件" class="headerlink" title="jQuery事件"></a>jQuery事件</h1><p>因为 JavaScript 在浏览器中以单线程模式运行，页面加载后，一旦页面上所有的 JavaScript 代码被执行完后，就只能依赖触发事件来执行 JavaScript 代码。<br>浏览器在接收到用户的鼠标或键盘输入后，会自动在对应的 DOM 节点上触发相应的事件。<br>如果该节点已经绑定了对应的 JavaScript 处理函数，该函数就会自动调用。</p><span id="more"></span><h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><p>事件绑定通过<code>eventName(function()&#123;&#125;)</code> 与 <code>on(eventName, funcion()&#123;&#125;)</code> 两种方法实现</p><ul><li><p><code>eventName(function()&#123;&#125;)</code> 绑定对应事件名的监听,例如：<code>$(&#39;#div&#39;).click(function()&#123;&#125;)</code></p></li><li><p><code>on(eventName, funcion()&#123;&#125;)</code> 通用的绑定事件监听, 例如：<code>$(&#39;#div&#39;).on(&#39;click&#39;, function()&#123;&#125;)</code></p><pre><code class="hljs">/* HTML: * * &lt;a id=&quot;test-link&quot; href=&quot;#0&quot;&gt;点我试试&lt;/a&gt; * */// 获取超链接的jQuery对象:const $a = $(&quot;#test-link&quot;)$a.on(&quot;click&quot;, function () &#123;  alert(&quot;Hello!&quot;)&#125;)$a.click(function () &#123;  alert(&quot;Hello!&quot;)&#125;)</code></pre></li></ul><h2 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h2><ul><li><p><code>click()</code>: 鼠标单击时触发； </p></li><li><p><code>dblclick</code>(): 鼠标双击时触发； </p></li><li><p><code>mouseenter()</code>: 鼠标进入时触发； </p></li><li><p><code>mouseleave()</code>: 鼠标移出时触发； </p></li><li><p><code>mousemove()</code>: 鼠标在 DOM 内部移动时触发； </p></li><li><p><code>hover()</code>: 鼠标进入和退出时触发两个函数，相当于 <code>mouseenter</code> 加上 <code>mouseleave</code></p></li><li><p>注如何区别<code>mouseover()</code>与<code>mouseenter()</code>?</p><ul><li><code>mouseover()</code>: 在移入子元素时也会触发, 对应mouseout</li><li><code>mouseenter()</code>: 只在移入当前元素时才触发, 对应mouseleave</li><li><code>hover()</code>使用的就是<code>mouseenter()</code>和<code>mouseleave()</code>，故在使用<code>hover()</code>鼠标移入移出子元素不会触发事件</li></ul></li></ul><h2 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h2><p>键盘事件仅作用在当前焦点的 DOM 上，通常是 <code>&lt;input&gt;</code> 和 <code>&lt;textarea&gt;</code></p><ul><li><code>keydown()</code>: 键盘按下时触发</li><li><code>keyup()</code>: 键盘松开时触发</li><li><code>keypress()</code>: 按一次键后触发</li></ul><h2 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h2><ul><li><p><code>focus()</code>: 当 DOM 获得焦点时触发</p></li><li><p><code>blur()</code>: 当 DOM 失去焦点时触发</p></li><li><p><code>change()</code>: 当 <code>&lt;input&gt;</code>、<code>&lt;select&gt;</code> 或 <code>&lt;textarea&gt;</code> 的内容改变时触发</p></li><li><p><code>submit()</code>: 当<form>提交时触发</p></li><li><p><code>ready()</code>: 当页面被载入并且 DOM 树完成初始化后触发</p></li><li><p>注</p><ul><li><code>reday()</code>事件ready 仅作用于 document 对象。由于 ready 事件在 DOM 完成初始化后触发，且只触发一次，所以非常适合用来写其他的初始化代码</li><li><code>$(document).ready() </code>的简写方式为<code>$(function()&#123;&#125;)</code></li></ul></li></ul><h2 id="事件参数"><a href="#事件参数" class="headerlink" title="事件参数"></a>事件参数</h2><p>有些事件，如 <code>mousemove()</code> 和 <code>keypress()</code>，我们需要获取鼠标位置和按键的值。所有事件都会传入 <code>Event</code> 对象作为参数，可以从 <code>Event</code> 对象上获取到更多的信息</p><ul><li>事件的坐标<ul><li><code>event.clientX</code>, <code>event.clientY</code>  相对于视口的左上角</li><li><code>event.pageX</code>, <code>event.pageY</code>  相对于页面的左上角</li><li><code>event.offsetX</code>, <code>event.offsetY</code> 相对于事件元素左上角</li></ul></li><li>事件相关处理<ul><li><p>停止事件冒泡 : <code>event.stopPropagation()</code></p></li><li><p>阻止事件默认行为 : <code>event.preventDefault()</code></p><pre><code class="hljs">//获取当前鼠标相对于页面的位置$(function () &#123;  $(&quot;#testMouseMoveDiv&quot;).mousemove(function (event) &#123;    $(&quot;#testMouseMoveSpan&quot;).text(&quot;pageX = &quot; +         event.pageX + &quot;, pageY = &quot; + event.pageY)  &#125;)&#125;)</code></pre></li></ul></li></ul><h2 id="取消绑定事件"><a href="#取消绑定事件" class="headerlink" title="取消绑定事件"></a>取消绑定事件</h2><ul><li><code>off(eventName)</code> 取消事件的绑定，</li><li>注 <ul><li><p><code>off(&#39;click&#39;, function () &#123;...&#125;)</code> 不能取消第一个绑定的匿名函数，即使它们写法相同也不是同一个对象</p></li><li><p><code>$(&quot;*&quot;).off()</code>能够清除所有事件</p><p>  &#x2F;&#x2F;点击btn1解除.inner上的所有事件监听<br>  $(‘#btn1’).click(function () {<br>  $(‘.inner’).off()<br>  })</p><p>  &#x2F;&#x2F;点击btn2解除.inner上的mouseenter事件<br>  $(‘#btn2’).click(function () {<br>  $(‘.inner’).off(‘mouseenter’)<br>  })</p></li></ul></li></ul><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><ul><li><p>事件委托是指将多个子元素(如li)的事件监听委托给父辈元素(ul)处理，通俗来说 委托方子元素（li）相当于业主，被委托方父元素（ul）相当于中介</p><ul><li>监听回调是加在了父辈元素上</li><li>当操作任何一个子元素(li)时, 事件会冒泡到父辈元素(ul)</li><li>父辈元素不会直接处理事件, 而是根据<code>event.target</code>得到发生事件的子元素(li), 通过这个子元素调用事件回调函数</li></ul></li><li><p>使用事件委托的好处</p><ul><li>添加新的子元素, 自动有事件响应处理</li><li>能减少事件监听的数量</li></ul></li></ul><blockquote><p>在jQuery 3.0中以弃用，使用 <code>on()</code> 与<code>off()</code>代替</p></blockquote><ul><li>设置事件委托: <code>$(parentSelector).delegate(childrenSelector, eventName, callback)</code></li><li>移除事件委托: <code>$(parentSelector).undelegate(eventName)</code><br>  &#x2F;&#x2F; 设置事件委托<br>  $(‘ul’).delegate(‘li’, ‘click’, function () {<br>      &#x2F;&#x2F; console.log(this)<br>      &#x2F;&#x2F;this是当前触发click事件的对象（li）<br>      this.style.background &#x3D; ‘red’<br>  })<br>  &#x2F;&#x2F; 向ul中新增li<br>  $(‘#btn1’).click(function () {<br>      $(‘ul’).append(‘<li>新增的li….</li>‘)<br>  })<br>  $(‘#btn2’).click(function () {<br>      &#x2F;&#x2F; 移除事件委托<br>      $(‘ul’).undelegate(‘click’)<br>  })</li></ul>]]></content>
    
    
    <categories>
      
      <category>jQuery</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery修改DOM结构</title>
    <link href="/2021/10/20/jQuery/jQuery%E4%BF%AE%E6%94%B9DOM%E7%BB%93%E6%9E%84/"/>
    <url>/2021/10/20/jQuery/jQuery%E4%BF%AE%E6%94%B9DOM%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="修改DOM结构"><a href="#修改DOM结构" class="headerlink" title="修改DOM结构"></a>修改DOM结构</h1><p>直接使用浏览器提供的 API 对 DOM 结构进行修改，不但代码复杂，而且要针对浏览器写不同的代码。 有了 jQuery，我们就专注于操作 jQuery 对象本身，底层的 DOM 操作由 jQuery 完成就可以了，这样一来，修改 DOM 也大大简化了</p><span id="more"></span><h2 id="添加DOM节点"><a href="#添加DOM节点" class="headerlink" title="添加DOM节点"></a>添加DOM节点</h2><p>要添加新的 DOM 节点，除了通过 jQuery 的 html() 这种暴力方法外，还可以用 append() 方法，例如在<code>&lt;ul&gt;</code>内部插入内容</p><pre><code class="hljs">    &lt;div id=&quot;test-div&quot;&gt;      &lt;ul&gt;        &lt;li&gt;&lt;span&gt;JavaScript&lt;/span&gt;&lt;/li&gt;        &lt;li&gt;&lt;span&gt;Python&lt;/span&gt;&lt;/li&gt;        &lt;li&gt;&lt;span&gt;Swift&lt;/span&gt;&lt;/li&gt;      &lt;/ul&gt;    &lt;/div&gt;</code></pre><p>首先要拿到<code>&lt;ul&gt;</code>节点：</p><pre><code class="hljs">    const $ul = $(&quot;#test-div&gt;ul&quot;)</code></pre><p>调用 <code>append()</code> 传入 HTML 片段:</p><pre><code class="hljs">    $ul.append(&quot;&lt;li&gt;&lt;span&gt;jQuery&lt;/span&gt;&lt;/li&gt;&quot;)</code></pre><p>也可以使用<code>appendTo()</code></p><pre><code class="hljs">    $(&quot;&lt;li&gt;&lt;span&gt;jQuery&lt;/span&gt;&lt;/li&gt;&quot;).appendTo($ul)</code></pre><p><code>append()</code> 把 DOM 添加到最后，而<code>prepend()</code> 则把 DOM 添加到最前，<code>prependTo()</code>同理</p><p>如果要把新节点插入到指定位置，例如，JavaScript 和 Python 之间，那么，可以先定位到 JavaScript，然后用 after() 方法:</p><pre><code class="hljs">    const js = $(&quot;#test-div&gt;ul&gt;li:first-child&quot;);    js.after(&quot;&lt;li&gt;&lt;span&gt;Lua&lt;/span&gt;&lt;/li&gt;&quot;);</code></pre><p> 也就是说，同级节点可以用 after() 或者 before() 方法。</p><h2 id="删除DOM节点"><a href="#删除DOM节点" class="headerlink" title="删除DOM节点"></a>删除DOM节点</h2><ul><li><code>empty()</code>删除所有匹配元素的子元素，不会删除自身节点</li><li><code>remove()</code>删除所有匹配的元素，包括自己</li></ul><p>例如：<code>empty()</code>方法</p><pre><code class="hljs">    var $li = $(&quot;#test-div&gt;ul li&quot;)    $li.empty()     //删除后    &lt;div id=&quot;test-div&quot;&gt;      &lt;ul&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;      &lt;/ul&gt;    &lt;/div&gt;</code></pre><p>而<code>remove()</code>方法</p><pre><code class="hljs">    $li.remove()    //删除后    &lt;div id=&quot;test-div&quot;&gt;      &lt;ul&gt;      &lt;/ul&gt;    &lt;/div&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>jQuery</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery操作DOM元素</title>
    <link href="/2021/10/20/jQuery/jQuery%E6%93%8D%E4%BD%9CDOM/"/>
    <url>/2021/10/20/jQuery/jQuery%E6%93%8D%E4%BD%9CDOM/</url>
    
    <content type="html"><![CDATA[<h1 id="jQuery操作DOM"><a href="#jQuery操作DOM" class="headerlink" title="jQuery操作DOM"></a>jQuery操作DOM</h1><p>jQuery对象提供了许多修改DOM元素的功能</p><span id="more"></span><h2 id="修改Text和HTML"><a href="#修改Text和HTML" class="headerlink" title="修改Text和HTML"></a>修改Text和HTML</h2><p>jQuery 对象的 text() 和 html() 方法分别获取节点的文本和原始 HTML 文本，例如，如下的 HTML 结构: </p><pre><code class="hljs">    &lt;!-- HTML结构 --&gt;    &lt;ul id=&quot;test-ul&quot;&gt;      &lt;li class=&quot;js&quot;&gt;111&lt;/li&gt;      &lt;li name=&quot;book&quot;&gt;&lt;span&gt;222&lt;/span&gt;&lt;/li&gt;    &lt;/ul&gt;</code></pre><p>分别获取文本和 HTML: </p><pre><code class="hljs">    console.log($(&quot;#test-ul li[name=book]&quot;).text()); // 222    console.log($(&quot;#test-ul li[name=book]&quot;).html()); // &lt;span&gt;222&lt;/span&gt;</code></pre><p>如jQuery 的 API 实现了读写合一的功能，也就是: 无参数调用 text() 是获取文本，传入参数就变成设置文本，HTML 也是类似操作<br>例如：</p><pre><code class="hljs">    $(&quot;#test-ul li[name=book]&quot;).text(&quot;aaa&quot;) </code></pre><h2 id="修改CSS"><a href="#修改CSS" class="headerlink" title="修改CSS"></a>修改CSS</h2><ul><li>jQuery 对象有“批量操作”的特点，对获取的DOM元素集进行操作</li></ul><p>例如下面的结构</p><pre><code class="hljs">    &lt;!-- HTML结构 --&gt;    &lt;ul id=&quot;test-css&quot;&gt;      &lt;li class=&quot;lang dy&quot;&gt;&lt;span&gt;JavaScript&lt;/span&gt;&lt;/li&gt;      &lt;li class=&quot;lang&quot;&gt;&lt;span&gt;Java&lt;/span&gt;&lt;/li&gt;      &lt;li class=&quot;lang dy&quot;&gt;&lt;span&gt;Python&lt;/span&gt;&lt;/li&gt;      &lt;li class=&quot;lang&quot;&gt;&lt;span&gt;Swift&lt;/span&gt;&lt;/li&gt;      &lt;li class=&quot;lang dy&quot;&gt;&lt;span&gt;Scheme&lt;/span&gt;&lt;/li&gt;    &lt;/ul&gt;</code></pre><p>可以用调用 jQuery 对象的 <code>css(&#39;name&#39;, &#39;value&#39;)</code> 方法，更改css样式。而获取css样式则是<code>css(&#39;name&#39;)</code></p><pre><code class="hljs">//更改li的class为dy的span元素    $(&quot;#test-css li.dy&gt;span&quot;)      .css(&quot;background-color&quot;, &quot;#bfa&quot;)      .css(&quot;color&quot;, &quot;red&quot;)</code></pre><p>同时jQuery提供了修改css类的方法</p><pre><code class="hljs">    const div = $(&quot;#test-div&quot;);    div.hasClass(&quot;highlight&quot;); // false， class是否包含highlight    div.addClass(&quot;highlight&quot;); // 添加highlight这个class    div.removeClass(&quot;highlight&quot;); // 删除highlight这个class</code></pre><h2 id="显示和隐藏-DOM"><a href="#显示和隐藏-DOM" class="headerlink" title="显示和隐藏 DOM"></a>显示和隐藏 DOM</h2><ul><li><p>jQuery 直接提供show()和hide()方法</p><pre><code class="hljs">  const a = $(&quot;a&quot;);  a.hide(); // 隐藏  a.show(); // 显示</code></pre></li></ul><p>注意，隐藏 DOM 节点并未改变 DOM 树的结构，它只影响 DOM 节点的显示。这和删除 DOM 节点是不同的。</p><h2 id="获取-DOM-信息"><a href="#获取-DOM-信息" class="headerlink" title="获取 DOM 信息"></a>获取 DOM 信息</h2><ul><li><p>利用 jQuery 对象的若干方法，我们直接可以获取 DOM 的高宽等信息，而无需针对不同浏览器编写特定代码:</p><pre><code class="hljs">  // 浏览器可视窗口大小:  $(window).width(); // 800  $(window).height(); // 600    // HTML文档大小:  $(document).width(); // 800  $(document).height(); // 3500    // 某个div的大小:  const div = $(&quot;#test-div&quot;);  div.width(); // 600  div.height(); // 300  div.width(400); // 设置CSS属性 width: 400px，是否生效要看CSS是否有效  div.height(&quot;200px&quot;); // 设置CSS属性 height: 200px，是否生效要看CSS是否有效</code></pre></li><li><p><code>attr()</code> 和 <code>removeAttr()</code> 方法用于操作 DOM 节点的属性:</p><pre><code class="hljs">  // &lt;div id=&quot;test-div&quot; name=&quot;Test&quot;&gt;...&lt;/div&gt;  const div = $(&quot;#test-div&quot;);  div.attr(&quot;data&quot;); // undefined, 属性不存在  div.attr(&quot;name&quot;); // &#39;Test&#39;  div.attr(&quot;name&quot;, &quot;Hello&quot;); // div的name属性变为&#39;Hello&#39;  div.removeAttr(&quot;name&quot;); // 删除name属性  div.attr(&quot;name&quot;); // undefined</code></pre></li><li><p>prop() 方法和 attr() 类似，但是 HTML5 规定有一种属性在 DOM 节点中可以没有值，只有出现与不出现两种，例如: </p><pre><code class="hljs">  &lt;input id=&quot;test-radio&quot; type=&quot;radio&quot; name=&quot;test&quot; checked value=&quot;1&quot; /&gt;</code></pre></li></ul><p> 等价于:<br>        <input id="test-radio" type="radio" name="test" checked="checked" value="1" /><br>     <code>attr()</code> 和 <code>prop()</code> 对于属性 checked 处理有所不同: </p><pre><code class="hljs">    const radio = $(&quot;#test-radio&quot;);    radio.attr(&quot;checked&quot;); // &#39;checked&#39;    radio.prop(&quot;checked&quot;); // true</code></pre><p> 一般来说<br>    - attr(): 操作属性值为非布尔值的属性<br>    - prop(): 专门操作属性值为布尔值的属性</p>]]></content>
    
    
    <categories>
      
      <category>jQuery</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery选择器</title>
    <link href="/2021/10/19/jQuery/jQuery%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <url>/2021/10/19/jQuery/jQuery%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h1><ul><li>jQuery 选择器允许对 HTML 元素组或单个元素进行操作。</li><li>jQuery 选择器基于元素的 id、类、类型、属性、属性值等”查找”（或选择）HTML 元素。 它基于已经存在的 CSS 选择器，除此之外，它还有一些自定义的选择器。</li><li>jQuery 中所有选择器都以美元符号开头：$()。</li><li>jQuery选择器不是同时执行，而是顺序执行<span id="more"></span></li></ul><h2 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h2><pre><code class="hljs">$(&quot;#test&quot;)             　　　　   选择id值为test的元素，id值是唯一的所以返回单个元素。$(&quot;div&quot;)               　　　　   选择所有的div标签元素，返回div元素数组 $(&quot;.myclass&quot;)          　　　　   选择使用myclass类的css的所有元素 $(&quot;*&quot;)                 　　　　   选取所有元素。$(&quot;#test,div,.myclass&quot;)  选取多个元素。(并集)</code></pre><h2 id="层次选择器"><a href="#层次选择器" class="headerlink" title="层次选择器"></a>层次选择器</h2><pre><code class="hljs">    $(&quot;div span&quot;) 选取 &lt; div &gt; 里的所有 &lt; span &gt; 元素    $(&quot;div &gt;span&quot;) 选取 &lt; div &gt; 元素下元素名是 &lt; span &gt; 的子元素    $(&quot;#one +div&quot;) 选取id为one的元素的下一个 &lt; div &gt; 同辈元素 等同于$(&quot;#one&quot;).next(&quot;div&quot;)    $(&quot;#one~div&quot;) 选取id为one的元素的元素后面的所有 &lt; div &gt; 同辈元素 等同于$(&quot;#one&quot;).nextAll(&quot;div&quot;)    $(&quot;#one&quot;).siblings(&quot;div&quot;) 获取id为one的元素的所有 &lt; div &gt; 同辈元素（ 不管前后）    $(&quot;#one&quot;).prev(&quot;div&quot;) 获取id为one的元素的前面紧邻的同辈 &lt; div &gt; 元素    所以 获取元素范围大小顺序依次为：    $(&quot;#one&quot;).siblings(&quot;div&quot;) &gt; $(&quot;#one~div&quot;) &gt; $(&quot;#one +div&quot;) 或是    $(&quot;#one&quot;).siblings(&quot;div&quot;) &gt; $(&quot;#one&quot;).nextAll(&quot;div&quot;) &gt; $(&quot;#one&quot;).next(&quot;div&quot;)</code></pre><h2 id="基本过滤选择器"><a href="#基本过滤选择器" class="headerlink" title="基本过滤选择器"></a>基本过滤选择器</h2><pre><code class="hljs">    $(&quot;div:first&quot;) 选取所有 &lt; div &gt; 元素中第1个 &lt; div &gt; 元素    $(&quot;div:last&quot;) 选取所有 &lt; div &gt; 元素中最后一个 &lt; div &gt; 元素    $(&quot;:not(.myClass)&quot;) 选取class不是myClass的元素    $(&quot;:even&quot;) 选取索引是偶数的元素(索引从0开始)    $(&quot;:odd&quot;) 选取索引是奇数的元素(索引从0开始)    $(&quot;:eq(index)&quot;) 选取索引等于index的元素    $(&quot;:gt(index)&quot;) 选取索引大于index的元素    $(&quot;:lt(index)&quot;) 选取索引小于index的元素    $(&quot;:header&quot;) 过滤掉所有标题元素， 例如： h1、 h2、 h3等    $(&quot;:animated&quot;) 选取正在执行动画的元素    $(&quot;:focus&quot;) 选取当前获取焦点的元素</code></pre><ul><li>例子：选取一堆div元素中的<strong>第二个和第三个div元素</strong>， <code>$(&quot;div:gt(0):lt(2)&quot;)</code> ，因为jQuery选择器不是同时执行，而是顺序执行，<code>div:gt(0)</code>后此时选中的是整个div中第2个元素，而 <code>:lt(2)</code> 是基于<code>div:gt(0)</code>执行后的DOM元素集，当然也能写成 <code>$(&quot;div:lt(3):gt(0)&quot;)</code></li></ul><h2 id="内容过滤选择器"><a href="#内容过滤选择器" class="headerlink" title="内容过滤选择器"></a>内容过滤选择器</h2><pre><code class="hljs">    $(&quot;div:contains(&#39;Name&#39;)&quot;) 选取所有 &lt; div &gt; 中含有 &#39;Name&#39;    文本的元素    $(&quot;div:empty&quot;) 选取不包含子元素（ 包括文本元素） 的 &lt; div &gt; 空元素    $(&quot;div:has(p)&quot;) 选取所有含有 &lt; p &gt; 元素的 &lt; div &gt; 元素    $(&quot;div:parent&quot;) 选取拥有子元素的（ 包括文本元素） &lt; div &gt; 元素</code></pre><h2 id="可见性过滤选择器"><a href="#可见性过滤选择器" class="headerlink" title="可见性过滤选择器"></a>可见性过滤选择器</h2><pre><code class="hljs">    $(&quot;div:hidden&quot;) 选取所有不可见的 &lt; div &gt; 元素    $(&quot;div:visible&quot;) 选取所有可见的 &lt; div &gt; 元素</code></pre><h2 id="属性过滤选择器"><a href="#属性过滤选择器" class="headerlink" title="属性过滤选择器"></a>属性过滤选择器</h2><pre><code class="hljs">    $(&quot;div[id]&quot;) 选取所有拥有属性id的元素    $(&quot;input[name=&#39;test&#39;]&quot;) 选取所有的name属性等于 &#39;test&#39;的 &lt; input &gt; 元素    $(&quot;input[name!=&#39;test&#39;]&quot;) 选取所有的name属性不等于 &#39;test&#39;的 &lt; input &gt; 元素    $(&quot;input[name^=&#39;news&#39;]&quot;) 选取所有的name属性以 &#39;news&#39;开头的 &lt; input &gt; 元素    $(&quot;input[name$=&#39;news&#39;]&quot;) 选取所有的name属性以 &#39;news&#39;结尾的 &lt; input &gt; 元素    $(&quot;input[name*=&#39;news&#39;]&quot;) 选取所有的name属性包含 &#39;news&#39;的 &lt; input &gt; 元素    $(&quot;div[title|=&#39;en&#39;]&quot;) 选取属性title等于 &#39;en&#39;或以 &#39;en&#39;为前缀(该字符串后跟一个连字符 &#39;-&#39;) 的 &lt; div &gt; 元素        $(&quot;div[title~=&#39;en&#39;]&quot;) 选取属性title用空格分隔的值中包含字符en的 &lt; div &gt; 元素    $(&quot;div[id][title$=&#39;test&#39;]&quot;) 选取拥有属性id, 并且属性title以 &#39;test&#39;结束的 &lt; div &gt; 元素</code></pre><h2 id="子元素过滤选择器"><a href="#子元素过滤选择器" class="headerlink" title="子元素过滤选择器"></a>子元素过滤选择器</h2><pre><code class="hljs">    $(&quot;div .one:nth-child(2)&quot;) 选取class为 &#39;one&#39; 的 &lt; div &gt; 父元素下的第2个子元素    $(&quot;div span:first-child&quot;) 选取每个 &lt; div &gt; 中的第1个 &lt; span &gt; 元素    $(&quot;div span:last-child&quot;) 选取每个 &lt; div &gt; 中的最后一个 &lt; span &gt; 元素    $(&quot;div button:only-child&quot;) 在 &lt; div &gt; 中选取是唯一子元素的 &lt; button &gt; 元素</code></pre><h2 id="表单对象属性过滤选择器"><a href="#表单对象属性过滤选择器" class="headerlink" title="表单对象属性过滤选择器"></a>表单对象属性过滤选择器</h2><pre><code class="hljs">    $(&quot;#form1 :enabled&quot;) 选取id为 &#39;form1&#39;的表单内所有可用元素    $(&quot;#form2 :disabled&quot;) 选取id为 &#39;form2&#39;的表单内所有不可用元素    $(&quot;input :checked&quot;) 选取所有被选中的 &lt; input &gt; 元素        $(&quot;select option:selected&quot;) 选取所有的select 的子元素中被选中的元素</code></pre><h2 id="表单选择器"><a href="#表单选择器" class="headerlink" title="表单选择器"></a>表单选择器</h2><pre><code class="hljs">    $(&quot;:input&quot;)  选取所有 &lt; input &gt; , &lt; textarea &gt; , &lt; select &gt; 和 &lt; button &gt; 元素    $(&quot;:text&quot;)  选取所有的单行文本框    $(&quot;:password&quot;)  选取所有的密码框    $(&quot;:radio&quot;)  选取所有单的选框    $(&quot;:checkbox&quot;)  选取所有的多选框    $(&quot;:submit&quot;)  选取所有的提交按钮    $(&quot;:image&quot;)  选取所有的图像按钮    $(&quot;:reset&quot;)  选取所有的重置按钮    $(&quot;:button&quot;)  选取所有的按钮    $(&quot;:file&quot;)  选取所有的上传域    $(&quot;:hidden&quot;)  选取所有不可见元素</code></pre>]]></content>
    
    
    <categories>
      
      <category>jQuery</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery介绍</title>
    <link href="/2021/10/19/jQuery/jQuery%E7%AE%80%E4%BB%8B/"/>
    <url>/2021/10/19/jQuery/jQuery%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="jQuery介绍"><a href="#jQuery介绍" class="headerlink" title="jQuery介绍"></a>jQuery介绍</h1><p>jQuery 是 JavaScript 世界中使用最广泛的一个库。鼎盛时期全世界大约有 80~90%的网站直接或间接地使用了 jQuery。</p><span id="more"></span><ul><li>jQuery 能帮我们干这些事情: <ul><li>消除浏览器差异: 您不需要自己写冗长的代码来针对不同的浏览器来绑定事件，编写 AJAX 等代码； </li><li>简洁的操作 DOM 的方法: 写 $(‘#test’) 肯定比 document.getElementById(‘test’) 来得简洁； 轻松实现动画、修改 CSS 等各种操作。 </li><li>jQuery 的理念 “Write Less, Do More“，让您写更少的代码，完成更多的工作！</li></ul></li></ul><h2 id="jQuery版本"><a href="#jQuery版本" class="headerlink" title="jQuery版本"></a>jQuery版本</h2><ul><li>jQuery 的 1.x 版本 兼容 ie678，2.x 为了精简代码体积移除了 ie678 的兼容。3.x 只兼容最新的一批浏览器</li><li>从jQuery官网 <a href="https://jquery.com/">https://jquery.com/</a> 下载最新版 3.x 即可</li></ul><h2 id="jQuery的本质"><a href="#jQuery的本质" class="headerlink" title="jQuery的本质"></a>jQuery的本质</h2><ul><li>jQuery实际上是封装好的js文件，只向外暴露了 $ &#x2F; jQuery</li><li>整个文件相当于下段代码<br>  (function (window) {<br>      var jQuery &#x3D; function () {<br>          return new xxx()<br>      }<br><br>      window.$ &#x3D; window.jQuery &#x3D; jQuery<br>  })(window)</li></ul><h2 id="使用jQuery"><a href="#使用jQuery" class="headerlink" title="使用jQuery"></a>使用jQuery</h2><ul><li>jQuery实际上是js文件，因此使用 jQuery 是需要先从外部引入js文件</li></ul><h3 id="本地引入"><a href="#本地引入" class="headerlink" title="本地引入"></a>本地引入</h3><ul><li>将jQuery文件放在本地文件内<br>  <script type="text/javascript" src="js/jquery-1.12.3.js"></script></li></ul><h3 id="远程引入"><a href="#远程引入" class="headerlink" title="远程引入"></a>远程引入</h3><ul><li>从外部CDN库中引入，例如免费开源网站 <a href="https://www.bootcdn.cn/">https://www.bootcdn.cn/</a><br>  <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js"></script></li></ul><h2 id="jQuery核心函数"><a href="#jQuery核心函数" class="headerlink" title="jQuery核心函数"></a>jQuery核心函数</h2><ul><li><p>jQuery函数在代码中写作 $ 或 jQuery</p></li><li><p>jQuery库向外直接暴露的就是 $ &#x2F; jQuery</p></li><li><p>引入jQuery库后, 直接使用$即可</p><ul><li>当函数用: $(xxx)</li><li>当对象用: $.xxx()</li></ul><p>  console.log(typeof $) &#x2F;&#x2F; function<br>  console.log(jQuery &#x3D;&#x3D;&#x3D; $) &#x2F;&#x2F; true</p></li></ul><h3 id="作为一般函数调用"><a href="#作为一般函数调用" class="headerlink" title="作为一般函数调用"></a>作为一般函数调用</h3><ul><li><p>作为一般函数调用: $(param)</p><ol><li>参数为函数 : 当DOM加载完成后，执行此回调函数，相当于<code>window.onload = function()&#123;&#125;</code></li><li>参数为选择器字符串: 查找所有匹配的标签, 并将它们封装成jQuery对象</li><li>参数为DOM对象: 将dom对象封装成jQuery对象</li><li>参数为html标签字符串 (用得少): 创建标签对象并封装成jQuery对象</li></ol><p>  &#x2F;&#x2F; html部分<br>      <div><br>          <button id="btn">测试</button><br>          <br /><br>      </div><br>  &#x2F;&#x2F;js部分<br>      $(function () { &#x2F;&#x2F; 绑定文档加载完成的监听</p><pre><code class="hljs">      // 1.2). 参数为选择器字符串: 查找所有匹配的标签, 并将它们封装成jQuery对象      $(&#39;#btn&#39;).click(function () &#123; // 绑定点击事件监听          // 1.3). 参数为DOM对象: 将dom对象封装成jQuery对象          alert($(this).html()) // this是什么? 发生事件的dom元素(&lt;button&gt;)          // 1.4). 参数为html标签字符串 (用得少): 创建标签对象并封装成jQuery对象          $(&#39;&lt;input type=&quot;text&quot; name=&quot;msg&quot;/&gt;&lt;br/&gt;&#39;).appendTo(&#39;div&#39;)      &#125;)  &#125;)</code></pre><p>  在上面代码中，需求是 <strong>点击按钮: 显示按钮的文本, 显示一个新的输入框</strong></p></li></ul><h3 id="作为对象使用"><a href="#作为对象使用" class="headerlink" title="作为对象使用"></a>作为对象使用</h3><ul><li>作为对象调用：$.xxx()，例如<ol><li><p>$.each() : 隐式遍历数组</p></li><li><p>$.trim() : 去除两端的空格</p><p> &#x2F;&#x2F;需求： 遍历输出数组中所有元素值<br> var arr &#x3D; [2, 4, 7]<br> &#x2F;&#x2F; 1). $.each() : 隐式遍历数组</p><p> $.each(arr, function (index, item) {<br> console.log(index, item)<br> })</p></li></ol></li></ul><h2 id="jQuery核心对象"><a href="#jQuery核心对象" class="headerlink" title="jQuery核心对象"></a>jQuery核心对象</h2><ul><li>jQuery对象是一个<strong>包含所有匹配的任意多个dom元素的伪数组对象</strong></li><li>如何得到jQuery对象: 执行jQuery函数返回的就是jQuery对象</li><li>使用jQuery对象: $obj.xxx()</li><li>基本行为：<ul><li><p>length: 得到DOM元素的个数</p></li><li></li><li><p>each(function(index, domEle){}): 遍历所有的DOM元素</p></li><li><p>index(): 得到当前DOM元素在所有兄弟元素中的下标</p><pre><code class="hljs">console.log($() instanceof Object) // true</code></pre></li></ul></li></ul><ul><li>例如下段代码<br>  &#x2F;&#x2F;html部分<br>      <button>测试一</button><br>      <button>测试二</button><br>      <button id="btn3">测试三</button><br>      <button>测试四</button><br>  &#x2F;&#x2F;js部分<br>      $(function () {<br>          var $buttons &#x3D; $(“button”)<br>          console.log($buttons.length) &#x2F;&#x2F;4<br>          console.log($buttons[2].innerHTML) &#x2F;&#x2F;测试三<br>      })<ul><li>通过调用 $(“button”) 函数 return 一个 jQuery对象，这个对象就是 <code>&lt;button&gt;</code>的DOM元素的伪数组对象</li><li>jQuery对象的命名一般以 $ 开头，如 $xxx</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>jQuery</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程机制与事件机制</title>
    <link href="/2021/10/17/javaScript/%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/10/17/javaScript/%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul><li>进程：程序的一次执行, 它占有一片独有的内存空间</li><li>线程： CPU的基本调度单位, 是程序执行的一个完整流程<span id="more"></span></li><li>进程与线程<ul><li>一个进程中一般至少有一个运行的线程: 主线程</li><li>一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的</li><li>一个进程内的数据可以供其中的多个线程直接共享</li><li>多个进程之间的数据是不能直接共享的</li></ul></li></ul><h3 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h3><ul><li><p>浏览器内核是指支持浏览器运行的最核心程序<br>  不同浏览器的内核可能不同<br>  Chrome, Safari: webkit<br>  firefox: Gecko<br>  IE: Trident<br>  360,搜狗等国内浏览器: Trident + webkit</p></li><li><p>内核由很多模块组成</p><ul><li>html,css文档解析模块 : 负责页面文本的解析</li><li>dom&#x2F;css模块 : 负责dom&#x2F;css在内存中的相关处理</li><li>布局和渲染模块 : 负责页面的布局和效果的绘制</li><li>布局和渲染模块 : 负责页面的布局和效果的绘制</li><li>定时器模块 : 负责定时器的管理</li><li>网络请求模块 : 负责服务器请求(常规&#x2F;Ajax)</li><li>事件响应模块 : 负责事件的管理</li></ul></li></ul><h3 id="js是单线程的"><a href="#js是单线程的" class="headerlink" title="js是单线程的"></a>js是单线程的</h3><ul><li><p>JS 是单线程的语言，所谓“单线程”就是一根筋，对于拿到的程序，一行一行的执行，直到上面的执行为完成，只能做这一件事</p></li><li><p>H5提出了实现多线程的方案：Web workers（很少用）</p></li><li><p>只能在主线程中更新界面，分线程中不能</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;1&quot;</span>)<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>&#125;, <span class="hljs-number">1000</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>  输出：1 3 2</p><p>  这个任务是串行的，不能发生阻塞，使用异步解决这种问题</p><p>  过程：</p><ol><li>执行第一行，打印1</li><li>执行setTimeout 后，传入setTimeout 的函数会被暂存起来，不会立即执行（单线程的特点，不能同时干两件事）</li><li>执行最后一行，打印3</li><li>待所有程序执行完，处于空闲状态时，会立马看有没有暂存起来的要执行</li><li>发现暂存起来的 setTimeout 中的函数无需等待时间，立即起来执行</li></ol><p>  而多个异步代码将会进入回调队列，排队执行</p><p>  如果主线程中程序执行需要200ms，定时器设置定时100ms，最终在整个程序中定时器会在200ms后执行，而不是300ms。因为在100ms时定时器已经进入回调队列，而主线程程序执行完毕时，回调队列中第一个函数（例子中的定时器）会直接进入执行栈中执行。</p></li></ul><h2 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h2><ul><li>所有代码分类<ul><li><strong>初始化执行代码(同步代码)</strong>: 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码</li><li><strong>回调执行代码(异步代码)</strong>: 处理回调逻辑</li></ul></li><li>js引擎执行代码的基本流程：先执行初始化代码，后面在某个时刻才执行回调代码</li></ul><h3 id="事件循环模型"><a href="#事件循环模型" class="headerlink" title="事件循环模型"></a>事件循环模型</h3><ul><li>事件循环模型由两个重要部分组成<ul><li>事件（定时器、DOM事件、Ajax）管理模块</li><li>回调队列</li></ul></li><li>模型运转流程<ol><li>执行初始化代码, 将事件回调函数交给对应模块管理</li><li>当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中</li><li>只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行</li></ol></li></ul><p><img src="/images/javascript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%A8%A1%E5%9E%8B.png" alt="事件循环模型"></p><p>上图中相关重要概念</p><ol><li>执行栈（execution stack）：所有代码都是在此空间执行的</li><li>浏览器内核（browser core）：js引擎模块(在主线程处理)，其它模块(在主&#x2F;分线程处理，如定时器、Ajax、DOM事件监听)</li><li>回调队列（callback queue）:异步代码在此处等待排队</li><li>事件轮询（event loop）:从回调队列中循环取出回调函数放入执行栈中处理(一个接一个)</li></ol>]]></content>
    
    
    <categories>
      
      <category>javaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对象</title>
    <link href="/2021/10/17/javaScript/%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/10/17/javaScript/%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="对象（Object）"><a href="#对象（Object）" class="headerlink" title="对象（Object）"></a>对象（Object）</h1><ul><li>对象是JS中的引用数据类型</li><li>对象是一种复合数据类型，在对象中可以保存多个不同数据类型的属性</li><li>使用<code>typeof</code>检查一个对象时，会返回<code>object</code></li></ul><span id="more"></span><h2 id="对象的基本语法"><a href="#对象的基本语法" class="headerlink" title="对象的基本语法"></a>对象的基本语法</h2><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><ul><li><p>方式一：</p>  <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>()<br></code></pre></td></tr></table></figure></li><li><p>方式二：</p>  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var obj <span class="hljs-operator">=</span> &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>方式三：<br>  使用对象字面量，在创建对象时直接向对象中添加属性</p><ul><li><p>语法：</p>  <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> obj = &#123;<br>    name: <span class="hljs-string">&#x27;tom&#x27;</span>,<br>    age: <span class="hljs-number">18</span>,<br>    sex: <span class="hljs-string">&#x27;男&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>  <strong>注</strong>：在什么时候使用 <code>对象[&quot;对象名&quot;]</code> 的方式</p><ol><li><p>属性名包含特殊字符：_ 空格</p> <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">//需求: 添加一个属性: content-<span class="hljs-keyword">type</span>: text/json<br>//p.content-<span class="hljs-keyword">type</span> <span class="hljs-type">= </span><span class="hljs-symbol">&#x27;text</span>/json&#x27; //不正确<br> p[<span class="hljs-symbol">&#x27;content</span>-<span class="hljs-keyword">type</span>&#x27;] = <span class="hljs-symbol">&#x27;text</span>/json&#x27;<br></code></pre></td></tr></table></figure></li></ol><pre><code class="hljs">2. 属性名不确定    <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//将name作为p的属性添加进p对象</span><br><span class="hljs-selector-tag">var</span> prop = <span class="hljs-string">&#x27;name&#x27;</span><br><span class="hljs-selector-tag">var</span> value = <span class="hljs-number">123</span><br><span class="hljs-comment">// p.prop = value  //不正确</span><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[prop]</span> = value<br></code></pre></td></tr></table></figure></code></pre><ol><li>2个引用变量指向同一个对象, 通过一个引用变量修改对象内部数据, 另一个引用变量也看得见</li><li>2个引用变量指向同一个对象,让一个引用变量指向另一个对象, 另一个引用变量还是指向原来的对象</li></ol></li></ul><h3 id="向对象中添加属性"><a href="#向对象中添加属性" class="headerlink" title="向对象中添加属性"></a>向对象中添加属性</h3><ul><li>语法：<br>  <code>对象.属性名 = 属性值</code><br>  <code>对象[&quot;属性名&quot;] = 属性值</code><ul><li>对象的属性名没有任何要求，不需要遵守标识符的规范，<br>  但是在开发中，尽量按照标识符的要求去写。</li><li>属性值也可以任意的数据类型。</li></ul></li></ul><h3 id="读取对象中的属性"><a href="#读取对象中的属性" class="headerlink" title="读取对象中的属性"></a>读取对象中的属性</h3><ul><li><p>语法：</p><p>  <code>对象.属性名</code><br>  <code>对象[&quot;属性名&quot;]</code></p></li><li><p>如果读取一个对象中没有的属性，它不会报错，而是返回一个<code>undefined</code></p></li></ul><h3 id="删除对象中的属性"><a href="#删除对象中的属性" class="headerlink" title="删除对象中的属性"></a>删除对象中的属性</h3><ul><li>语法：<br>  <code>delete 对象.属性名</code><br>  <code>delete 对象[&quot;属性名&quot;]</code></li></ul><h3 id="使用in检查对象中是否含有指定属性"><a href="#使用in检查对象中是否含有指定属性" class="headerlink" title="使用in检查对象中是否含有指定属性"></a>使用in检查对象中是否含有指定属性</h3><ul><li><p>语法：<br>  <code>&quot;属性名&quot; in 对象</code></p></li><li><p>如果在对象中含有该属性，则返回true如果没有则返回false</p></li></ul><h3 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h3><ul><li>基本数据类型<br>  <code>String Number Boolean Null Undefined</code></li><li>引用数据类型<br>  <code>Object</code></li><li>基本数据类型的数据，变量是直接保存的它的值。<br>  变量与变量之间是互相独立的，修改一个变量不会影响其他的变量。</li><li>引用数据类型的数据，变量是保存的对象的引用（内存地址）。<br>  如果多个变量指向的是同一个对象，此时修改一个变量的属性，会影响其他的变量。</li><li>比较两个变量时，对于基本数据类型，比较的就是值，<br>  对于引用数据类型比较的是地址，地址相同才相同</li></ul><h2 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h2><h3 id="Object构造函数模式"><a href="#Object构造函数模式" class="headerlink" title="Object构造函数模式"></a>Object构造函数模式</h3><ul><li><p>套路: 先创建空<code>Object</code>对象, 再动态添加属性&#x2F;方法</p></li><li><p>适用场景: 起始时不确定对象内部数据</p></li><li><p>问题: 语句太多</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>()<br>p.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Tom&#x27;</span><br>p.<span class="hljs-property">age</span> = <span class="hljs-number">12</span><br>p.<span class="hljs-property">setName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="对象字面量模式"><a href="#对象字面量模式" class="headerlink" title="对象字面量模式"></a>对象字面量模式</h3><ul><li><p>套路: 使用<code>&#123;&#125;</code>创建对象, 同时指定属性&#x2F;方法</p></li><li><p>适用场景: 起始时对象内部数据是确定的</p></li><li><p>问题: 如果创建多个对象, 有重复代码</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> p = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">23</span>,<br>    <span class="hljs-attr">setName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><ul><li><p>套路: 通过工厂函数动态创建对象并返回</p></li><li><p>适用场景: 需要创建多个对象</p></li><li><p>问题: 对象没有一个具体的类型, 都是<code>Object</code>类型</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createPerson</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-keyword">var</span> p = &#123;<br>        <span class="hljs-attr">name</span>: name,<br>        <span class="hljs-attr">age</span>: age,<br>        <span class="hljs-attr">setName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>        &#125;,<br>    &#125;<br>    <span class="hljs-keyword">return</span> p<br>&#125;<br><span class="hljs-keyword">var</span> p1 = <span class="hljs-title function_">createPerson</span>(<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-number">12</span>)<br><span class="hljs-keyword">var</span> p2 = <span class="hljs-title function_">createPerson</span>(<span class="hljs-string">&#x27;JAck&#x27;</span>, <span class="hljs-number">13</span>)<br></code></pre></td></tr></table></figure></li></ul><h3 id="自定义构造函数模式"><a href="#自定义构造函数模式" class="headerlink" title="自定义构造函数模式"></a>自定义构造函数模式</h3><ul><li><p>套路: 自定义构造函数, 通过<code>new</code>创建对象</p></li><li><p>适用场景: 需要创建多个类型确定的对象</p></li><li><p>问题: 每个对象都有相同的数据, 浪费内存</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">setName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-number">12</span>)<br><span class="hljs-keyword">var</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Tom2&#x27;</span>, <span class="hljs-number">13</span>)<br></code></pre></td></tr></table></figure></li></ul><h3 id="构造函数-原型的组合模式"><a href="#构造函数-原型的组合模式" class="headerlink" title="构造函数+原型的组合模式"></a>构造函数+原型的组合模式</h3><ul><li><p>套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上</p></li><li><p>适用场景: 需要创建多个类型确定的对象</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">setName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>&#125;<br><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-number">12</span>)<br><span class="hljs-keyword">var</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;JAck&#x27;</span>, <span class="hljs-number">23</span>)<br></code></pre></td></tr></table></figure></li></ul><h2 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型 prototype"></a>原型 prototype</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>我们所创建的每一个函数，解析器都会向函数中添加一个属性<code>prototype</code>，这个属性对应着一个对象，这个对象就是我们所谓的原型对象<br>如果函数作为普通函数调用<code>prototype</code>没有任何作用，当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象，我们可以通过 <code>__proto__</code> 来访问该属性</p><p>原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。</p><p>当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用</p><p>我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了</p><ul><li><p>向构造函数的原型中添加属性</p>  <figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-type">MyClass</span>.proto<span class="hljs-keyword">type</span>.name = 123<br></code></pre></td></tr></table></figure></li><li><p>向构造函数中原型中添加一个方法</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">MyClass</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty()"></a><code>hasOwnProperty()</code></h3><ul><li>可以使用对象的<code>hasOwnProperty()</code>来检查对象自身中是否含有该属性</li><li>使用<code>hasOwnProperty()</code>方法只有当对象自身中含有属性时，才会返回<code>true</code></li><li>使用<code>in</code>检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回<code>true</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age, gender</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">gender</span> = gender<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">a</span> = <span class="hljs-number">123</span><br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;男&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">in</span> p) <span class="hljs-comment">//true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;a&#x27;</span>)) <span class="hljs-comment">//false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span>.<span class="hljs-title function_">hasOwnProterty</span>(<span class="hljs-string">&#x27;a&#x27;</span>)) <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>注意：</strong></p><ul><li><p>原型对象也是对象，所以它也有原型，当我们使用一个对象的属性或方法时，会现在自身中寻找，自身中如果有，则直接使用，如果没有则去原型对象中寻找，如果原型对象中有，则使用，如果没有则去原型的原型中寻找，直到找到Object对象的原型，Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回<code>undefined</code></p></li><li><p><strong>通过原型对象添加的属性和方法函数本身是没有的</strong>，这就是静态方法和实例方法的区别</p></li></ul></li><li><p><strong>总结</strong></p><ul><li>函数的<code>prototype</code>属性: 在定义函数时自动添加的, 默认值是一个空<code>Object</code>对象</li><li>对象的<code>__proto__</code>属性: 创建对象时自动添加的, 默认值为构造函数的<code>prototype</code>属性值</li><li>实例与构造函数原型有直接联系，但是实例与构造函数之间没有。</li><li>程序员能直接操作显式原型, 但不能直接操作隐式原型(ES6之前)</li></ul></li></ul><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><ul><li>每个构造函数都有一个原型对象，原型有一个属性（<code>constructor</code>）指回构造函数，而实例有一个内部指针（<code>__proto__</code>）指向原型，又原型也是另一个类型的实例，那就意味着这个原型本身有一个内部指针指向另一个原型，相应的另一个原型也有一个指针指向另一个构造函数。这样实例和原型之间就构造了一条原型链。</li><li>任何函数的默认原型都是一个<code>Object</code>的实例，因此构造函数的原型对象都有<code>__proto__</code>指向<code>Object.prototype</code>（包括<code>Function</code>），而<code>Object.__proto__ === null</code>，因此Object.__proto__是整条原型链的末端。</li></ul><p><strong>注：</strong></p><ul><li><strong>实例对象的<code>__proto__</code>等于构造函数的prototype</strong></li><li>实例对象的<code>prototype</code>是<code>undefined</code></li><li>任何函数的构造函数都是<code>Function</code>，包括<code>Function</code>也不例外，因此<code>Function.__proto__ === Function.prototype</code></li><li><code>function</code>是<code>Function</code>的实例，实例化的对象是<code>Object</code>的实例</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;123&#x27;</span><br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;aaa&#x27;</span><br><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">name</span>) <span class="hljs-comment">//aaa</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property">__proto__</span>) <span class="hljs-comment">//true (Object是Function的实例对象</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Function</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">//true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">//undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">//true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">//true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">//true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p><img src="/images/javascript/%E5%8E%9F%E5%9E%8B%E9%93%BE1.png" alt="原型链1"></p><ul><li>重写函数的prototype后，相当于prototype指向了一个新的对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;123&#x27;</span><br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;aaa&#x27;</span><br><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;bbb&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">5</span>,<br>&#125;<br><span class="hljs-keyword">var</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">constructor</span>) <span class="hljs-comment">//Person</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property">constructor</span>) <span class="hljs-comment">//Function</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">age</span>) <span class="hljs-comment">//undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">name</span>) <span class="hljs-comment">//aaa</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">__proto__</span>.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span>) <span class="hljs-comment">//5</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2.<span class="hljs-property">age</span>) <span class="hljs-comment">//5</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">name</span>) <span class="hljs-comment">//bbb</span><br><br></code></pre></td></tr></table></figure></li></ul><p><img src="/images/javascript/%E5%8E%9F%E5%9E%8B%E9%93%BE2.png" alt="原型链2"></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="通过原型链继承"><a href="#通过原型链继承" class="headerlink" title="通过原型链继承"></a>通过原型链继承</h3><ul><li><p>套路</p><ol><li>定义父类型构造函数</li><li>给父类型的原型添加方法</li><li>定义子类型的构造函数</li><li>创建父类型的对象赋值给子类型的原型</li><li>将子类型原型的构造属性设置为子类型</li><li>给子类型原型添加方法</li><li>创建子类型的对象: 可以调用父类型的方法</li></ol></li><li><p>关键</p><p>  子类型的原型为父类型的一个实例对象</p><p>  function SuperType() {<br>  this.colors &#x3D; [‘red’, ‘blue’, ‘green’]<br>  this.name &#x3D; 2<br>  }</p><p>  function SubType() {}</p><p>  &#x2F;&#x2F; 继承 SuperType<br>  SubType.prototype &#x3D; new SuperType()</p><p>  let instance1 &#x3D; new SubType()<br>  instance1.name +&#x3D; 2<br>  instance1.colors.push(‘black’)<br>  console.log(instance1.colors) &#x2F;&#x2F; “red,blue,green,black”<br>  console.log(instance1.name) &#x2F;&#x2F; 4</p><p>  let instance2 &#x3D; new SubType()<br>  console.log(instance2.colors) &#x2F;&#x2F; “red,blue,green,black”<br>  console.log(instance2.name) &#x2F;&#x2F; 2</p></li></ul><p>在这个例子中， <code>SuperType</code> 构造函数定义了一个 <code>colors</code> 属性，其中包含一个数组（引用值）。每个 <code>SuperType</code> 的实例都会有自己的 <code>colors</code> 属性，包含自己的数组。但是，当 <code>SubType</code> 通过原型继承SuperType 后， <code>SubType.prototype</code> 变成了 <code>SuperType</code> 的一个实例，因而也获得了自己的 <code>colors</code>属性。这类似于创建了 <code>SubType.prototype.colors</code> 属性。最终结果是， <code>SubType</code> 的所有实例都会共享这个 <code>colors</code> 属性。</p><p>导致<code>SubType</code>的每个实例引用 <code>colors</code> 属性, 都会从原型链中寻找<code>SubType.prototype.colors</code> 属性，相当于每个<code>SubType</code>都共用同一个 <code>colors</code> 属性。</p><p>而对于基本数据类型来说，执行instance1.name +&#x3D; 2 这行代码，会在instance1 实例中添加name属性，然后在从SubType.prototype中读取name属性的值（2），最后 +2，等价于instance1.name &#x3D; SubType.prototype.name + 2。而SubType.prototype.name的值没有改变，仅读取instance2.name的值时，instance2会从原型链中读取SubType.prototype.name的值（2） </p><h3 id="盗用构造函数继承"><a href="#盗用构造函数继承" class="headerlink" title="盗用构造函数继承"></a>盗用构造函数继承</h3><ul><li>套路:<ol><li>定义父类型构造函数</li><li>定义子类型构造函数</li><li><strong>在子类型构造函数中调用父类型构造</strong></li></ol></li><li>关键:<ol><li>在子类型构造函数中通用call() 调用父类型构造函数</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 继承 SuperType 并传参</span><br>    <span class="hljs-title class_">SuperType</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&#x27;Nicholas&#x27;</span>) <span class="hljs-comment">// this.SuperType(&quot;Nicholas&quot;) 等价于 this.name = name</span><br>    <span class="hljs-comment">// 实例属性</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">29</span><br>&#125;<br><span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-property">name</span>) <span class="hljs-comment">// &quot;Nicholas&quot;;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-property">age</span>) <span class="hljs-comment">// 29</span><br><br></code></pre></td></tr></table></figure><p>盗用构造函数的一个优点就是可以在子类构造函数中向父类构造函数传参。<br>在 <code>SubType</code> 构造函数中调用 <code>SuperType</code> 构造函数时传入这个参数，实际上会在 <code>SubType</code> 的实例上定义 <code>name</code> 属性。</p><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><ul><li>原型链+盗用构造函数的组合继承<ul><li>使用原型链继承原型上的属性和方法</li><li>通过盗用构造函数继承实例属性</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>]<br>&#125;<br><span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-comment">// 继承属性</span><br>    <span class="hljs-title class_">SuperType</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>&#125;<br><span class="hljs-comment">// 继承方法</span><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperType</span>()<br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayAge</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>)<br>&#125;<br><br><span class="hljs-keyword">let</span> instance1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>(<span class="hljs-string">&#x27;Nicholas&#x27;</span>, <span class="hljs-number">29</span>)<br>instance1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;black&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance1.<span class="hljs-property">colors</span>) <span class="hljs-comment">// &quot;red,blue,green,black&quot;</span><br>instance1.<span class="hljs-title function_">sayName</span>() <span class="hljs-comment">// &quot;Nicholas&quot;;</span><br>instance1.<span class="hljs-title function_">sayAge</span>() <span class="hljs-comment">// 29</span><br><br><span class="hljs-keyword">let</span> instance2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>(<span class="hljs-string">&#x27;Greg&#x27;</span>, <span class="hljs-number">27</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance2.<span class="hljs-property">colors</span>) <span class="hljs-comment">// &quot;red,blue,green&quot;</span><br>instance2.<span class="hljs-title function_">sayName</span>() <span class="hljs-comment">// &quot;Greg&quot;</span><br>instance2.<span class="hljs-title function_">sayAge</span>() <span class="hljs-comment">// 27</span><br><br></code></pre></td></tr></table></figure><p>在这个例子中， <code>SuperType</code> 构造函数定义了两个属性， <code>name</code> 和 <code>colors</code>，而它的原型上也定义了一个方法叫 <code>sayName()</code>。<br><code>SubType</code> 构造函数调用了 <code>SuperType</code> 构造函数，传入了 <code>name</code> 参数，然后又定义了自己的属性 <code>age</code>。此外， <code>SubType.prototype</code> 也被赋值为 <code>SuperType</code> 的实例。原型赋值之后，又在这个原型上添加了新方法 <code>sayAge()</code>。<br>这样，就可以创建两个 <code>SubType</code> 实例，让这两个实例都有自己的属性，包括 <code>colors</code>，同时还共享相同的方法。</p><p><img src="/images/javascript/%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF.png" alt="组合继承"></p><h2 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h2><ul><li><p>在JS中使用<code>Date</code>对象来表示一个时间</p></li><li><p>创建一个<code>Date</code>对象</p><ul><li><p>如果直接使用构造函数创建一个Date对象，则会封装为当前代码执行的时间</p>  <figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">var</span> <span class="hljs-built_in">date</span> = <span class="hljs-literal">new</span> <span class="hljs-built_in">Date</span>();  <span class="hljs-comment">//封装此行代码执行的时间</span><br>console.<span class="hljs-keyword">log</span>(<span class="hljs-built_in">date</span>); <span class="hljs-comment">//打印date  Fri Dec 11 2020 23:32:17 GMT+0800 (中国标准时间)</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>创建一个指定的时间对象</p><ul><li><p>需要在构造函数中传递一个表示时间的字符串作为参数</p></li><li><p>日期的格式: 月&#x2F;日&#x2F;年 时:分:秒</p>  <figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">var</span> <span class="hljs-built_in">date</span> = <span class="hljs-literal">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&quot;2/18/2011 11:10:30&quot;</span>);<br>console.<span class="hljs-keyword">log</span>(<span class="hljs-built_in">date</span>); <span class="hljs-comment">//2011-02-18T03:10:30.000Z</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="getDate"><a href="#getDate" class="headerlink" title="getDate()"></a><code>getDate()</code></h3><ul><li><p>获取当前日期对象是几日</p>  <figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">var</span> <span class="hljs-built_in">date</span> = <span class="hljs-literal">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&quot;2/18/2011 11:10:30&quot;</span>);<br><span class="hljs-built_in">var</span> d = <span class="hljs-built_in">date</span>.getDate();<br>console.<span class="hljs-keyword">log</span>(d); <span class="hljs-comment">//18</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="getDay"><a href="#getDay" class="headerlink" title="getDay()"></a><code>getDay()</code></h3><ul><li><p>获取当前日期对象时周几</p></li><li><p>会返回一个0-6的值<br>  0 表示周日<br>  1 表示周一</p>  <figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">var</span> <span class="hljs-built_in">date</span> = <span class="hljs-literal">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&quot;2/18/2011 11:10:30&quot;</span>)<br><span class="hljs-built_in">var</span> d = <span class="hljs-built_in">date</span>.getDay()<br>console.<span class="hljs-keyword">log</span>(d) <span class="hljs-comment">//5 (周六)</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="getMonth"><a href="#getMonth" class="headerlink" title="getMonth()"></a><code>getMonth()</code></h3><ul><li><p>获取当前时间对象的月份</p></li><li><p>会返回一个0-11的值<br>  0 表示1月<br>  1 表示2月<br>  11 表示12月</p>  <figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">var</span> <span class="hljs-built_in">date</span> = <span class="hljs-literal">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&quot;2/18/2011 11:10:30&quot;</span>);<br><span class="hljs-built_in">var</span> d = <span class="hljs-built_in">date</span>.getMonth();<br>console.<span class="hljs-keyword">log</span>(d); <span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure></li></ul><p>​</p><h3 id="getFullYear"><a href="#getFullYear" class="headerlink" title="getFullYear()"></a><code>getFullYear()</code></h3><ul><li><p>获取当前日期对象的年份</p>  <figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">var</span> <span class="hljs-built_in">date</span> = <span class="hljs-literal">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&quot;2/18/2011 11:10:30&quot;</span>);<br><span class="hljs-built_in">var</span> d = <span class="hljs-built_in">date</span>.getFullYear();<br>console.<span class="hljs-keyword">log</span>(d); <span class="hljs-comment">//2011</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="getTime"><a href="#getTime" class="headerlink" title="getTime()"></a><code>getTime()</code></h3><ul><li>获取当前日期对象的时间戳<ul><li>时间戳，指的是从格林威治标准时间的1970年1月1日，0时0分0秒 到当前日期所花费的毫秒数</li></ul></li><li>计算机底层在保存时间时使用都是时间戳  <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> <span class="hljs-built_in">date</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&quot;2/18/2011 11:10:30&quot;</span>)<br><span class="hljs-keyword">var</span> <span class="hljs-built_in">time</span> = <span class="hljs-built_in">date</span>.getTime()<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">time</span>) <span class="hljs-comment">//1297998630000 (毫秒数)</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="Date-now"><a href="#Date-now" class="headerlink" title="Date.now()"></a><code>Date.now()</code></h3><ul><li><p>获取当前的时间戳</p>  <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> <span class="hljs-built_in">time</span> = <span class="hljs-built_in">Date</span>.<span class="hljs-built_in">now</span>();<br></code></pre></td></tr></table></figure></li><li><p>可以利用时间戳来测试代码的执行的性能</p></li></ul><h2 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h2><p><code>Math</code>和其他的对象不同，它不是一个构造函数，它属于一个工具类不用创建对象，它里边封装了数学运算相关的属性和方法</p><h3 id="abs"><a href="#abs" class="headerlink" title="abs()"></a><code>abs()</code></h3><p> 可以用来计算一个数的绝对值</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">abs</span>(<span class="hljs-number">-2</span>)) <span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><h3 id="Math-ceil"><a href="#Math-ceil" class="headerlink" title="Math.ceil()"></a><code>Math.ceil()</code></h3><p>可以对一个数进行向上取整，小数位只有有值就自动进1</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">ceil</span>(<span class="hljs-number">1.1</span>)) <span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><h3 id="Math-floor"><a href="#Math-floor" class="headerlink" title="Math.floor()"></a><code>Math.floor()</code></h3><p>可以对一个数进行向下取整，小数部分会被舍掉</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">floor</span>(<span class="hljs-number">1.99</span>)) <span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure><h3 id="Math-round"><a href="#Math-round" class="headerlink" title="Math.round()"></a><code>Math.round()</code></h3><p>可以对一个数进行四舍五入取整</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">round</span>(<span class="hljs-number">1.4</span>)) <span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure><h3 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random()"></a><code>Math.random()</code></h3><p>可以用来生成一个0-1之间的随机数</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//生成一个0-10的随机数</span><br>Math.<span class="hljs-built_in">round</span>(Math.<span class="hljs-built_in">random</span>() * <span class="hljs-number">10</span>)<br><br><span class="hljs-comment">//生成一个1-5之间的随机数</span><br>Math.<span class="hljs-built_in">round</span>(Math.<span class="hljs-built_in">random</span>() * <span class="hljs-number">5</span> + <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h3 id="max"><a href="#max" class="headerlink" title="max()"></a><code>max()</code></h3><p>可以获取多个数中的最大值</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">var</span> max = Math.max(<span class="hljs-number">10</span>,<span class="hljs-number">45</span>,<span class="hljs-number">30</span>,<span class="hljs-number">100</span>) // <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h3 id="min"><a href="#min" class="headerlink" title="min()"></a><code>min()</code></h3><p>可以获取多个数中的最小值</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">var</span> min = Math.min(<span class="hljs-number">10</span>,<span class="hljs-number">45</span>,<span class="hljs-number">30</span>,<span class="hljs-number">100</span>) // <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h3 id="Math-pow-x-y"><a href="#Math-pow-x-y" class="headerlink" title="Math.pow(x,y)"></a><code>Math.pow(x,y)</code></h3><p>返回x的y次幂</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">console</span>.log(Math.pow(<span class="hljs-number">12</span>,<span class="hljs-number">3</span>)) //<span class="hljs-number">12</span>^<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="Math-sqrt"><a href="#Math-sqrt" class="headerlink" title="Math.sqrt()"></a><code>Math.sqrt()</code></h3><p>用于对一个数进行开方运算</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">20</span>))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>javaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数</title>
    <link href="/2021/10/15/javaScript/%E5%87%BD%E6%95%B0/"/>
    <url>/2021/10/15/javaScript/%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="函数（Function）"><a href="#函数（Function）" class="headerlink" title="函数（Function）"></a>函数（Function）</h1><ul><li>函数也是一个对象，也具有普通对象的功能</li><li>函数中可以封装一些代码，在需要的时候可以去调用函数来执行这些代码</li><li>使用typeof检查一个函数时会返回function</li></ul><span id="more"></span><h2 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h2><ul><li><p>函数声明<br>  function 函数名([形参1,形参2…形参N]){<br>      语句…<br>  }<br><br>  function fun() {<br>      consloe.log(“hellow”);<br>  }</p></li><li><p>函数表达式<br>  var 函数名 &#x3D; function([形参1,形参2…形参N]){<br>      语句…<br>  };<br><br>  var fun &#x3D; function() {<br>      consloe.log(“hellow”);<br>  }</p></li></ul><h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><ul><li><p>语法：<br>  函数对象([实参1,实参2…实参N]);<br>  fun(); sum(); alert(); Number(); parseInt();<br>  &#x2F;&#x2F;fun() 直接调用<br>  &#x2F;&#x2F;obj.fun() 通过对象调用<br>  &#x2F;&#x2F;new fun() new调用<br>  &#x2F;&#x2F;fun.call(obj) fun.apply(obj) 临时让fun成为obj的方法进行调用 obj.fun()<br>      var obj &#x3D;{};<br>      funcation fun() {<br>          this.name &#x3D; “123”;<br>      }<br>      &#x2F;&#x2F;obj.fun() 错误，obj中没有fun这个方法<br>      fun.call(obj)<br>      console.log(obj.name) &#x2F;&#x2F; 123</p></li><li><p>当我们调用函数时，函数中封装的代码会按照编写的顺序执行</p></li></ul><h2 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h2><ul><li>形参：形式参数<ul><li>定义函数时，可以在()中定义一个或多个形参，形参之间使用 , 隔开</li><li>定义形参就相当于在函数内声明了对应的变量但是并不赋值，</li><li>形参会在调用时才赋值。</li></ul></li><li>实参：实际参数<ul><li>调用函数时，可以在()传递实参，传递的实参会赋值给对应的形参,</li><li>调用函数时JS解析器不会检查实参的类型和个数，可以传递任意数据类型的值。</li><li>如果实参的数量大于形参，多余实参将不会赋值，</li><li>如果实参的数量小于形参，则没有对应实参的形参将会赋值undefined</li></ul></li></ul><h2 id="返回值-return"><a href="#返回值-return" class="headerlink" title="返回值 return"></a>返回值 return</h2><p>可以使用 return 来设置函数的返回值<br>语法：<br>        return 值;</p><pre><code class="hljs">    return a;</code></pre><ul><li>return后的值将会会作为函数的执行结果返回，可以定义一个变量，来接收该结果</li><li>在函数中return后的语句都不会执行</li><li>如果return语句后不跟任何值就相当于返回一个undefined， 如果函数中不写return，则也会返回undefined</li></ul><h2 id="立即执行函数-IIFE"><a href="#立即执行函数-IIFE" class="headerlink" title="立即执行函数(IIFE)"></a>立即执行函数(IIFE)</h2><ul><li><p>函数定义完，立即被调用，这种函数叫做立即执行函数，匿名函数直接调用</p></li><li><p>立即执行函数往往只会执行一次</p></li><li><p>作用：隐藏实现，不会污染外部命名空间，编写js模块<br>  语法：</p><pre><code class="hljs">  (function([形参1,形参2...形参N])&#123;      语句...  &#125;)([实参1,实参2...实参N]);  (function()&#123;      consloe.log(&quot;hellow&quot;);  &#125;)();  (function(a,b)&#123;      console.log(&quot;a = &quot;+a);      console.log(&quot;b = &quot;+b);  &#125;)(123,456);</code></pre></li></ul><h2 id="函数的声明提前"><a href="#函数的声明提前" class="headerlink" title="函数的声明提前"></a>函数的声明提前</h2><pre><code class="hljs">- 使用函数声明形式创建的函数 function 函数()&#123;&#125;- 它会在所有的代码执行之前就被创建，所以我们可以在函数声明前来调用函数- 使用函数表达式创建的函数，不会被声明提前，所以不能在声明前调用</code></pre><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ul><li>作用域指一个变量的作用的范围</li></ul><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><pre><code class="hljs">- 直接编写在script标签中的JS代码，都在全局作用域- 全局作用域在页面打开时创建，在页面关闭时销毁- 在全局作用域中有一个全局对象window，它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用- 在全局作用域中： 创建的变量都会作为window对象的属性保存创建的函数都会作为window对象的方法保存- 全局作用域中的变量都是全局变量，在页面的任意的部分都可以访问的到</code></pre><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><pre><code class="hljs">- 函数作用域是在function字样里的作用域,调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁 - 每调用一次函数就会创建一个新的函数作用域，它们之间互相独立的 - 当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果没有，再在离得最近的一级作用域，直到找到全局变量，如果全局作用域中没有找到，就会报错 - 如果想直接在函数作用域中用全局的变量,使用window.a来调用(前提是用var或者直接写来声明的变量) - 在函数作用域中也有声明提前的特性，使用变量声明关键字声明的变量，会在函数中所有的代码执行之前被声明，这个变量是在函数作用域中被声明的，同理在函数中声明的函数也是一样 - 有参的函数在调用的时候不传入实参,形参的值是undefined，因为在定义形参的时候相当于在函数内部用var声明了一个变量，没有赋值的变量一律为undefined，即使全局变量中有一样的变量也会用内部没有赋值的变量</code></pre><h2 id="关键字-this"><a href="#关键字-this" class="headerlink" title="关键字 this"></a>关键字 this</h2><ul><li>解析器在调用函数每次都会向函数内部传递进一个隐含的参数这个隐含的参数就是this</li><li>this指向的是一个对象，这个对象我们称为函数执行的上下文对象<ul><li>根据函数的调用方式的不同，this会指向不同的对象<ol><li><p>以函数的形式调用时，this永远都是window<br> var name &#x3D; “abc”;<br><br> function fun(){<br>     console.log(this.name);&#x2F;&#x2F;此时this.name指向全局作用域的window.name<br> }<br><br> fun(); </p></li><li><p>以方法的形式调用时，this就是调用方法的那个对象<br> function fun(){<br>         console.log(this.name);&#x2F;&#x2F;此时的this.name指向的是定义的obj对象中的name属性<br>     }<br><br> var obj &#x3D; {<br>             name:”abc”,<br>             sayName:fun<br>         };<br><br> obj.sayname(); </p></li><li><p>以构造函数的形式调用时，this就是新创建的那个对象<br> function Person(name , age , gender){<br>     this.name &#x3D; name;<br>     this.age &#x3D; age;<br>     this.gender &#x3D; gender;<br>     this.sayName &#x3D; function(){<br>         console.log(this.name); &#x2F;&#x2F;this指向的都是Person类中的属性<br>     };<br> }</p></li></ol></li></ul></li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul><li>构造函数就是一个普通的函数，创建方式和普通函数没有区别,<ul><li><p>不同的是构造函数习惯上首字母大写</p></li><li><p>构造函数和普通函数的区别就是调用方式的不同<br>  普通函数是直接调用，而构造函数需要使用new关键字来调用</p></li><li><p>构造函数的执行流程：<br>  1.立刻创建一个新的对象<br>  2.将新建的对象设置为函数中this,在构造函数中可以使用this来引用新建的对象<br>  3.逐行执行函数中的代码<br>  4.将新建的对象作为返回值返回</p></li><li><p>使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类。<br>  我们将通过一个构造函数创建的对象，称为是该类的实例</p><pre><code class="hljs">  function Person(name , age , gender)&#123;          this.name = name;          this.age = age;          this.gender = gender;          this.sayName = function()&#123;              console.log(this.name);           &#125;;      &#125;  var p1 = new Person(&quot;张三&quot;, 18, &quot;男&quot;); //此时的person是以构造函数的形式赋值给p1变量  var p2 = Person(&quot;李四&quot;, 18, &quot;男&quot;); //此时的person是以普通函数的形式赋值给p1变量</code></pre></li></ul></li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul><li><p>当函数可以记住并访问所在的词法作用域时， 就产生了闭包， 即使函数是在当前词法作用域之外执行。<br>  通俗来说当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包<br>  （函数嵌套，内部函数引用外部函数的变量）<br>  function foo() {<br>      var a &#x3D; 2;<br><br>      function bar() {<br>          console.log(a);<br>      }<br>      return bar;<br>  }<br>  var baz &#x3D; foo();<br>  baz(); &#x2F;&#x2F;2</p><ul><li>在上述代码中，函数 bar() 的词法作用域能够访问 foo() 的内部作用域（foo()内部嵌套了bar()函数）。将 bar() 函数本身当作一个值类型进行传递，使得bar()能够在它的词法作用域外部进行调用</li><li>我们都知道在函数执行完毕后就，将由垃圾回收机制释放掉foo()函数所占用的内存，但是 var baz &#x3D; foo() 这行代码中，bar()函数一直处于执行状态，而foo()函数内部作用域任然在被bar()函数使用（bar()打印变量a的值），拜 bar() 所声明的位置所赐， 它拥有涵盖 foo() 内部作用域的闭包， 使得该作用域能够一直存活， 以供 bar() 在之后任何时间进行引用。</li><li>bar() 依然持有对该作用域的引用， 而这个引用就叫作闭包。</li></ul></li><li><p>循环与闭包<br>  正常情况下，我们对这段代码行为的预期是分别输出数字 1~5，每秒一次， 每次一个。但实际上， 这段代码在运行时会以每秒一次的频率输出五次 6。<br>  for (var i &#x3D; 1; i &lt;&#x3D; 5; i++) {<br>      setTimeout(function timer() {<br>          console.log(i);<br>      }, i * 1000);<br>  }<br>  因为延迟回调函数的执行总是在循环执行结束才执行的，此时执行回调函数是 i &#x3D;&#x3D;&#x3D; 6。尽管循环中5个函数都是分别定义的，但是它们都处在一个<strong>共享全局作用域</strong>中，因此实际上只有一个 i 。</p><pre><code class="hljs">  for (var i = 1; i &lt;= 5; i++) &#123;      (function (i) &#123;          setTimeout(function timer() &#123;              console.log(i);          &#125;, j * 1000);      &#125;)(i);  &#125;</code></pre><p>  IIFE 会通过声明并立即执行一个函数来创建作用域。在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域， 使得延迟函数的回调可以将新的作用域封闭在每个迭代内部， 每个迭代中都会含有一个具有正确值的变量供我们访问。</p><pre><code class="hljs">  for (let i = 1; i &lt;= 5; i++) &#123;      setTimeout(function timer() &#123;          console.log(i);      &#125;, i * 1000);  &#125;</code></pre><p>  还能使用let声明创建块作用域，并且for 循环头部的 let 声明还会有一个特殊的行为。 这个行为指出变量在循环过程中不止被声明一次， 每次迭代都会声明。 随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。</p></li><li><p><strong>模块</strong></p><ul><li><p>我们可以利用闭包创建JS模块</p><ul><li><p>具有特定功能的js文件</p></li><li><p>将所有的数据和功能都封装在一个函数内部(私有的)</p></li><li><p>只向外暴露一个包信n个方法的对象或函数</p></li><li><p>模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能</p><pre><code class="hljs">  function CoolModule() &#123;      var something = &quot;cool&quot;;      var another = [1, 2, 3];      function doSomething() &#123;          console.log(something);      &#125;      function doAnother() &#123;          console.log(another.join(&quot; ! &quot;));      &#125;      return &#123;          doSomething: doSomething,          doAnother: doAnother      &#125;;  &#125;  //将以上部分通过js文件保存起来，直接引用外部js文件  var foo = CoolModule();  foo.doSomething(); // cool  foo.doAnother(); // 1 ! 2 ! 3</code></pre></li></ul></li><li><p>首先， CoolModule() 只是一个函数， 必须要通过调用它来创建一个模块实例。 如果不执行外部函数， 内部作用域和闭包都无法被创建。</p></li><li><p>其次， CoolModule() 返回一个用对象字面量语法 { key: value, … } 来表示的对象。 这个返回的对象中含有对内部函数而不是内部数据变量的引用。 我们保持内部数据变量是隐藏且私有的状态。 可以将这个对象类型的返回值看作本质上是模块的公共 API。</p></li><li><p>这个对象类型的返回值最终被赋值给外部的变量 foo， 然后就可以通过它来访问 API 中的属性方法， 比如 foo.doSomething()。</p></li><li><p>doSomething() 和 doAnother() 函数具有涵盖模块实例内部作用域的闭包（ 通过调用CoolModule() 实现）。</p></li><li><p>模块模式需要具备两个必要条件。</p><ol><li>必须有外部的封闭函数， 该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。</li><li>封闭函数必须返回至少一个内部函数， 这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li></ol></li></ul></li><li><p>记住闭包产生的条件：<strong>当函数可以记住并访问所在的词法作用域， 即使函数是在当前词法作用域之外执行， 这时就产生了闭包。</strong></p></li></ul><h2 id="垃圾回收（GC）"><a href="#垃圾回收（GC）" class="headerlink" title="垃圾回收（GC）"></a>垃圾回收（GC）</h2><ul><li>就像人生活的时间长了会产生垃圾一样，程序运行过程中也会产生垃圾，这些垃圾积攒过多以后，会导致程序运行的速度过慢，所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生垃圾</li><li>当一个对象没有任何的变量或属性对它进行引用，此时我们将永远无法操作该对象，此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，所以这种垃圾必须进行清理。</li><li>在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要也不能进行垃圾回收的操作</li><li>我们需要做的只是要将不再使用的对象设置null即可<br>  var obj &#x3D; new Object();<br><br> &#x2F;&#x2F;对对象进行各种操作。。。。<br><br> obj &#x3D; null;</li></ul>]]></content>
    
    
    <categories>
      
      <category>javaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事件</title>
    <link href="/2021/10/15/DOM/%E4%BA%8B%E4%BB%B6/"/>
    <url>/2021/10/15/DOM/%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>HTML 事件是发生在 HTML 元素上的事情。</p><p>当在 HTML 页面中使用 JavaScript 时， JavaScript 可以触发这些事件。</p><span id="more"></span><h2 id="事件的冒泡"><a href="#事件的冒泡" class="headerlink" title="事件的冒泡"></a>事件的冒泡</h2><p>事件的冒泡（Bubble）</p><ul><li>所谓的冒泡指的就是事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发</li><li>在开发中大部分情况冒泡都是有用的,如果不希望发生事件冒泡可以通过事件对象来取消冒泡<ul><li>可以将事件对象的 cancelBubble 设置为true，即可取消冒泡，这个需要设置在子元素的事件中，并且大多数都是设置的可以冒泡，除了某些函数默认不冒泡<br>  event.cancelBubble &#x3D; true;</li></ul></li></ul><p>如果在父元素里面设置了一个事件,而在子元素中也有相同的事件,不想要父元素的事件在子元素的范围内出现时，可以通过多种方式设置取消冒泡</p><ol><li>event.cancelBubble &#x3D; true</li><li>event.stopPropagation();</li></ol><h2 id="事件的委派"><a href="#事件的委派" class="headerlink" title="事件的委派"></a>事件的委派</h2><ul><li>指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。</li><li>事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能</li></ul><p>例：<br>为每一个超链接都绑定一个单击响应函数，这里我们为每一个超链接都绑定了一个单击响应函数，这种中操作比较麻烦，而且这些操作只能为已有的超链接设置事件，而新添加超链接必须重新绑定</p><pre><code class="hljs">//获取所有的avar allA = document.getElementsByTagName(&quot;a&quot;);//遍历for(var i=0 ; i&lt;allA.length ; i++)&#123;    allA[i].onclick = function()&#123;        alert(&quot;我是a的单击响应函数！&quot;);    &#125;;&#125;</code></pre><p>我们希望，只绑定一次事件，即可应用到多个元素上，即使元素是后添加的，我们可以尝试将其绑定给元素的共同的祖先元素 </p><pre><code class="hljs">//假设所以的a元素都是由一个父元素包裹，获取a的父元素var parent=document.getElementById(&quot;parent&quot;);//为a的父元素绑定事件parent.onclick=function()&#123;    alert(&quot;我是a的单击响应函数！&quot;);&#125;</code></pre><p> 12345但是这个例子需要判断如果触发的对象是我们期望的元素,就执行该代码,否则不执行,因为如果点击的是a元素之外的其它地方就不触发弹窗效果,这个时候需要使用target 事件对象中的event中的target表示的触发事件的对象 </p><pre><code class="hljs">parent.onclick=function(event)&#123;    event=event||window.event;    if(event.target.nodeName===&quot;A&quot;)&#123;//nodeName返回的标签名全为大写        alert(&quot;我是a的单击响应函数！&quot;);       &#125;&#125;</code></pre><h2 id="事件的绑定"><a href="#事件的绑定" class="headerlink" title="事件的绑定"></a>事件的绑定</h2><h3 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h3><ul><li><p>使用 对象.事件 &#x3D; 函数 的形式绑定响应函数，它只能同时为一个元素的一个事件绑定一个响应函数，不能绑定多个，如果绑定了多个，则后边会覆盖掉前边的</p></li><li><p>使用addEventListener() （不支持IE8）可以同时为一个元素的相同事件同时绑定多个响应函数，这样当事件被触发时，响应函数将会按照函数的绑定顺序执行</p><ul><li><p>参数：<br>  1.事件的字符串，不要on （onclick -&gt; click）<br>  2.回调函数，当事件触发时该函数会被调用<br>  3.是否在捕获阶段触发事件，需要一个布尔值，true表示事件在捕获阶段执行，flase表示在冒泡阶段执行，默认值为false(可选)，如果想要这两个事件都可以在同一个对象上发生必须添加两次事件</p><pre><code class="hljs">  btn.addEventListener(&quot;click&quot;,function()&#123;      alert(1);  &#125;,false);    btn.addEventListener(&quot;click&quot;,function()&#123;      alert(2);  &#125;,false);</code></pre></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>DOM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变量与作用域</title>
    <link href="/2021/10/15/javaScript/%E5%8F%98%E9%87%8F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/2021/10/15/javaScript/%E5%8F%98%E9%87%8F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ul><li><strong>字面量</strong><br>字面量（常量），都是一些不可改变的值<br>比如 ：1 2 3 4 5<br>字面量都是可以直接使用，但是我们一般都不会直接使用字面量</li><li><strong>变量</strong><br>变量可以用来保存字面量，而且变量的值是可以任意改变的<br>变量更加方便我们使用，所以在开发中都是通过变量去保存一个字面量，而很少直接使用字面量，可以通过变量对字面量进行描述</li></ul><span id="more"></span><h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><ul><li>所有函数的参数都是按值传递的，在按值传递参数时，值会被复制到一个局部变量中（也就是arguments对象中的一个槽位）<br>  function setName(obj) {<br>      obj.name &#x3D; “aaa”<br>      obj &#x3D; new Object()<br>      obj.name &#x3D; “bbb”<br>  }<br>  var person &#x3D; new Object()<br>  setName(person)<br>  console.log(person.name) &#x2F;&#x2F; aaa<br>  如果是按照引用传递的话，person将会指向name为”bbb”的对象，而不是任然指向”aaa”的对象。<br>  当obj在函数内部重写时，它变成了一个指向本地对象的指针，而那个本地对象在函数执行结束时就被销毁了。</li></ul><h1 id="执行上下文与作用域"><a href="#执行上下文与作用域" class="headerlink" title="执行上下文与作用域"></a>执行上下文与作用域</h1><h2 id="变量提升与函数提升"><a href="#变量提升与函数提升" class="headerlink" title="变量提升与函数提升"></a>变量提升与函数提升</h2><ul><li><p>变量声明提升：通过var定义(声明)的变量, 在定义语句之前就可以访问到，但值: undefined</p></li><li><p>函数声明提升：通过function声明的函数, 在之前就可以直接调用，但 值: 函数定义(对象)</p><pre><code class="hljs">  //变量提升  console.log(a1) //可以访问, 但值是undefined  var a1 = 3  //函数提升  a2() // 可以直接调用，输出a2()  function a2() &#123;  console.log(&#39;a2()&#39;)  &#125;  a3() //报错  var a3 = function()&#123;      console.log(&#39;a3&#39;)  &#125;</code></pre></li></ul><p>遇到函数表达式 var a3 &#x3D; function(){}时，首先会将var a3上升到函数体顶部，然而此时的 a3 的值为 undefined,所以执行a3()报错。</p><ul><li><strong>注</strong>：<ul><li><p>当遇到函数和变量同名且都会被提升的情况，函数声明优先级比较高（<strong>实际上是变量先提升到全局作用域中，但值为undefined，然后函数提升并且给函数直接赋值</strong>），因此变量声明会被函数声明所覆盖，但是可以重新赋值。</p><pre><code class="hljs">  console.log(a) //输出：function a()&#123; console.log(&#39;函数&#39;) &#125;  function a() &#123;      console.log(&quot;函数&quot;)  &#125; //  var a = &quot;变量&quot;  console.log(a) //输出：&#39;变量&#39;</code></pre></li></ul></li></ul><p>function 声明的优先级比 var 声明高，也就意味着当两个同名变量同时被 function 和 var 声明时，function 声明会覆盖 var 声明。</p><p>这代码等效于：</p><pre><code class="hljs">    function a() &#123;        console.log(&quot;函数&quot;);    &#125;    var a    console.log(a) //输出：function a()&#123; console.log(&#39;函数&#39;) &#125;    a = &quot;变量&quot; //赋值    console.log(a) //输出：&#39;变量&#39;</code></pre><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><h3 id="全局执行上下文"><a href="#全局执行上下文" class="headerlink" title="全局执行上下文"></a>全局执行上下文</h3><pre><code class="hljs">* 在执行全局代码前将window确定为全局执行上下文* 对全局数据进行预处理    * var定义的全局变量==&gt;undefined, 添加为window的属性    * function声明的全局函数==&gt;赋值(fun), 添加为window的方法    * this==&gt;赋值(window)* 开始执行全局代码</code></pre><h3 id="函数执行上下文"><a href="#函数执行上下文" class="headerlink" title="函数执行上下文"></a>函数执行上下文</h3><pre><code class="hljs">* 在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象* 对局部数据进行预处理    * 形参变量==&gt;赋值(实参)==&gt;添加为执行上下文的属性    * arguments==&gt;赋值(实参列表), 添加为执行上下文的属性    * var定义的局部变量==&gt;undefined, 添加为执行上下文的属性    * function声明的函数 ==&gt;赋值(fun), 添加为执行上下文的方法    * this==&gt;赋值(调用函数的对象)* 开始执行函数体代码</code></pre><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><h2 id="JavaScript-引擎创建了执行上下文栈来管理执行上下文。可以把执行上下文栈认为是一个存储函数调用的栈结构，遵循后进先出的原则。-JavaScript-执行在单线程上，所有的代码都是排队执行，遵循后进先出的原则。-一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。-每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。-浏览器的-JS-执行引擎总是访问栈顶的执行上下文。-全局上下文只有唯一的一个，它在浏览器关闭时出栈。"><a href="#JavaScript-引擎创建了执行上下文栈来管理执行上下文。可以把执行上下文栈认为是一个存储函数调用的栈结构，遵循后进先出的原则。-JavaScript-执行在单线程上，所有的代码都是排队执行，遵循后进先出的原则。-一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。-每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。-浏览器的-JS-执行引擎总是访问栈顶的执行上下文。-全局上下文只有唯一的一个，它在浏览器关闭时出栈。" class="headerlink" title="JavaScript 引擎创建了执行上下文栈来管理执行上下文。可以把执行上下文栈认为是一个存储函数调用的栈结构，遵循后进先出的原则。- JavaScript 执行在单线程上，所有的代码都是排队执行，遵循后进先出的原则。- 一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。- 每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。- 浏览器的 JS 执行引擎总是访问栈顶的执行上下文。- 全局上下文只有唯一的一个，它在浏览器关闭时出栈。"></a>JavaScript 引擎创建了执行上下文栈来管理执行上下文。可以把执行上下文栈认为是一个存储函数调用的栈结构，遵循后进先出的原则。<br>- JavaScript 执行在单线程上，所有的代码都是排队执行，遵循后进先出的原则。<br>- 一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。<br>- 每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。<br>- 浏览器的 JS 执行引擎总是访问栈顶的执行上下文。<br>- 全局上下文只有唯一的一个，它在浏览器关闭时出栈。</h2><pre><code class="hljs">    var color = &quot;blue&quot;    function changeColor() &#123;        var anotherColor = &quot;red&quot;        function swapColors() &#123;            var tempColor = anotherColor            anotherColor = color            color = tempColor        &#125;        swapColors()    &#125;    changeColor()- 当上述代码在浏览器中加载时，JavaScript 引擎会创建一个全局执行上下文并且将它推入当前的执行栈- 调用 changeColor 函数时，此时 changeColor 函数内部代码还未执行，js 执行引擎立即创建一个 changeColor 的执行上下文，然后把这执行上下文压入到执行栈中。- 执行 changeColor 函数过程中，调用 swapColors 函数，同样地，swapColors 函数执行之前也创建了一个 swapColors 的执行上下文，并压入到执行栈中。- swapColors 函数执行完成，swapColors 函数的执行上下文出栈，并且被销毁。- changeColor 函数执行完成，changeColor 函数的执行上下文出栈，并且被销毁。</code></pre><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ul><li>我们可以这样理解：作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</li><li>在创建函数会创建函数作用域，函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。<strong>而外部作用域无法使用内部作用域的变量</strong></li><li>在ES6中引入了let关键字，用来在任意块中声明变量，在块中的变量无法在块作用域在进行引用<br>  var foo &#x3D; true;<br>  if (foo) {<br>      { &#x2F;&#x2F; &lt;– 显式的快<br>          let bar &#x3D; foo * 2;<br>          bar &#x3D; something( bar );<br>          console.log( bar );<br>      }<br>  }<br>  console.log( bar ); &#x2F;&#x2F; ReferenceError</li></ul><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><ul><li>作用域链是由多个上下级关系的作用域形成的链，他的方向是从下向上的（从内向外），查找变量时就是沿着作用域链来查找的<br>  var a &#x3D; 2;<br>  function fn1() {<br>      var b &#x3D; 3;<br>      function fn2() {<br>        var c &#x3D; 4;<br>        console.log(c);<br>        console.log(b);<br>        console.log(a);<br>        console.log(d);<br>      }<br><br>      fn2();<br>  }<br>  fn1(); &#x2F;&#x2F;4, 3, 2, ReferenceError<br>  上面例子中的作用域链就是fn2函数作用域–&gt;fn1函数作用域–&gt;全局作用域</li></ul>]]></content>
    
    
    <categories>
      
      <category>javaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事件对象</title>
    <link href="/2021/04/27/DOM/%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/04/27/DOM/%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><ul><li>当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递进响应函数,在事件对象中封装了当前事件相关的一切信息，比如：鼠标的坐标，键盘哪个按键被按下，鼠标滚轮滚动的方向…</li></ul><span id="more"></span><ul><li>注:<ul><li>一般都会把形参写在事件对象的形参里，虽然不写也不会报错，但是获取方式会相对麻烦</li><li>在IE8中，响应函数被触发时，浏览器不会传递事件对象。在IE8及以下的浏览器中，是将事件对象作为window对象的属性保存的<br>  &#x2F;&#x2F;写实参调用event<br>  function eventTest(event){<br>     event &#x3D; event || window.event;<br>  }<br><br>  &#x2F;&#x2F;不写实参调用event<br>  function eventTest(){<br>      var event &#x3D; window.event || arguments[0];<br>  }<br><br>  &#x2F;&#x2F;传入额外实参<br>  function eventTest(a,b){<br>      var event &#x3D; window.event || arguments.callee.caller.arguments[0];<br>  }<br>  &#x2F;&#x2F;如果传入了参数却如第二种写法的话，则arguments中将会传入已经传入的参数，<br>          &#x2F;&#x2F;这时获取的arguments[0]就会是第一个传入的参数</li></ul></li></ul><h3 id="基本事件对象"><a href="#基本事件对象" class="headerlink" title="基本事件对象"></a>基本事件对象</h3><ul><li>静态变量</li></ul><table><thead><tr><th>静态变量</th><th>描述</th></tr></thead><tbody><tr><td>CAPTURING-PHASE</td><td>当前事件阶段为捕获阶段(1)</td></tr><tr><td>AT-TARGET</td><td>当前事件是目标阶段,在评估目标事件(1)</td></tr><tr><td>BUBBLING-PHASE</td><td>当前的事件为冒泡阶段 (3)</td></tr></tbody></table><ul><li>属性</li></ul><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>bubbles</td><td>返回布尔值，指示事件是否是起泡事件类型</td></tr><tr><td>cancelable</td><td>返回布尔值，指示事件是否可拥可取消的默认动作</td></tr><tr><td>currentTarget</td><td>返回其事件监听器触发该事件的元素</td></tr><tr><td>eventPhase</td><td>返回事件传播的当前阶段</td></tr><tr><td>target</td><td>返回触发此事件的元素（事件的目标节点）不兼容低版本IE，低版本IE用srcElement</td></tr><tr><td>timeStamp</td><td>返回事件生成的日期和时间</td></tr><tr><td>type</td><td>返回当前 Event 对象表示的事件的名称</td></tr></tbody></table><ul><li>方法</li></ul><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>initEvent()</td><td>初始化新创建的 Event 对象的属性</td></tr><tr><td>preventDefault()</td><td>通知浏览器不要执行与事件关联的默认动作</td></tr><tr><td>stopPropagation()</td><td>不再派发事件</td></tr></tbody></table><h3 id="目标事件对象"><a href="#目标事件对象" class="headerlink" title="目标事件对象"></a>目标事件对象</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>addEventListener()</td><td>允许在目标事件中注册监听事件(IE8 &#x3D; attachEvent())</td></tr><tr><td>dispatchEvent()</td><td>允许发送事件到监听器上 (IE8 &#x3D; fireEvent())</td></tr><tr><td>removeEventListener()</td><td>运行一次注册在事件目标上的监听事件(IE8 &#x3D; detachEvent())</td></tr></tbody></table><h3 id="事件监听对象"><a href="#事件监听对象" class="headerlink" title="事件监听对象"></a>事件监听对象</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>handleEvent()</td><td>把任意对象注册为事件处理程序</td></tr></tbody></table><h3 id="文档事件对象"><a href="#文档事件对象" class="headerlink" title="文档事件对象"></a>文档事件对象</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>createEvent()</td><td>返回新创建的event对象</td></tr></tbody></table><h3 id="鼠标-键盘事件对象"><a href="#鼠标-键盘事件对象" class="headerlink" title="鼠标&#x2F;键盘事件对象"></a>鼠标&#x2F;键盘事件对象</h3><ul><li>属性</li></ul><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>altKey</td><td>返回当事件被触发时，”ALT” 是否被按下</td></tr><tr><td>button</td><td>返回当事件被触发时，哪个鼠标按钮被点击</td></tr><tr><td>clientX</td><td>返回当事件被触发时，鼠标指针的水平坐标</td></tr><tr><td>clientY</td><td>返回当事件被触发时，鼠标指针的垂直坐标</td></tr><tr><td>ctrlKey</td><td>返回当事件被触发时，”CTRL” 键是否被按下</td></tr><tr><td>Location</td><td>返回按键在设备上的位置</td></tr><tr><td>charCode</td><td>返回onkeypress事件触发键值的字母代码</td></tr><tr><td>key</td><td>在按下按键时返回按键的标识符</td></tr><tr><td>keyCode</td><td>返回onkeypress事件触发的键的值的字符代码，或者 onkeydown 或 onkeyup 事件的键的代码</td></tr><tr><td>which</td><td>返回onkeypress事件触发的键的值的字符代码，或者 onkeydown 或 onkeyup 事件的键的代码</td></tr><tr><td>metaKey</td><td>返回当事件被触发时，”meta” 键是否被按下</td></tr><tr><td>relatedTarget</td><td>返回与事件的目标节点相关的节点</td></tr><tr><td>screenX</td><td>返回当某个事件被触发时，鼠标指针的水平坐标</td></tr><tr><td>screenY</td><td>返回当某个事件被触发时，鼠标指针的垂直坐标</td></tr><tr><td>shiftKey</td><td>返回当事件被触发时，”SHIFT” 键是否被按下</td></tr></tbody></table><ul><li>方法</li></ul><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>initMouseEvent()</td><td>初始化鼠标事件对象的值</td></tr><tr><td>initKeyboardEvent()</td><td>初始化键盘事件对象的值</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>DOM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>DOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DOM介绍</title>
    <link href="/2021/04/27/DOM/DOM/"/>
    <url>/2021/04/27/DOM/DOM/</url>
    
    <content type="html"><![CDATA[<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><ul><li>DOM全称Document Object Model(文档对象模型)<ul><li>文档:整个HTML网页文档对象</li><li>对象:网页中的每一个部分都被转换为了一个对象</li><li>模型:使用模型表示对象之间的关系，方便我们获取对象</li></ul></li></ul><span id="more"></span><hr><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><ul><li><strong>Node(节点)是构成HTML5的基本单元</strong>，DOM节点主要分为四类<ul><li><strong>文档节点</strong>:整个HTML文档</li><li><strong>元素节点</strong>:HTML文档中的HTML标签</li><li><strong>属性节点</strong>:元素的属性</li><li><strong>文本节点</strong>:HTML标签中的文本内容</li></ul></li></ul><table><thead><tr><th align="center">节点</th><th align="center">nodeName(节点名)</th><th align="center">nodeType(节点类型)</th><th align="center">nodeValue(节点值)</th></tr></thead><tbody><tr><td align="center">文档节点</td><td align="center">#document</td><td align="center">9</td><td align="center">null</td></tr><tr><td align="center">元素节点</td><td align="center">标签名</td><td align="center">1</td><td align="center">null</td></tr><tr><td align="center">属性节点</td><td align="center">属性名</td><td align="center">2</td><td align="center">属性值</td></tr><tr><td align="center">文本节点</td><td align="center">#text</td><td align="center">3</td><td align="center">文本内容</td></tr></tbody></table><ul><li>浏览器已经为我们提供了文档节点对象window,该对象可以在页面中直接使用,代表的是整个网页 </li><li>通过nodeType&#x3D;&#x3D;&#x3D;1可以判断某节点是否是元素节点 </li><li>文本节点包含了在写代码时的回车换行符间产生的空白，但是IE8及以下的浏览器中不会将空白节点当作子节点，而其他浏览器会</li><li>通过nodeName返回的标签名是全大写的 </li><li>元素节点的名字也可以通过专门的TagName属性获得</li></ul><hr><h3 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h3><ul><li>事件是用户和浏览器之间的交互行为</li></ul><h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>onclick</td><td>当用户点击某个对象时调用的事件句柄。单击鼠标左键或者按下回车键时触发,意味着onclick事件处理程序既可以通过键盘也可以通过鼠标执行</td></tr><tr><td>oncontextmenu</td><td>在用户点击鼠标右键打开上下文菜单时触发。可以用做自定义菜单</td></tr><tr><td>ondblclick</td><td>当用户双击某个对象时调用的事件句柄。双击鼠标左键时触发</td></tr><tr><td>onmousedown</td><td>鼠标按钮被按下。</td></tr><tr><td>onmouseenter</td><td>当鼠标指针移动到元素上时触发。该事件不冒泡，即鼠标移到其后代元素上时不会触发</td></tr><tr><td>onmouseleave</td><td>当鼠标指针移出元素时触发。该事件不冒泡，即鼠标移出其后代元素时不会触发。</td></tr><tr><td>onmousemove</td><td>鼠标被移动。</td></tr><tr><td>onmouseover</td><td>鼠标移到某元素之上。鼠标移到其后代元素上时会触发,意味着支持冒泡</td></tr><tr><td>onmouseout</td><td>鼠标从某元素移开。支持冒泡</td></tr><tr><td>onmouseup</td><td>鼠标按键被松开</td></tr></tbody></table><h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>onkeydown</td><td>某个键盘按键被按下</td></tr><tr><td>onkeypress</td><td>某个键盘按键被按下并松开</td></tr><tr><td>onkeyup</td><td>某个键盘按键被松开</td></tr></tbody></table><h4 id="框架-对象事件"><a href="#框架-对象事件" class="headerlink" title="框架&#x2F;对象事件"></a>框架&#x2F;对象事件</h4><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>onabort</td><td>图像的加载被中断。( <code>&lt;object&gt;)</code></td></tr><tr><td>onbeforeunload</td><td>该事件在即将离开页面（刷新或关闭）时触发 onerror 在加载文档或图像时发生错误。 ( <object>, <body>和 <frameset>)</td></tr><tr><td>onhashchange</td><td>该事件在当前 URL 的锚部分发生修改时触发</td></tr><tr><td>onload</td><td>一张页面或一幅图像完成加载</td></tr><tr><td>onpageshow</td><td>该事件在用户访问页面时触发</td></tr><tr><td>onpagehide</td><td>该事件在用户离开当前网页跳转到另外一个页面时触发</td></tr><tr><td>onresize</td><td>窗口或框架被重新调整大小。(由window调用)</td></tr><tr><td>onscroll</td><td>当文档被滚动时发生的事件</td></tr><tr><td>onunload</td><td>用户退出页面。 (<code>&lt;body&gt; </code>和 <code>&lt;frameset&gt;)</code></td></tr></tbody></table><h4 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h4><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>onblur</td><td>元素失去焦点时触发</td></tr><tr><td>onchange</td><td>该事件在表单元素的内容改变时触发( <code>&lt;input&gt;</code>, <code>&lt;keygen&gt;</code>, <code>&lt;select&gt;</code>, 和 <code>&lt;textarea&gt;</code>)</td></tr><tr><td>onfocus</td><td>元素获取焦点时触发</td></tr><tr><td>onfocusin</td><td>元素即将获取焦点时触发</td></tr><tr><td>onfocusout</td><td>元素即将失去焦点时触发</td></tr><tr><td>oninput</td><td>元素获取用户输入时触发</td></tr><tr><td>onreset</td><td>表单重置时触发</td></tr><tr><td>onsearch</td><td>用户向搜索域输入文本时触发 ( <code>&lt;input=&quot;search&quot;&gt;</code>)</td></tr><tr><td>onselect</td><td>用户选取文本时触发 ( <code>&lt;input&gt;</code>和<code>&lt;textarea&gt;)</code></td></tr><tr><td>onsubmit</td><td>表单提交时触发</td></tr></tbody></table><h4 id="剪贴板事件"><a href="#剪贴板事件" class="headerlink" title="剪贴板事件"></a>剪贴板事件</h4><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>oncopy</td><td>该事件在用户拷贝元素内容时触发</td></tr><tr><td>oncut</td><td>该事件在用户剪切元素内容时触发</td></tr><tr><td>onpaste</td><td>该事件在用户粘贴元素内容时触发</td></tr></tbody></table><h4 id="打印事件"><a href="#打印事件" class="headerlink" title="打印事件"></a>打印事件</h4><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>onafterprint</td><td>该事件在页面已经开始打印，或者打印窗口已经关闭时触发</td></tr><tr><td>onbeforeprint</td><td>该事件在页面即将开始打印时触发</td></tr></tbody></table><h4 id="拖动事件"><a href="#拖动事件" class="headerlink" title="拖动事件"></a>拖动事件</h4><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>ondrag</td><td>该事件在元素正在拖动时触发</td></tr><tr><td>ondragend</td><td>该事件在用户完成元素的拖动时触发</td></tr><tr><td>ondragenter</td><td>该事件在拖动的元素进入放置目标时触发</td></tr><tr><td>ondragleave</td><td>该事件在拖动元素离开放置目标时触发</td></tr><tr><td>ondragover</td><td>该事件在拖动元素在放置目标上时触发</td></tr><tr><td>ondragstart</td><td>该事件在用户开始拖动元素时触发</td></tr><tr><td>ondrop</td><td>该事件在拖动元素放置在目标区域时触发</td></tr></tbody></table><h4 id="多媒体事件"><a href="#多媒体事件" class="headerlink" title="多媒体事件"></a>多媒体事件</h4><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>onabort</td><td>事件在视频&#x2F;音频（audio&#x2F;video）终止加载时触发</td></tr><tr><td>oncanplay</td><td>事件在用户可以开始播放视频&#x2F;音频（audio&#x2F;video）时触发</td></tr><tr><td>oncanplaythrough</td><td>事件在视频&#x2F;音频（audio&#x2F;video）可以正常播放且无需停顿和缓冲时触发</td></tr><tr><td>ondurationchange</td><td>事件在视频&#x2F;音频（audio&#x2F;video）的时长发生变化时触发</td></tr><tr><td>onemptied</td><td>当期播放列表为空时触发</td></tr><tr><td>onended</td><td>事件在视频&#x2F;音频（audio&#x2F;video）播放结束时触发</td></tr><tr><td>onerror</td><td>事件在视频&#x2F;音频（audio&#x2F;video）数据加载期间发生错误时触发</td></tr><tr><td>onloadeddata</td><td>事件在浏览器加载视频&#x2F;音频（audio&#x2F;video）当前帧时触发触发</td></tr><tr><td>onloadedmetadata</td><td>事件在指定视频&#x2F;音频（audio&#x2F;video）的元数据加载后触发</td></tr><tr><td>onloadstart</td><td>事件在浏览器开始寻找指定视频&#x2F;音频（audio&#x2F;video）触发</td></tr><tr><td>onpause</td><td>事件在视频&#x2F;音频（audio&#x2F;video）暂停时触发</td></tr><tr><td>onplay</td><td>事件在视频&#x2F;音频（audio&#x2F;video）开始播放时触发</td></tr><tr><td>onplaying</td><td>事件在视频&#x2F;音频（audio&#x2F;video）暂停或者在缓冲后准备重新开始播放时触发</td></tr><tr><td>onprogress</td><td>事件在浏览器下载指定的视频&#x2F;音频（audio&#x2F;video）时触发</td></tr><tr><td>onratechange</td><td>事件在视频&#x2F;音频（audio&#x2F;video）的播放速度发送改变时触发</td></tr><tr><td>onseeked</td><td>事件在用户重新定位视频&#x2F;音频（audio&#x2F;video）的播放位置后触发</td></tr><tr><td>onseeking</td><td>事件在用户开始重新定位视频&#x2F;音频（audio&#x2F;video）时触发</td></tr><tr><td>onstalled</td><td>事件在浏览器获取媒体数据，但媒体数据不可用时触发</td></tr><tr><td>onsuspend</td><td>事件在浏览器读取媒体数据中止时触发</td></tr><tr><td>ontimeupdate</td><td>事件在当前的播放位置发送改变时触发</td></tr><tr><td>onvolumechange</td><td>事件在音量发生改变时触发</td></tr><tr><td>onwaiting</td><td>事件在视频由于要播放下一帧而需要缓冲时触发</td></tr></tbody></table><h4 id="动画事件"><a href="#动画事件" class="headerlink" title="动画事件"></a>动画事件</h4><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>animationend</td><td>该事件在 CSS 动画结束播放时触发</td></tr><tr><td>animationiteration</td><td>该事件在 CSS 动画重复播放时触发</td></tr><tr><td>animationstart</td><td>该事件在 CSS 动画开始播放时触发</td></tr></tbody></table><h4 id="过渡事件"><a href="#过渡事件" class="headerlink" title="过渡事件"></a>过渡事件</h4><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>transitionend</td><td>该事件在 CSS 完成过渡后触发</td></tr></tbody></table><h4 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h4><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>onmessage</td><td>该事件通过或者从对象(WebSocket, Web Worker, Event Source 或者子 frame 或父窗口)接收到消息时触发</td></tr><tr><td>onmousewheel</td><td>已废弃。 使用 onwheel事件替代</td></tr><tr><td>ononline</td><td>该事件在浏览器开始在线工作时触发</td></tr><tr><td>onoffline</td><td>该事件在浏览器开始离线工作时触发</td></tr><tr><td>onpopstate</td><td>该事件在窗口的浏览历史（history 对象）发生改变时触发</td></tr><tr><td>onshow</td><td>该事件当 <code>&lt;menu&gt;</code> 元素在上下文菜单显示时触发 onstorage 该事件在 Web Storage(HTML 5 Web 存储)更新时触发</td></tr><tr><td>ontoggle</td><td>该事件在用户打开或关闭 <code>&lt;details&gt;</code>元素时触发</td></tr><tr><td>onwheel</td><td>该事件在鼠标滚轮在元素上下滚动时触发</td></tr><tr><td>DOMMouseScroll</td><td>火狐(firefox)支持的绑定鼠标滚轮的事件，并且该事件必须要通过addEventListener()函数来绑定事件</td></tr><tr><td>DOMContentLoaded</td><td>监听文档DOM元素的内容是否加载完成，比onload事件要监听的东西更少，DOM元素加载完毕后就会执行该事件,通过addEventListener()函数来绑定事件</td></tr></tbody></table><hr><h3 id="DOM查询"><a href="#DOM查询" class="headerlink" title="DOM查询"></a>DOM查询</h3><h4 id="获取DOM节点"><a href="#获取DOM节点" class="headerlink" title="获取DOM节点"></a>获取DOM节点</h4><ul><li><code>getElementById()</code> 通过ID获取元素节点，返回一个普通对象 <ul><li><strong>注意:</strong> ID其实可以不用获取而直接使用,因为ID是具有唯一性的,但是不推荐不获取就直接使用ID，因为以后会很难区分这个变量是哪里来的</li></ul></li><li><code>getElementsByTagName()</code>  可以根据标签名来获取一组元素节点对象，这个方法会给我们返回一个类数组对象，所有查询到的元素都会封装到对象中，即使查询到的元素只有一个，也会封装到数组中返回</li><li><code>getElementsByClassName()</code> 方法通过类名获取元素节点(IE8及以下版本不支持),返回一个类数组对象</li><li><code>getElementsByName()</code> 方法通过name属性获取元素节点，这个方法主要是获取表单项，返回一个类数组对象</li><li><code>quertSelector()</code> 方法需要一个选择器的字符串作为参数,可以根据一个CSS选择器来查询一个元素节点对象，语法和CSS语法一样，可以多个选择器一起使用，该方法在IE8也可用<ul><li>**注意:**使用该方法总会返回唯一的一个元素，如果满足条件的元素有多个，也只会返回第一个找到的</li></ul></li><li><code>quertSelectorAll()</code> 方法用法同quertSelector()方法相同<ul><li>**注意:**使用该方法就返回一个类数组对象，类数组对象里包含的所有符号要求的元素对象,即使符合条件的元素只有一个，也会返回类数组</li></ul></li></ul><h4 id="获取属性节点"><a href="#获取属性节点" class="headerlink" title="获取属性节点"></a>获取属性节点</h4><pre><code class="hljs">- 读取元素的属性节点,使用 元素.属性名 或 元素[属性名] - 修改元素的属性节点,使用 元素.属性名=新值 或 元素[属性名]=新值     - **注意:** 读取元素的class属性时必须用className来代替class关键字</code></pre><h4 id="获取文本节点"><a href="#获取文本节点" class="headerlink" title="获取文本节点"></a>获取文本节点</h4><ul><li><code>innerHTML</code> 属性可以获取双标签元素内部的html代码，包括子标签,这个属性对于单标签元素(如表单标签)没有意义，返回一个字符串 </li><li><code>InnerText</code> 属性可以获取双标签元素内部的文本内容，它和InnerHTML属性类似，但会自动将HTML标签去除，返回一个字符串 </li><li><code>value</code>属性可以获取单标签元素(如表单标签)内部的内容，同时要向单标签元素写入内容也必须使用value属性，返回一个字符串 </li><li><code>nodeValue</code> 属性通过获取标签内的文本节点的内容来获取元素内部的文本内容(因为文本节点实际是一个标签的子节点，所以需要先找到文本节点，返回一个字符串</li></ul><h4 id="获取元素子节点"><a href="#获取元素子节点" class="headerlink" title="获取元素子节点"></a>获取元素子节点</h4><ul><li><code>childNodes</code>属性获取元素子节点，该属性会获取包括文本节点的所有子节点，返回一个类数组对象 </li><li><code>children</code> 属性可以获取当前元素的所有子元素，推荐用这个属性，返回一个类数组对象，而且是动态获取</li><li><code>firstChild</code> 属性表示当前节点的第一个子节点，也包括空白文本，返回一个普通对象</li><li><code>firstElementChild</code> 属性获取第一个子元素，返回一个普通对象，但是不兼容IE8，不推荐使用</li><li><code>getElementsByTagName()</code> 方法获取当前节点下一组元素节点，返回一个类数组对象</li><li>注：<ul><li>参数值 “ * “ 返回元素的所有子元素</li><li>document对象调用该方法，相当于获取整个文档中的元素节点</li></ul></li></ul><h4 id="获取父和兄弟节点"><a href="#获取父和兄弟节点" class="headerlink" title="获取父和兄弟节点"></a>获取父和兄弟节点</h4><ul><li><code>parentElement</code> 属性获取当前节点的父元素(只在IE中可用) </li><li><code>parentNode</code> 属性获取当前节点的父节点,这是W3C标准的,推荐使用 </li><li><code>offsetParent</code>属性获取到离当前元素最近的开启了定位(除去默认的static)的祖先元素，如果所以的祖先元素都没有开启定位，则会返回body </li><li><code>previousSibling</code> 属性获取当前节点的前一个兄弟节点<ul><li>**注意:**可能获取空白文本，如果两个元素中间有空白就会获取空白文本节点</li></ul></li><li><code>previosElementSibling</code> 属性获取前一个元素，IE8不支持 </li><li><code>nextSibiling</code> 属性表示当前节点的后一个兄弟节点 </li><li><code>nextElementSibling</code> 获取后一个元素，IE8不支持</li></ul><h4 id="获取元素节点的内容"><a href="#获取元素节点的内容" class="headerlink" title="获取元素节点的内容"></a>获取元素节点的内容</h4><ul><li><code>innerHTML</code>和<code>innerText</code> 属性<ul><li>这两个属性并没有在DOM标准定义，但是大部分浏览器都支持这两个属性</li><li>两个属性作用类似，都可以获取到标签内部的内容，<ul><li>不同是innerHTML会获取到html标签，而innerText会自动去除标签</li></ul></li><li>如果使用这两个属性来设置标签内部的内容时，没有任何区别的</li></ul></li><li><code>nodeValue</code> 属性设置或返回指定节点的节点值</li><li><strong>注</strong>：如果您希望返回元素的文本，请记住文本始终位于文本节点中，并且您必须返回文本节点的值<br>  element.childNodes[0].nodeValue</li></ul><h4 id="document对象的其他的属性和方法"><a href="#document对象的其他的属性和方法" class="headerlink" title="document对象的其他的属性和方法"></a>document对象的其他的属性和方法</h4><ul><li><code>document.all</code> 获取页面中的所有元素，相当于document.getElementsByTagName(“*”);</li><li><code>document.documentElement</code> 获取页面中html根元素</li><li><code>document.body</code> 获取页面中的body元素</li></ul><h3 id="DOM修改"><a href="#DOM修改" class="headerlink" title="DOM修改"></a>DOM修改</h3><h4 id="创建元素节点"><a href="#创建元素节点" class="headerlink" title="创建元素节点"></a>创建元素节点</h4><ul><li><p><code>document.createElement()</code> 方法可以根据标签名创建一个元素节点对象</p><ul><li>它需要一个标签名作为参数，将会根据该标签名创建元素节点对象，并将创建好的对象作为返回值返回<br>  var div&#x3D;document.createElement(“div”);</li></ul></li><li><p><code>document.createTextNode()</code> 可以根据文本内容创建一个文本节点对象</p><ul><li>需要一个文本内容作为参数，将会根据该内容创建文本节点，并将新节点返回<br>  var divText &#x3D; doucment.createTextNote(“adc”);</li></ul></li></ul><h4 id="添加元素节点"><a href="#添加元素节点" class="headerlink" title="添加元素节点"></a>添加元素节点</h4><ul><li><code>父节点.appendChild()</code> 向父节点中添加指定的子节点<ul><li>要添加子节点之前必须要先有这个子节点，没有就要先创建，并且新加的子节点会自动添加到所有子节点的最后面</li></ul></li><li><code>父节点.insertBefore()</code> 将一个新的节点插入到旧节点的前边<ul><li>该方法由父节点调用,传入两个参数(新节点和旧节点),第一个参数必填，第二个参数可选<br>  父节点.insertBefore(新节点, 旧节点);</li><li>要添加子节点之前必须要先有这个子节点，没有就要先创建，并且如果没有传入第二个参数会自动添加到所有子节点的最后面 </li><li>如果子节点不是新创建而是从原有父级节点上调用的，那么在用insertBefore()方法时会先将原有父级节点上的该子节点删除</li></ul></li></ul><h4 id="替换元素节点"><a href="#替换元素节点" class="headerlink" title="替换元素节点"></a>替换元素节点</h4><ul><li><code>父节点.replaceChild()</code> 使用一个新的节点去替换旧节点<ul><li>要替换子节点之前必须要先有这个新的子节点，没有就要先创建<br>  父节点.replaceChild(新节点,旧节点)</li></ul></li></ul><h4 id="删除元素节点"><a href="#删除元素节点" class="headerlink" title="删除元素节点"></a>删除元素节点</h4><ul><li><code>父节点.removeChild()</code><ul><li>删除指定的子节点</li><li>推荐方式：<code>子节点.parentNode.removeChild(子节点)</code></li></ul></li></ul><h3 id="元素样式"><a href="#元素样式" class="headerlink" title="元素样式"></a>元素样式</h3><h4 id="修改元素样式"><a href="#修改元素样式" class="headerlink" title="修改元素样式"></a>修改元素样式</h4><ul><li>通过<code>style</code>属性修改元素样式<ul><li><p>语法：元素.style.样式名 &#x3D; 样式值<br>  <strong>注：</strong></p></li><li><p>通过style属性设置的样式都是<strong>内联样式</strong>，而内联样式有较高的优先级，所以通过JS修改的样式往往会立即显示</p></li><li><p>但是如果在样式中写了!important，则此时样式会有最高的优先级，即使通过JS也不能覆盖该样式，此时将会导致JS修改样式失效</p></li><li><p>如果CSS的样式名中含有 - ，这种名称在JS中是不合法的比如background-color，需要将这种样式名修改为驼峰命名法，去掉 - ，然后将 - 后的字母大写，如background-color写作backgroundColor，border-top-width写作borderTopWidth</p></li><li><p>通过JS的style属性设置和读取的都是内联样式，无法读取CSS样式表中的样式(外部样式和嵌套样式)</p></li></ul></li></ul><h4 id="读取元素样式"><a href="#读取元素样式" class="headerlink" title="读取元素样式"></a>读取元素样式</h4><ul><li><p><code>元素.currentStyle.样式名</code></p><ul><li>它可以用来读取当前元素正在显示的样式，如果当前元素没有设置该样式，则获取它的默认值，如：width返回auto</li><li>注：currentStyle<strong>只有IE浏览器支持，其他的浏览器都不支持</strong><br>  #box1{<br>  width: 100px;<br>  height: 100px;<br>  }<br><br>  var box1 &#x3D; document.getElementById(“box1”); &#x2F;&#x2F;获取box1元素<br>  alert(box1.currentStyle.width);&#x2F;&#x2F;100px<br>  alert(box1.currentStyle.backgroundColor);&#x2F;&#x2F;transparent</li></ul></li><li><p><code>getComputedStyle()</code></p><ul><li>获取元素当前的样式，这个方法是window的方法，可以直接使用，但是该方法<strong>不支持IE8及以下的浏览器</strong></li><li>需要两个参数<ul><li>第一个：要获取样式的元素</li><li>第二个：可以传递一个伪元素，一般都传null</li></ul></li><li>该方法会返回一个对象，对象中封装了当前元素对应的样式，可以通过<strong>对象.样式名</strong>来读取样式，如果获取的样式没有设置，则会获取到真实的值，而不是默认值，比如：没有设置width，它不会获取到auto，而是一个长度<br>  #box1 {<br>      width: 100px;<br>      height: 200px;<br>      background-color: #bfa;<br>  }<br><br>  var box1 &#x3D; document.getElementById(“box1”);<br>  var objBox1 &#x3D; getComputedStyle(box1, null);<br>  alert(objBox1.width);&#x2F;&#x2F;100px</li></ul></li><li><p><strong>注意:</strong> 通过currentStyle属性和getComputedStyle()方法读取到的样式都是只读的，不能修改，如果要修改必须通过style属性</p></li><li><p><strong>二者的兼容写法</strong><br>  function getStyle(obj , name){<br>      &#x2F;*<br>          参数:obj 要获取样式的元素<br>              name 要获取的样式名<br>      *&#x2F;<br>      if(window.getComputedStyle){ &#x2F;&#x2F;这里的getComputedStyle函数实际上是一个对象，如果有则返回true，<br>                  而这里使用window对象调用，是在全局作用域中寻找是否含有这个对象没有则返回false（相当于ie没有该对象），<br>                  而如果不通过window对象调用的话，在局部作用域中调用会找不到这个对象，返回一个undefined<br>          &#x2F;&#x2F;正常浏览器的方式，具有getComputedStyle()方法<br>          return getComputedStyle(obj , null)[name];<br>      }<br>      else{<br>          &#x2F;&#x2F;IE8的方式，没有getComputedStyle()方法<br>          return obj.currentStyle[name];<br>      }<br>      &#x2F;&#x2F;当然if的对象也可以反过来，但是如果判断obj.currentStyle有问题在于IE8以上的IE浏览器两种方法都有，<br>          这样它就会优先使用第一个方法，但是我们推荐优先使用getComputedStyle()<br><br>      &#x2F;&#x2F;简洁写法，三目运算符<br>      &#x2F;&#x2F;return window.getComputedStyle?getComputedStyle(obj , null)[name]:obj.currentStyle[name];<br><br>  }</p></li></ul><h4 id="获取特殊样式"><a href="#获取特殊样式" class="headerlink" title="获取特殊样式"></a>获取特殊样式</h4><ul><li><p><strong>注: 以下获取的样式都是只读的,不能够修改</strong></p></li><li><p><code>clientWidth</code> 与 <code>clientHeight</code></p><ul><li>这两个属性可以获取元素的可见宽度和高度</li><li>这些属性都是不带px的，返回都是一个number类型，可以直接进行计算</li><li>会获取元素宽度和高度，包括内容区和内边距</li></ul></li><li><p><code>offsetWidth</code> 与 <code>offsetHeight</code></p><ul><li>获取元素的整个宽度和高度(内容区，内边距和边框)，返回值也是number类型</li></ul></li><li><p><code>offsetParent</code></p><ul><li>可以用来获取当前元素的定位父元素</li><li>会获取到离当前元素最近的开启了定位的祖先元素，如果所有的祖先元素都没有开启定位，则返回body</li></ul></li><li><p><code>offsetLeft</code> 与 <code>offsetTop</code></p><ul><li>获取当前元素相对于其定位父元素的水平偏移量和垂直偏移量</li><li><strong>注意：</strong>偏移量的原点是父元素的左上角(left top)，和背景图片的原点相同</li></ul></li><li><p><code>window.innerWidth</code> 与 <code>window.innerHeight</code></p><ul><li>可以获取window窗口的内部宽高</li><li><strong>注意：</strong>不包括页面的导航栏以及页面滚动条和控制台</li></ul></li><li><p><code>scrollWidth</code> 与 <code>scrollHeight</code></p><ul><li>可以获取元素整个滚动区域的宽度和高度，如果没有隐藏的部分则等于clientWidth和clientHeight</li></ul></li><li><p><code>scrollLeft</code> 与 <code>scrollTop</code></p><ul><li>可以获取水平和垂直滚动条滚动的距离<br>  当满足 scrollHeight - scrollTop &#x3D;&#x3D; clientHeight，说明垂直滚动条滚动到底了（实际高度 - 滚动高度 &#x3D;&#x3D; 可视高度）<br>  当满足 scrollWidth - scrollLeft &#x3D;&#x3D; clientWidth，说明水平滚动条滚动到底</li></ul></li><li><p>实例<br>  <!DOCTYPE html><br>  <html lang="en"><br>  <head><br>      <meta charset="UTF-8"><br>      <meta name="viewport" content="width=device-width, initial-scale=1.0"><br>      <title>Document</title><br>      <script><br>          window.onload = function () {<br>              var info = document.getElementById("info");<br>              var input = document.getElementsByTagName("input");<br>              info.onscroll = function () {<br>                  if (info.scrollHeight - Math.round(info.scrollTop) == info.clientHeight) {//判断滚动条是否到底<br>                      input[0].disabled = false;//checkbox变为可选项<br><br>                      input[0].onclick = function () {//勾选checkbox时<br>                          if (input[0].checked == true) {<br>                              input[1].disabled = false;<br>                          }<br>                          else{<br>                              input[1].disabled = true;<br>                          }<br>                      }<br>                  }<br>              }<br>          }<br>      </script><br><br>      <style><br>          #info{<br>              width: 200px;<br>              height: 300px;<br>              background-color: #bbffaa;<br>              overflow: auto;<br>          }<br>      </style><br>  </head><br>  <body><br>      <div id="box"><br>          <p id="info">亲爱的用户，请仔细阅读以下协议，如果你不仔细阅读你就别注册<br>              </p><br>              <input type="checkbox" name="c" id="check" disabled="disabled">我已阅读<br>              <input type="button" value="注册" disabled="disabled" ><br>      </div><br>  </body><br>  </html></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>DOM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
      <tag>DOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串方法</title>
    <link href="/2021/04/27/javaScript/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95/"/>
    <url>/2021/04/27/javaScript/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="字符串的相关方法"><a href="#字符串的相关方法" class="headerlink" title="字符串的相关方法"></a>字符串的相关方法</h2><ul><li>在底层字符串是以字符数组的形式保存的<br>  var str &#x3D; “abc”;&#x2F;&#x2F; [“a”,”b”,”c”]</li><li>length属性<ul><li>可以用来获取字符串的长度<br>  console.log(str.length); &#x2F;&#x2F;输出字符串str的长度</li></ul></li></ul><span id="more"></span><h3 id="charAt"><a href="#charAt" class="headerlink" title="charAt()"></a>charAt()</h3><ul><li>可以返回字符串中指定位置的字符</li><li>根据索引获取指定的字符<br>  var str &#x3D; “aBcd”;<br><br>  console.log(str.charAt(2)); &#x2F;&#x2F;c<br>  console.log(str[2]); &#x2F;&#x2F;c</li></ul><h3 id="charCodeAt"><a href="#charCodeAt" class="headerlink" title="charCodeAt()"></a>charCodeAt()</h3><ul><li>获取指定位置字符的字符编码（Unicode编码）<br>  var str &#x3D; “aBcd”;<br>  console.log(str.charCodeAt(1)); &#x2F;&#x2F; 66</li></ul><h3 id="String-formCharCode"><a href="#String-formCharCode" class="headerlink" title="String.formCharCode()"></a>String.formCharCode()</h3><ul><li>可以根据字符编码去获取字符<br>  var str &#x3D; “aBcd”;<br>  console.log(String.fromCharCode(66)); &#x2F;&#x2F; B</li></ul><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><ul><li>可以用来连接两个或多个字符串（不会对改变原字符）</li><li>作用和 + 一样<br>  var str &#x3D; “aBcd”;<br>  var str2 &#x3D; “EfG”;<br><br>  console.log(str.concat(str2, )); &#x2F;&#x2F; aBcdEfG<br>  console.log(str); &#x2F;&#x2F; aBcd<br>  console.log(str.concat(str2, “123”)); &#x2F;&#x2F; aBcdEfG123</li></ul><h3 id="indexof"><a href="#indexof" class="headerlink" title="indexof()"></a>indexof()</h3><ul><li>该方法可以检索一个字符串中是否含有指定内容<ul><li>如果字符串中含有该内容，则会返回其第一次出现的索引,如果没有找到指定的内容，则返回-1</li><li>可以指定一个第二个参数，指定开始查找的位置<br>  var str &#x3D; “Abc abcd”;<br>  console.log(str.indexOf(“b”));&#x2F;&#x2F; 1<br>  console.log(str.indexOf(“b”, 2)); &#x2F;&#x2F; 5 从第二个位置开始查找</li></ul></li></ul><h3 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h3><ul><li>该方法的用法和indexOf()一样，不同的是indexOf是从前往后找，而lastIndexOf是从后往前找<ul><li>可以指定一个第二个参数，指定开始查找的位置<br>  var str &#x3D; “Abc abcd”;<br>  console.log(str.lastIndexOf(“b”)); &#x2F;&#x2F; 5<br>  console.log(str.lastIndexOf(“b”, 4)); &#x2F;&#x2F; 1 从第二个位置开始从后往前查找</li></ul></li></ul><h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><ul><li>可以从字符串中截取指定的内容</li><li>不会影响原字符串，而是将截取到内容返回</li><li>参数：<br>  第一个，开始位置的索引（包括开始位置）<br>  第二个，结束位置的索引（不包括结束位置）<ul><li>如果省略第二个参数，则会截取到后边所有的</li><li>也可以传递一个负数作为参数，负数的话将会从后边计算<br>  str &#x3D; “abcdefghijk”;<br><br>  console.log(str.slice(1,4)); &#x2F;&#x2F;bcd<br>  console.log(str.slice(1,-1)); &#x2F;&#x2F;bcdefghij</li></ul></li></ul><h3 id="substring"><a href="#substring" class="headerlink" title="substring()"></a>substring()</h3><ul><li>可以用来截取一个字符串，可以slice()类似</li><li>参数：<ul><li>第一个：开始截取位置的索引（包括开始位置）</li><li>第二个：结束位置的索引（不包括结束位置）</li><li>不同的是这个方法不能接受负值作为参数，如果传递了一个负值，则默认使用0，而且他还自动调整参数的位置，如果第二个参数小于第一个，则自动交换<br>  var str &#x3D; “abcdefghijk”;<br>  console.log(str.substring(0, 2)); &#x2F;&#x2F; ab<br>  console.log(str.substring(2, 0)); &#x2F;&#x2F; ab</li></ul></li></ul><h3 id="substr"><a href="#substr" class="headerlink" title="substr()"></a>substr()</h3><ul><li>用来截取字符串</li><li>参数：<ul><li>第一个：截取开始位置的索引</li><li>第二个：截取的长度<br>  var str &#x3D; “abcdefghijk”;<br>  console.log(str.substr(2, 3)); &#x2F;&#x2F; cde</li></ul></li></ul><h3 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h3><ul><li>可以将一个字符串拆分为一个数组</li><li>参数：<ul><li>需要一个字符串作为参数，将会根据该字符串去拆分数组</li><li>如果传递一个空串作为参数，则会将每个字符都拆分为数组中的一个元素<br>  var str &#x3D; “abcbcdefgdhij”;<br>  console.log(str.split(“d”));  &#x2F;&#x2F; [ ‘abcbc’, ‘efg’, ‘hij’ ]<br><br>  var str2 &#x3D; “abc”;<br>  console.log(str2.split(“”)); &#x2F;&#x2F; [ ‘a’, ‘b’, ‘c’ ]</li></ul></li></ul><h3 id="toUpperCase"><a href="#toUpperCase" class="headerlink" title="toUpperCase()"></a>toUpperCase()</h3><ul><li>将一个字符串转换为大写并返回<br>  var str &#x3D; “Abc”;<br>  console.log(str.toUpperCase()); &#x2F;&#x2F; ABC</li></ul><h3 id="toLowerCase"><a href="#toLowerCase" class="headerlink" title="toLowerCase()"></a>toLowerCase()</h3><ul><li>将一个字符串转换为小写并返回<br>  var str &#x3D; “Abc”;<br>  console.log(str.toLowerCase()); &#x2F;&#x2F; abc</li></ul>]]></content>
    
    
    <categories>
      
      <category>javaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2021/04/27/javaScript/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/04/27/javaScript/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>正则表达式用于定义一些字符串的规则，计算机可以根据正则表达式，来检查一个字符串是否符合规则，获取将字符串中符合规则的内容提取出来</p><span id="more"></span><h2 id="创建正则表达式的对象"><a href="#创建正则表达式的对象" class="headerlink" title="创建正则表达式的对象"></a>创建正则表达式的对象</h2><h3 id="构造函数方式构造"><a href="#构造函数方式构造" class="headerlink" title="构造函数方式构造"></a>构造函数方式构造</h3><ul><li>语法：<br>var 变量 &#x3D; new RegExp(“正则表达式”,”匹配模式”);<br>  var reg &#x3D; new RegExp(“a”); &#x2F;&#x2F;这个正则表达式可以来检查一个字符串中是否含有a<br>  var reg &#x3D; new RegExp(“a”, “i”); &#x2F;&#x2F;不区分大小写</li><li>使用typeof检查正则对象，会返回object</li><li>在构造函数中可以传递一个匹配模式作为第二个参数，可以是<br>  i 忽略大小写<br>  g 全局匹配模式</li></ul><h3 id="使用字面量来创建"><a href="#使用字面量来创建" class="headerlink" title="使用字面量来创建"></a>使用字面量来创建</h3><ul><li><pre><code class="hljs">语法：</code></pre>  var 变量 &#x3D; &#x2F;正则表达式&#x2F;匹配模式<br>     var reg &#x3D; &#x2F;a&#x2F;;  &#x2F;&#x2F;等价于var reg &#x3D; new RegExp(“a”);<br>     var reg &#x3D; &#x2F;a&#x2F;i; &#x2F;&#x2F;等价于var reg &#x3D; new RegExp(“a”, “i”);</li></ul><h2 id="正则表达式的语法"><a href="#正则表达式的语法" class="headerlink" title="正则表达式的语法"></a>正则表达式的语法</h2><h3 id="使用-或-表示或者的意思"><a href="#使用-或-表示或者的意思" class="headerlink" title="使用 | 或 [] 表示或者的意思"></a>使用 | 或 [] 表示或者的意思</h3><pre><code class="hljs">//下面三个表达式等价var reg = /a|b|c/var reg = /[abc]/var reg = /[a-c]/</code></pre><ul><li>[a-z] 任意小写字母</li><li>[A-Z] 任意大写字母</li><li>[A-z] 任意字母</li><li>[0-9] 任意数字</li><li>[^ ]  非</li></ul><h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><ul><li><p>通过量词可以设置一个内容出现的次数</p></li><li><p>量词只对它前边的一个内容起作用</p><pre><code class="hljs">  &#123;n&#125;正好出现n次  &#123;m,n&#125;出现m-n次  &#123;m,&#125;m次以上  \+至少一个，相当于&#123;1,&#125;  \*0个或多个，相当于&#123;0,&#125;  ?0个或1个，相当于&#123;0,1&#125;</code></pre></li></ul><h3 id="检查一个字符串中开头或结尾"><a href="#检查一个字符串中开头或结尾" class="headerlink" title="检查一个字符串中开头或结尾"></a>检查一个字符串中开头或结尾</h3><ul><li><pre><code class="hljs">^ 表示开头</code></pre></li><li><pre><code class="hljs">$ 表示结尾  var reg = /^a/; //以a开始  var reg = /a$/; //以a结尾</code></pre></li><li><p>如果在正则表达式中同时使用^ $则要求字符串必须完全符合正则表达式</p><pre><code class="hljs">  var reg = /^a&amp;/; //要求正则表达式必须为a</code></pre></li></ul><h3 id="使用-作为转义字符"><a href="#使用-作为转义字符" class="headerlink" title="使用 \ 作为转义字符"></a>使用 \ 作为转义字符</h3><ul><li><code>\\\.</code> 表示 <code>.</code></li><li><code>\\\\</code>  表示 <code>\\</code></li></ul><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><ul><li><p><code>.</code>  单个字符，除了换行和行结束符 </p></li><li><p><code>\w</code> 任意字母、数字、_  [A-z0-9_]</p></li><li><p><code>\W</code> 非字母、数字、_  [^A-z0-9_]</p></li><li><p><code>\d</code> 任意的数字 [0-9]</p></li><li><p><code>\D</code> 非数字 [^0-9]</p></li><li><p><code>\s</code> 空格</p></li><li><p><code>\S</code> 非空格</p></li><li><p><code>\b</code> 单词边界</p></li><li><p><code>\B</code> 非单词边界</p><pre><code class="hljs">  电子邮件  hello  .nihao          @     abc  .com.cn     任意字母数字下划线    .任意字母数字下划线  @   任意字母数字     .任意字母（2-5位）   .任意字母（2-5位）     \w&#123;3,&#125;  (\.\w+)*  @  [A-z0-9]+  (\.[A-z]&#123;2,5&#125;)&#123;1,2&#125;    var emailReg = /^\w&#123;3,&#125;(\.\w+)*@[A-z0-9]+(\.[A-z]&#123;2,5&#125;)&#123;1,2&#125;$/;  var email = &quot;abc.hello@163.com&quot;;  console.log(emailReg.test(email)); //true</code></pre></li></ul><h2 id="正则表达式的方法"><a href="#正则表达式的方法" class="headerlink" title="正则表达式的方法"></a>正则表达式的方法</h2><h3 id="test"><a href="#test" class="headerlink" title="test()"></a>test()</h3><ul><li>使用这个方法可以用来检查一个字符串是否符合正则表达式的规则，如果符合则返回true，否则返回false<br>  var str &#x3D; “abc123”;<br>  var reg &#x3D; new RegExp(“aB”, “i”);<br><br>  console.log(reg.test(str)); &#x2F;&#x2F;true</li></ul><h3 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h3><ul><li>可以将一个字符串拆分为一个数组</li><li>方法中可以传递一个正则表达式作为参数，这样方法将会根据正则表达式去拆分字符串</li><li>这个方法即使不指定全局匹配，也会全都拆分<br>  &#x2F;&#x2F;根据任意字母来将字符串拆分<br>  var str &#x3D; “1a2b3c4d5e6f7”;<br>  console.log(str.split(&#x2F;[A-z]&#x2F;)); &#x2F;&#x2F;[‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’]</li></ul><h3 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h3><ul><li>可以搜索字符串中是否含有指定内容</li><li>如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到返回-1</li><li>它可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串</li><li>serach()只会查找第一个，即使设置全局匹配也没用<br> &#x2F;&#x2F;搜索字符串中是否含有abc 或 aec 或 afc<br> str &#x3D; “hello abc hello aec afc”;<br> console.log(str.search(&#x2F;a[bef]c&#x2F;)); &#x2F;&#x2F;6</li></ul><h3 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h3><ul><li>可以根据正则表达式，从一个字符串中将符合条件的内容提取出来</li><li>默认情况下我们的match只会找到第一个符合要求的内容，找到以后就停止检索<ul><li>我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容</li><li>可以为一个正则表达式设置多个匹配模式，且顺序无所谓</li></ul></li><li>match()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果<br>  var str &#x3D; “1a2a3a4a5e6f7A8B9C”;<br>  &#x2F;&#x2F;提取字符串中所有的字母（不区分大小写）<br>  console.log(str.match(&#x2F;[a-z]&#x2F;ig)); &#x2F;&#x2F;返回值是数组</li></ul><h3 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h3><ul><li>可以将字符串中指定内容替换为新的内容</li><li>参数：<ul><li>第一个：被替换的内容，可以接受一个正则表达式作为参数</li><li>第二个：新的内容</li></ul></li><li>默认只会替换第一个，设置正则表达式为全局匹配模式，这样就会替换到所有符合正则表达式的内容</li><li>第二个参数设为空串，相当于删除匹配到的内容<br>  var str &#x3D; “1a2a3a4a5e6f7A8B9C”;<br>  console.log(str.replace(&#x2F;[a-z]&#x2F;gi, “@”)); &#x2F;&#x2F; 1@2@3@4@5@6@7@8@9@<br>  console.log(str.replace(&#x2F;[a-z]&#x2F;gi, “”));  &#x2F;&#x2F; 123456789</li></ul>]]></content>
    
    
    <categories>
      
      <category>javaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组</title>
    <link href="/2021/04/27/javaScript/%E6%95%B0%E7%BB%84/"/>
    <url>/2021/04/27/javaScript/%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul><li>数组也是一个对象</li><li>普通对象是使用字符串作为属性名的，而数组时使用数字来作为索引操作元素</li><li>数组中的元素可以是任意的数据类型，可以是对象</li></ul><span id="more"></span><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><pre><code class="hljs">- 声明或创建一个不指定长度的数组        var arr = new Array();- 声明或创建一个指定长度的数组        var arr = new Array(10); //创建一个length为10的数组，没有值- 声明或创建一个带有默认值的数组        var arr = new Array(1, 2, 3); //length为3，值为[1, 2, 3]- 使用字面量创建数组        var arr = [1, 2, 3, 4, 5] //length为5，值为[1, 2, 3, 4, 5]        //创建不定长度的数组        var arr2 = [];</code></pre><ul><li><p><strong>读取数组中的元素</strong></p><ul><li>语法：<br> 数组[索引]<br> arr[2]</li><li><pre><code class="hljs">如果读取不存在的索引，他不会报错而是返回undefined</code></pre></li></ul></li><li><p><strong>length</strong></p><ul><li><p>length是数组的一个属性,代表数组的长度</p></li><li><p>获取数组的长度</p><ul><li><p>可以使用length属性来获取数组的长度(元素的个数)</p></li><li><pre><code class="hljs">语法：     数组.length     var arr=[1,2,3]; //arr.length = 3;     console.log(arr.length);//输出数组长度</code></pre></li><li><p>对于连续的数组，使用length可以获取到数组的长度（元素的个数）</p></li><li><p>对于非连续的数组，使用length会获取到数组的最大的索引+1</p></li><li><pre><code class="hljs">尽量不要创建非连续的数组</code></pre></li></ul></li><li><p>修改length</p><ul><li><pre><code class="hljs">如果修改的length大于原长度，则多出部分会空出来</code></pre></li><li>如果修改的length小于原长度，则多出的元素会被删除，所以可以修改length的长度为0来让数组为空</li></ul></li><li><p>向数组的最后一个位置添加元素</p><ul><li>语法：<br>  数组[数组.length] &#x3D; 值;<br><br>  arr[arr.length] &#x3D; 10;</li></ul></li></ul></li></ul><h2 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h2><h3 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h3><pre><code class="hljs">- 该方法可以向数组的末尾添加一个或多个元素，并返回数组的新的长度- 可以将要添加的元素作为方法的参数传递，这样这些元素将会自动添加到数组的末尾- 该方法会将数组新的长度作为返回值返回        var arr = [1, 2, 3];        var result = arr.push(0);//arr = [1, 2, 3, 4], result = 4</code></pre><h3 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h3><ul><li>该方法可以删除数组的最后一个元素,并将被删除的元素作为返回值返回<br>  var arr &#x3D; [1, 2, 3];<br>  var result &#x3D; arr.pop(); &#x2F;&#x2F; result &#x3D; 3, arr &#x3D; [1, 2]</li></ul><h3 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h3><ul><li>向数组开头添加一个或多个元素，并返回新的数组长度</li><li>向前边插入元素以后，其他的元素索引会依次调整<br>  var arr &#x3D; [1, 2, 3];<br>  var result &#x3D; arr.unshift(4, 5); &#x2F;&#x2F; result &#x3D; 5, arr &#x3D; [ 4, 5, 1, 2, 3 ]</li></ul><h3 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h3><ul><li>可以删除数组的第一个元素，并将被删除的元素作为返回值返回<br>  var arr &#x3D; [1, 2, 3];<br>  var result &#x3D; arr.shift(); &#x2F;&#x2F; result &#x3D; 1, arr &#x3D; [2, 3]</li></ul><h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><ul><li><p>可以用来从数组提取指定元素</p></li><li><p>该方法<strong>不会改变元素数组</strong>， 而是将截取到的元素封装到一个新数组中返回<br>参数：<br>  第一个，截取开始的位置的索引, 包含开始索引<br>  第二个，截取结束的位置的索引, 不包含结束索引</p><pre><code class="hljs">      var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;];            var result = arr.slice(2, 3); // result = [ &#39;c&#39; ], arr = [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39; ]      result = arr.slice(2); // result =  [ &#39;c&#39;, &#39;d&#39; ], arr = [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39; ]</code></pre></li><li><p>第二个参数可以省略不写, 此时会截取从开始索引往后的所有元素</p></li><li><p>索引可以传递一个负值， 如果传递一个负值， 则从后往前计算<br>- 1 倒数第一个<br>- 2 倒数第二个</p></li></ul><h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><pre><code class="hljs">- 可以用于删除数组中的指定元素，并向数组中添加新元素- 使用splice()会**影响到原数组**，会将指定元素从原数组中删除，并将被删除的元素作为返回值返回- 参数：- 第一个，表示开始位置的索引- 第二个，表示删除的数量- 第三个及以后。。    可以传递一些新的元素，这些元素将会自动插入到开始位置索引前边        var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;];                var result  = arr.splice(1,2); // result = [ &#39;b&#39;, &#39;c&#39; ], arr = [ &#39;a&#39;, &#39;d&#39; ]        var result  = arr.splice(1, 2, &quot;e&quot;, &quot;f&quot;); // result = [ &#39;b&#39;, &#39;c&#39; ], arr = [ &#39;a&#39;, &#39;e&#39;, &#39;f&#39;, &#39;d&#39; ]</code></pre><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><ul><li>concat()可以连接两个或多个数组，并将新的数组返回</li><li>该方法<strong>不会对原数组产生影响</strong><br>  var arr1 &#x3D; [“a”, “b”, “c”];<br>  var arr2 &#x3D; [“1”, “2”, “3”];<br><br>  var result &#x3D; arr1.concat(arr2); &#x2F;&#x2F; result &#x3D; [ ‘a’, ‘b’, ‘c’, ‘1’, ‘2’, ‘3’ ]</li></ul><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><ul><li>该方法可以将数组转换为一个字符串</li><li>该方法<strong>不会对原数组产生影响</strong>，而是将转换后的字符串作为结果返回</li><li>在join()中可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符，如果不指定连接符，则默认使用,作为连接符，如果指定为空，则会直接将字符连接<br>  var arr1 &#x3D; [“a”, “b”, “c”];<br><br>  var result &#x3D; arr1.join();&#x2F;&#x2F; result &#x3D; a,b,c<br>  var result &#x3D; arr1.join(“@<em>&amp;”); &#x2F;&#x2F; result &#x3D; a@</em>&amp;b@_&amp;c<br>  var result &#x3D; arr1.join(“”); &#x2F;&#x2F; result &#x3D; abc</li></ul><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><ul><li>该方法用来反转数组（前边的去后边，后边的去前边）</li><li>该方法会<strong>直接修改原数组</strong><br>  var arr1 &#x3D; [“a”, “b”, “c”];<br><br> var result &#x3D; arr1.reverse();<br><br> console.log(result); &#x2F;&#x2F;result &#x3D; [ ‘c’, ‘b’, ‘a’ ]<br> console.log(arr1); &#x2F;&#x2F; arr1 &#x3D; [ ‘c’, ‘b’, ‘a’ ]</li></ul><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><ul><li><p>可以用来对数组中的元素进行排序</p></li><li><p>也会<strong>影响原数组</strong>，默认会按照Unicode编码进行排序<br> &#x2F;&#x2F;字符型数组<br> var arr1 &#x3D; [“b”, “d”, “a”, “c”];<br> var result &#x3D; arr1.sort();<br> console.log(result); &#x2F;&#x2F;[ ‘a’, ‘b’, ‘c’, ‘d’ ]<br> console.log(arr1); &#x2F;&#x2F;[ ‘a’, ‘b’, ‘c’, ‘d’ ]<br><br> &#x2F;&#x2F;number型数组，以Unicode编码进行排序<br> var arr2 &#x3D; [2, 5, 7, 21, 13];<br> var result &#x3D; arr2.sort();<br> console.log(result); &#x2F;&#x2F;[ 13, 2, 21, 5, 7 ]<br> console.log(arr2); &#x2F;&#x2F; [ 13, 2, 21, 5, 7 ]</p></li><li><p>对于number型数组，我们可以自己来指定排序的规则</p><ul><li><p>我们可以在sort()添加一个回调函数，来指定排序规则，回调函数中需要定义两个形参，浏览器将会分别使用数组中的元素作为实参去调用回调函数</p></li><li><p>浏览器会根据回调函数的返回值来决定元素的顺序:</p><ul><li><p>如果返回一个大于0的值，则元素会交换位置</p></li><li><p>如果返回一个小于0的值，则元素位置不变</p></li><li><p>如果返回一个0，则认为两个元素相等，也不交换位置</p><pre><code class="hljs">  var result = arr2.sort(function(a, b)&#123;  /*  if(a &gt; b)&#123;      return -1;  &#125;  else if(a &lt; b)&#123;      return 1;  &#125;  else&#123;      return 0;  &#125;  /*      return a - b;//升序，return b - a 则降序  &#125;);  console.log(result); //[ 2, 5, 7, 13, 21 ]  console.log(arr2); //[ 2, 5, 7, 13, 21 ]</code></pre></li></ul><p>  如果需要升序排列，则返回 a - b<br>  如果需要降序排列，则返回 b - a</p></li></ul></li></ul><h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><ul><li>forEach()方法需要一个函数作为参数</li><li>数组中有几个元素函数就会执行几次，每次执行时，浏览器会将遍历到的元素以实参的形式传递进来，我们可以来定义形参，来读取这些内容</li><li>浏览器会在回调函数中传递三个参数：<ul><li>第一个参数（value），就是当前正在遍历的元素</li><li>第二个参数（index），就是当前正在遍历的元素的索引</li><li>第三个参数（object），就是正在遍历的数组<br>  arr.forEach(function(value , index , obj){<br>      console.log(value);<br>  });</li></ul></li><li>列如：<br>  去除数组arr中重复的数字<br>  var arr &#x3D; [1,2,3,2,2,1,3,4,2,5];<br><br>  &#x2F;&#x2F;for循环方式遍历<br>  for(var i &#x3D; 0; i &lt; arr.length; i++){<br>      for(var j &#x3D; i + 1; j &lt; arr.length; j++){<br>          if(arr[i] &#x3D;&#x3D; arr[j]){<br>              arr.splice(j,1);<br>              j–;<br>          }<br>      }<br>  }<br><br>  &#x2F;&#x2F;forEach方式遍历<br>  arr.forEach(function(num, i, arr){&#x2F;&#x2F;num相当于arr[i]<br>      for(var j &#x3D; i + 1; j &lt; arr.length - 1; j++){<br>          if(num &#x3D;&#x3D; arr[j]){<br>              arr.splice(j, 1);<br>              j–;<br>          }<br>      }<br>  });<br><br>  console.log(arr);</li></ul>]]></content>
    
    
    <categories>
      
      <category>javaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类型转换</title>
    <link href="/2021/04/27/javaScript/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>/2021/04/27/javaScript/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><ul><li>类型转换就是指将其他的数据类型，转换为String Number 或 Boolean</li></ul><span id="more"></span><h2 id="转换为String"><a href="#转换为String" class="headerlink" title="转换为String"></a>转换为String</h2><ul><li><p>方式一（强制类型转换）：</p><ul><li>调用被转换数据的toString()方法</li><li>例子：<br>  var a &#x3D; 123;<br>  a &#x3D; a.toString();</li><li>注意：这个方法不适用于null和undefined<br>  由于这两个类型的数据中没有方法，所以调用toString()时会报错</li></ul></li><li><p>方式二（强制类型转换）：</p><ul><li>调用String()函数</li><li>例子：<br>  var a &#x3D; 123;<br>  a &#x3D; String(a);</li><li>原理：对于Number Boolean String都会调用他们的toString()方法来将其转换为字符串，<ul><li>对于null值，直接转换为字符串”null”。</li><li>对于undefined，直接转换为字符串”undefined”</li></ul></li></ul></li><li><p>方式三（隐式的类型转换）: </p><ul><li>为任意的数据类型 +””</li><li>例子：<br>  var a &#x3D; true;<br>  a &#x3D; a + “”;</li><li>原理：和String()函数一样</li></ul></li></ul><h2 id="转换为Number"><a href="#转换为Number" class="headerlink" title="转换为Number"></a>转换为Number</h2><ul><li><p>方式一（强制类型转换）：</p><ul><li>调用Number()函数</li><li>例子：<br>  var s &#x3D; “123”;<br>  s &#x3D; Number(s);</li><li>转换的情况：<br>  1.字符串 –&gt; 数字<br>  如果字符串是一个合法的数字，则直接转换为对应的数字<br>  如果字符串是一个非法的数字，则转换为NaN<br>  如果是一个空串或纯空格的字符串，则转换为0<br>  2.布尔值 –&gt; 数字<br>  true 转换为 1<br>  false 转换为 0<br>  3.空值 null –&gt; 数字<br>  null 转换为 0<br>  4.未定义 undefind–&gt; 数字<br>  undefined 转换为 NaN</li></ul></li><li><p>方式二（强制类型转换）：</p><ul><li><p>调用parseInt()或parseFloat()，这两个函数专门用来将一个字符串转换为数字</p></li><li><p>parseInt()</p><ul><li>可以将一个字符串中的有效的整数位提取出来，并转换为Number</li><li>例子：<br>  var a &#x3D; “123.456px”;<br>  a &#x3D; parseInt(a); &#x2F;&#x2F;123</li><li>如果需要可以在parseInt()中指定一个第二个参数，来指定进制<br>  var a &#x3D; 0xff;<br>  a &#x3D; parseInt(a, 10);&#x2F;&#x2F;255 将16进制a转换为10进制</li></ul></li><li><p>parseFloat()</p><ul><li>可以将一个字符串中的有效的小数位提取出来，并转换为Number</li><li>例子：<br>  var a &#x3D; “123.456px”;<br>  a &#x3D; parseFloat(a); &#x2F;&#x2F;123.456</li></ul></li></ul><p>  注：对非String类型的变量使用parseInt()或parseFloat()方法，会先将变量转换为String类型，然后才转换为number类型</p><pre><code class="hljs">          var a = true;          a = parseInt(a); //NaN      </code></pre></li><li><p>方式三（隐式的类型转换）：</p><ul><li><p>使用一元的+来进行隐式的类型转换</p></li><li><p>例子：<br>  var a &#x3D; “123”;<br>  a &#x3D; +a;</p></li><li><p>原理：和Number()函数一样</p></li></ul></li></ul><p></p><h2 id="转换为布尔值"><a href="#转换为布尔值" class="headerlink" title="转换为布尔值"></a>转换为布尔值</h2><ul><li><p>方式一（强制类型转换）：</p><ul><li>使用Boolean()函数</li><li>例子：<br>  var s &#x3D; “false”;<br>  s &#x3D; Boolean(s); &#x2F;&#x2F;true</li><li>转换的情况<ul><li><p>字符串 –&gt; 布尔<br>  除了空串其余全是true</p></li><li><p>数值 –&gt; 布尔<br>  除了0和NaN其余的全是true</p></li><li><p>对象 —&gt; 布尔<br>  都是true</p></li><li><p>null、undefined —&gt; 布尔<br>  都是false</p></li></ul></li></ul></li><li><p>方式二（隐式类型转换）：</p><ul><li>为任意的数据类型做两次非运算，即可将其转换为布尔值</li><li>例子：<br>  var a &#x3D; “hello”;<br>  a &#x3D; !!a; &#x2F;&#x2F;true</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>javaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本语法</title>
    <link href="/2021/04/27/javaScript/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/04/27/javaScript/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript的基本语法"><a href="#JavaScript的基本语法" class="headerlink" title="JavaScript的基本语法"></a>JavaScript的基本语法</h1><h2 id="JavaScript编写位置"><a href="#JavaScript编写位置" class="headerlink" title="JavaScript编写位置"></a>JavaScript编写位置</h2><ul><li>可以将js代码编写到标签的onclick属性或超链接的href属性中（当我们点击按钮时，js代码才会执行  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;xxx&#x27;);&quot;</span>&gt;</span>button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>`<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:alert(&#x27;xxx&#x27;);&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>可以将js代码编写到script标签</li></ul><p></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;我是script标签中的代码&quot;</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>可以将js代码编写到外部js文件中，然后通过script标签引入  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/script.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <br></code></pre></td></tr></table></figure>注：script标签一旦用于引入外部文件了，就不能在编写代码了，即使编写了浏览器也会忽略<br>如果需要则可以在创建一个新的script标签用于编写内部代码</li></ul><span id="more"></span><h2 id="字面量与变量"><a href="#字面量与变量" class="headerlink" title="字面量与变量"></a>字面量与变量</h2><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>字面量（常量），都是一些不可改变的值<br>比如 ：1 2 3 4 5<br>字面量都是可以直接使用，但是我们一般都不会直接使用字面量</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量可以用来保存字面量，而且变量的值是可以任意改变的<br>变量更加方便我们使用，所以在开发中都是通过变量去保存一个字面量，而很少直接使用字面量，可以通过变量对字面量进行描述</p><h3 id="声明赋值"><a href="#声明赋值" class="headerlink" title="声明赋值"></a>声明赋值</h3><p>通过 <code>var</code> 来声明变量</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">var</span> <span class="hljs-operator">=</span> a<br><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span><br>var b <span class="hljs-operator">=</span> <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>在JS中所有的可以由我们自主命名的都可以称为是标识符</p><ul><li><p>例如：变量名、函数名、属性名都属于标识符</p></li><li><p>命名一个标识符时需要遵守如下的规则：<br>  1.标识符中可以含有字母、数字、<code>_</code>、<code>$</code><br>  2.标识符不能以数字开头<br>  3.标识符不能是ES中的关键字或保留字<br>  4.标识符一般都采用驼峰命名法</p><ul><li>首字母小写，每个单词的开头字母大写，其余字母小写<br>  <code>helloWorld xxxYyyZzz</code></li></ul></li><li><p>JS底层保存标识符时实际上是采用的Unicode编码，所以理论上讲，所有的utf-8中含有的内容都可以作为标识符</p></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>JS中一共分成六种数据类型<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">String 字符串<br><span class="hljs-built_in">Number</span> 数值<br><span class="hljs-built_in">Boolean</span> 布尔值<br><span class="hljs-literal">Null</span> 空值<br><span class="hljs-literal">Undefined</span> 未定义<br>Object 对象<br></code></pre></td></tr></table></figure></li></ul><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a><strong>基本数据类型</strong></h3><h4 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String 字符串"></a><strong>String 字符串</strong></h4><ul><li>JS中的字符串需要使用引号引起来双引号或单引号都行</li><li>在字符串中使用\作为转义字符</li></ul><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">\<span class="hljs-string">&#x27;  ==&gt; &#x27;</span><br>\<span class="hljs-string">&quot;  ==&gt; &quot;</span><br>\n  =<span class="hljs-function">=&gt;</span> 换行<br>\t  =<span class="hljs-function">=&gt;</span> 制表符<br>\\  =<span class="hljs-function">=&gt;</span> \<br></code></pre></td></tr></table></figure><ul><li>使用typeof运算符检查字符串时，会返回”string”</li></ul><p></p><h4 id="Number-数值"><a href="#Number-数值" class="headerlink" title="Number 数值"></a>Number 数值</h4><ul><li>JS中所有的整数和浮点数都是Number类型</li><li>特殊的数字</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-literal">Infinity</span> 正无穷<br>-<span class="hljs-literal">Infinity</span> 负无穷<br><span class="hljs-literal">NaN</span> 非法数字（Not A <span class="hljs-built_in">Number</span>）<br></code></pre></td></tr></table></figure><ul><li>其他进制的数字的表示：</li></ul><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">0</span>b 开头表示二进制，但是不是所有的浏览器都支持<br><span class="hljs-symbol">0 </span>开头表示八进制<br><span class="hljs-number">0</span>x 开头表示十六进制<br></code></pre></td></tr></table></figure><ul><li>使用<code>typeof</code>检查一个Number类型的数据时，会返回<code>number</code><br>（包括NaN 和 Infinity）</li></ul><h4 id="Boolean-布尔值"><a href="#Boolean-布尔值" class="headerlink" title="Boolean 布尔值"></a>Boolean 布尔值</h4><ul><li>布尔值主要用来进行逻辑判断，布尔值只有两个</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span> 逻辑的真<br><span class="hljs-literal">false</span> 逻辑的假<br></code></pre></td></tr></table></figure><ul><li>使用<code>typeof</code>检查一个布尔值时，会返回<code>boolean</code></li></ul><p></p><h4 id="Null-空"><a href="#Null-空" class="headerlink" title="Null 空"></a>Null 空</h4><ul><li>空值专门用来表示为空的对象</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-literal">Null</span>类型的值只有一个 <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><ul><li>使用<code>typeof</code>检查一个Null类型的值时会返回<code>object</code>“</li></ul><h4 id="Undefined-未定义"><a href="#Undefined-未定义" class="headerlink" title="Undefined 未定义"></a>Undefined 未定义</h4><ul><li>如果声明一个变量但是没有为变量赋值此时变量的值就是<code>undefined</code></li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">该类型的值只有一个 <span class="hljs-literal">undefined</span><br></code></pre></td></tr></table></figure><ul><li><p>使用<code>typeof</code>检查一个<code>Undefined</code>类型的值时，会返回<code>undefined</code></p></li><li><p><strong>注：</strong><code>typeof</code> 判断<code>null</code>与<code>array</code>都是返回<code>object</code>。可以用<code>instanceof</code>判断引用数据类型，如 <code>a instanceof Object</code> 返回一个<code>boolean</code>值</p></li></ul><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a><strong>引用数据类型</strong></h3><h4 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object 对象"></a>Object 对象</h4><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li>运算符也称为操作符</li><li>通过运算符可以对一个或多个值进行运算或操作</li></ul><h3 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a>typeof运算符</h3><ul><li>用来检查一个变量的数据类型</li><li>语法：<code>typeof 变量</code></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = <span class="hljs-number">100</span><br>typeof <span class="hljs-selector-tag">a</span> <span class="hljs-comment">//number</span><br></code></pre></td></tr></table></figure><ul><li>它会返回一个用于描述类型的字符串作为结果</li></ul><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">+</span>对两个值进行加法运算并返回结果<br><span class="hljs-bullet">-</span>   对两个值进行减法运算并返回结果<br><span class="hljs-bullet">*</span>对两个值进行乘法运算并返回结果<br>/对两个值进行除法运算并返回结果<br>%对两个值进行取余运算并返回结果<br></code></pre></td></tr></table></figure><ul><li>除了加法以外，对非Number类型的值进行运算时，都会先转换为Number然后在做运算。</li><li>而做加法运算时，如果是两个字符串进行相加，则会做拼串操作，将两个字符连接为一个字符串。</li><li>任何值和字符串做加法，都会先转换为字符串，然后再拼串</li></ul><h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><ul><li>一元运算符只需要一个操作数</li></ul><h3 id="一元的"><a href="#一元的" class="headerlink" title="一元的 +"></a>一元的 +</h3><ul><li>就是正号，不会对值产生任何影响，但是可以将一个非数字转换为数字</li><li>例子：</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">var <span class="hljs-keyword">a</span> = <span class="hljs-literal">true</span><br><span class="hljs-keyword">a</span> = +<span class="hljs-keyword">a</span><br></code></pre></td></tr></table></figure><h3 id="一元的-1"><a href="#一元的-1" class="headerlink" title="一元的 -"></a>一元的 -</h3><ul><li>就是负号，可以对一个数字进行符号位取反</li><li>例子：</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var a <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> -a<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="自增"><a href="#自增" class="headerlink" title="自增"></a>自增</h3><p>自增可以使变量在原值的基础上自增1，自增使用 ++</p><p>自增可以使用 前<code>++</code>（<code>++a</code>）后<code>++</code>(<code>a++</code>)，无论是<code>++a</code> 还是 <code>a++</code>都会立即使原变量自增1</p><p>不同的是<code>++a</code>和<code>a++</code>的值是不同的，<br><code>++a</code>的值是变量的新值（自增后的值）</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">a</span> = a + <span class="hljs-number">1</span><br><span class="hljs-attr">a</span> = a<br></code></pre></td></tr></table></figure><p><code>a++</code>的值是变量的原值（自增前的值）</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">a</span> = a<br><span class="hljs-attr">a</span> = a + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="自减"><a href="#自减" class="headerlink" title="自减"></a>自减</h3><p>自减可以使变量在原值的基础上自减1，自减使用 <code>--</code><br>自减可以使用 前<code>--</code>（<code>--a</code>）后<code>--</code>(<code>a--</code>)，无论是<code>--a</code> 还是 a–都会立即使原变量自减1</p><p>不同的是–a和a–的值是不同的，</p><p><code>--a</code>的值是变量的新值（自减后的值）</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> a - <span class="hljs-number">1</span><br><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> a<br></code></pre></td></tr></table></figure><p>  <code>a--</code>的值是变量的原值（自减前的值）</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> a<br><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> a - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>javaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
